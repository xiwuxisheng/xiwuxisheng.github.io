<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>曲终</title>
    <url>/2022/04/24/%E6%95%A3%E6%96%87/%E6%9B%B2%E7%BB%88/</url>
    <content><![CDATA[<p><b>生与死，不过是阴与阳的轮转！</b></p>
<p><b>花开花落，亦不过是一场轮回！</b></p>
<p><b>相遇与分离，既是欣喜，也是无奈！</b></p>
<p><img src="/images/poem/quzhong1.jpeg"></p>
<p>白天埋头在“搬砖”的海洋里，尽情遨游，似乎让我忘记了一切烦恼，这些烦恼里面既有对未来不可确定的恐惧，也有对原生熟悉的人渐渐陌生的不安，更多的是对身边发生变化的慌不择路。看到坐在旁边熟悉的人，心里止不住涌起一股悲伤。3年前，我们是同一天同一个时刻入职了这家公司，满怀着憧憬和希望，浑身似乎燃起了火焰，想要将阻挡在我们前进道路上的所有名为困难的石头统统搬开。大家一起欢笑着，比拼着，揶揄着，单纯而年轻。再来看如今，熟悉的面孔一张张从眼前消失，一直以为自己的生活就该如此一成不变，但是我错了，当你安然享受这份宁静时，意外总是随之而来。我已经经受了一场场的离别，虽然每次在最后的时刻里，大家欢笑着畅所欲言地诉说着各自的奇闻趣事，未来生活的展望，可终归那是一场虚假的欢乐，离别总是在欢乐之后。最终，连这最后熟悉的面孔也要离开了。我其实很清楚，大家的离开虽然依然在深圳这座城市里面，但是已经决定了，这次的离别，大概率就是未来一生的不可见。</p>
<p><img src="/images/poem/quzhong2.jpeg"></p>
<p>人与人之间本身并无关联，也无需推动，也无需言语，淡淡的陪伴润物细无声，于无声处让你习惯起来，你习惯了这个人的玩笑话，你习惯了这个人的脸庞，你习惯了这个人的喜怒哀乐，因为习惯，所以产生了微妙的联系，这个联系就是熟悉感。但是熟悉感的逝去不经意间就会让人无奈，充满感伤。毕业季时各奔东西的分离，朋友间渐渐不再联系的陌生，同事离开后的慢慢遗忘，虽是亲人却渐渐没有言语的寂寞，这些都是成熟后对于离别习以为常的冷漠。我似乎是长大了，但是却也没长大，因为我依然不习惯离别。</p>
<p>夜未央，繁星在天边闪耀，黑暗透彻的眼眸中倒映着微微的星辉，恰如一段柔然的光芒照进了心底。海岸城五光十色的绚烂里，我们觥筹交错，我们诉说着以往的趣事，怀念着一起开团的兴奋愉悦，也推杯倒酒，将这份宴会的欢乐和着酒味融入各自的心底，虽然来来回回说了多少废话，但是依然乐此不疲，作为组织的同事，给我们介绍了苏州的各道名菜，里面有红烧松江鱼、糯米藕、红烧肉、东坡肉、苏州烤鸭、酒酿丸子等，苏杭一带主要吃的是甜食，所以这些菜实际上味道很不错，但是太腻味了，就吃了几道菜我们就已经吃不下了。我从心里是希望时间停留在这一刻，可是曲终终将人散，离别的那一刻，同事的脸上依然是曾经灿烂的笑容，似乎比平常更显得耀眼，我回头往着他，想说什么却什么也没说出来，最后他似乎释然了，玩笑似的给我敬了一个礼，我赶紧回了一个礼，这一刻，我明白了，人生无常，有来有往，相遇是缘分，离别也是平常，有些人能在一起熟悉共事了三年，未来陌生一世，已然足够。“无可奈何花落去，似曾相识燕归来”，熟悉的人离开，但也会有新的人相遇。</p>
<p><img src="/images/poem/quzhong3.jpeg"></p>
<p>或许明天他就不在曾经熟悉的座位上了，我决定将这份过往储藏，为它编制一段美好的梦想，去幻想，去欢乐，用来阻隔我的脆弱，抵御我的悲伤。也许当我老了，有一天我看见旷野霜降，星河流淌，即使那时泪光低垂，忆起这段过往，我也不会感到悲伤，因为这就是我所经历的人生啊。</p>
<p><img src="/images/poem/quzhong4.jpeg"></p>
<p>——————  2022年4月24日晚随笔</p>
]]></content>
      <categories>
        <category>散文</category>
      </categories>
      <tags>
        <tag>离别, 辞职, 新的人, 曲终</tag>
      </tags>
  </entry>
  <entry>
    <title>Framework与XCFramework的制作</title>
    <url>/2022/02/27/iOS/Framework%20%E4%B8%8E%20XCFramework%E7%9A%84%E5%88%B6%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>由于Xcode11引入了<strong>XCFramework</strong>这个库概念，所以我们看到的二进制第三方库中都包含了两个文件，一个是.framework，而另外一个则是.xcframework,为什么多出了一个xcframework的文件，这个文件代表的意思是什么呢，以及如何制作这种新类型的二进制包？那首先我们必须先来了解几个概念。</p>
<h2 id="Library"><a href="#Library" class="headerlink" title="Library"></a>Library</h2><p><strong>作用：</strong></p>
<p>App的设计为了达到共享复制的目的，那么一般是把通用的函数或者功能模块制作成一个公共库。</p>
<p><strong>定义：</strong></p>
<p>目标文件的集合，即将相关的目标文件打包在一起，就成了一个 Library。</p>
<h2 id="静态库-Static-Library"><a href="#静态库-Static-Library" class="headerlink" title="静态库(Static Library)"></a>静态库(Static Library)</h2><p><strong>文件形式：</strong></p>
<p>.a，.lib 的形式存在，iOS中还可以是.framework或.xcframework</p>
<p><strong>使用原理：</strong></p>
<p>App自身的代码被编译成目标文件后，通过静态链接器将App的目标文件与静态库合并，并生成可执行文件。这样，App自身代码生成的目标文件与静态库都被拷贝到可执行文件中，从而让静态库也成为了App可执行文件的一部分。</p>
<p><img src="/images/framework/document_image_rId11.jpeg"></p>
<p><strong>特点包括：</strong></p>
<ul>
<li><p>  App启动时就全部加入内存，由于使用的是静态库，不需要从外部链接加载，所以加载速度很快，但是又因为增加了内容过多导致启动速度慢</p>
</li>
<li><p>  静态库文件会被静态链接器链接并复制到生成的可执行文件中，导致可执行文件增大，占用内存也会增多</p>
</li>
<li><p>  由于静态库是制作好的二进制库，如果发生变更，需要重新编译，给维护带来不便</p>
</li>
</ul>
<h2 id="动态库-Dynamic-Library"><a href="#动态库-Dynamic-Library" class="headerlink" title="动态库(Dynamic Library)"></a>动态库(Dynamic Library)</h2><p><strong>文件形式：</strong></p>
<p>以.dylib，.so，.dll的形式存在，iOS中还可以是.framework或.xcframework</p>
<p>iOS App的动态库存放在.app bundle下的Frameworks 文件夹</p>
<p><strong>使用原理：</strong></p>
<p>以 OS X 为例，当 App 启动时，操作系统内核会将 App<br>代码和数据载入新进程(也就是操作系统为 App<br>创建的新进程)的地址空间。与此同时呢，操作系统内核也会把动态加载器(Dynamic<br>Loader)<br>载入进程，由动态加载器来完成加载App依赖的动态库。不过在启动阶段，动态加载器只会根据静态链接器中记录的<br>App 已链接的依赖库的名字，然后使用依赖库的 install<br>name来查找它们是否在文件系统中存在。如果不存在或不兼容，App<br>启动过程会中断。动态库被完全载入内存，是在代码里使用它的时候。所以相对静态库来说，使用动态库链接的<br>App 启动过程会更快。</p>
<p><img src="/images/framework/document_image_rId12.jpeg"></p>
<p><strong>特点包括：</strong></p>
<ul>
<li><p>  由于按需加载，可以加快App启动</p>
</li>
<li><p>  不会被加载复制到可执行文件中，所以可以动态按需加载</p>
</li>
<li><p>  维护更新方便，只要api不变，动态库变更，依赖动态库的App无需重新编译。因为重新编译主要是App的可执行文件部分，而动态库不属于其中，而是独立的，可动态加载</p>
</li>
</ul>
<h2 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h2><p>Framework通俗的理解为封装了共享资源的具有层次结构的文件夹。共享资源可以是<br>nib文件、国际化字符串文件、头文件、库文件等等。它同时也是个Bundle，里面的内容可以通过<br>Bundle相关 API来访问。Framework可以是static framework或dynamic<br>framework。在iOS App打包完成后，如果Framework包含了模拟器指令集(x86_64<br>或 i386)，那么用 Xcode 发布 App 的时候，会报unsupported<br>architectures的错误，所以需要我们手动或脚本去移除。</p>
<h2 id="XCFramework"><a href="#XCFramework" class="headerlink" title="XCFramework"></a>XCFramework</h2><p>XCFramework是由Xcode创建的一个可分发的二进制包，包含了framework或library<br>的一个或多个变体，因此可以在多个平台(iOS、macOS、tvOS、watchOS)上使用，包括模拟器。XCFramework可以是静态的也可以是动态的。XCFramework的好处就是用<br>Xcode<br>发布的时候，Xcode会自动选用正确的指令集Frameworks，省去了手动移除动态库中的模拟器指令集的工作。</p>
<h2 id="制作-Frameworks"><a href="#制作-Frameworks" class="headerlink" title="制作 Frameworks"></a>制作 Frameworks</h2><p>假设您的framework代码都已经写好了，打包的Aggregation<br>Target也创建好了。接下来，我将直接讲用脚本来制作frameworks。至于是制作static<br>framework还是dynamic framework可以在framework target的 Build<br>Settings中的Mach-O Type选择framework的类型，一般选用Dynamic<br>Library或者Static Library就行。</p>
<h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p>Xcode11.0+</p>
<p>macOS Catalina 10.15.0+</p>
<h3 id="xcarchive-目录结构"><a href="#xcarchive-目录结构" class="headerlink" title=".xcarchive 目录结构"></a>.xcarchive 目录结构</h3><p>制作universal<br>framework与xcframework，我们都会用到.xcarchive包，所以我们先来看下它的目录结构</p>
<p><img src="/images/framework/document_image_rId13.png"></p>
<h2 id="制作Universal-Framework脚本"><a href="#制作Universal-Framework脚本" class="headerlink" title="制作Universal Framework脚本"></a>制作Universal Framework脚本</h2><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">#!/bin/sh -e<br><br>REVEAL_FRAMEWORK_IN_FINDER=true<br><br>BUILD_DIR=\&quot;\$&#123;PROJECT_DIR&#125;/Build\&quot;<br><br>FREAMEWORK_NAME=\&quot;\$&#123;PROJECT_NAME&#125;\&quot;<br><br>FREAMEWORK_OUTPUT_DIR=\&quot;\$&#123;PROJECT_DIR&#125;/Distribution\&quot;<br><br>ARCHIVE_PATH_IOS_DEVICE=\&quot;\$&#123;BUILD_DIR&#125;/ios_device<span class="hljs-selector-class">.xcarchive</span>\&quot;<br><br>ARCHIVE_PATH_IOS_SIMULATOR=\&quot;\$&#123;BUILD_DIR&#125;/ios_simulator<span class="hljs-selector-class">.xcarchive</span>\&quot;<br><br>\# ARCHIVE_PATH_MACOS=\&quot;./build/macos<span class="hljs-selector-class">.xcarchive</span>\&quot;<br><br>function archiveOnePlatform &#123;<br><br>echo \&quot;▸ Starts archiving the scheme: \$&#123;<span class="hljs-number">1</span>&#125; for destination: \$&#123;<span class="hljs-number">2</span>&#125;;\\n▸<br>Archive path: \$&#123;<span class="hljs-number">3</span>&#125;\&quot;<br><br>xcodebuild archive \\<br><br>-scheme \&quot;\$&#123;<span class="hljs-number">1</span>&#125;\&quot; \\<br><br>-destination \&quot;\$&#123;<span class="hljs-number">2</span>&#125;\&quot; \\<br><br>-archivePath \&quot;\$&#123;<span class="hljs-number">3</span>&#125;\&quot; \\<br><br>VALID_ARCHS=\&quot;\$&#123;<span class="hljs-number">4</span>&#125;\&quot; \\<br><br>SKIP_INSTALL=NO \\<br><br>BUILD_LIBRARY_FOR_DISTRIBUTION=YES \| xcpretty<br><br>\# sudo gem install -n /usr/local/bin xcpretty<br><br>\# xcpretty makes xcode compile information much more readable.<br><br>&#125;<br><br>function archiveAllPlatforms &#123;<br><br>\# https://www.mokacoding.com/blog/xcodebuild-destination-options/<br><br>\# Platform Destination<br><br>\# iOS generic/platform=iOS<br><br>\# iOS Simulator generic/platform=iOS Simulator<br><br>\# iPadOS generic/platform=iPadOS<br><br>\# iPadOS Simulator generic/platform=iPadOS Simulator<br><br>\# macOS generic/platform=macOS<br><br>\# tvOS generic/platform=tvOS<br><br>\# watchOS generic/platform=watchOS<br><br>\# watchOS Simulator generic/platform=watchOS Simulator<br><br>\# carPlayOS generic/platform=carPlayOS<br><br>\# carPlayOS Simulator generic/platform=carPlayOS Simulator<br><br>SCHEME=\$&#123;<span class="hljs-number">1</span>&#125;<br><br>archiveOnePlatform \$SCHEME \&quot;generic/platform=iOS Simulator\&quot;<br>\$&#123;ARCHIVE_PATH_IOS_SIMULATOR&#125; \&quot;x86_64\&quot;<br><br>archiveOnePlatform \$SCHEME \&quot;generic/platform=iOS\&quot;<br>\$&#123;ARCHIVE_PATH_IOS_DEVICE&#125; \&quot;armv7 arm64\&quot;<br><br>\# archiveOnePlatform \$SCHEME \&quot;generic/platform=macOS\&quot;<br>\$&#123;ARCHIVE_PATH_MACOS&#125;<br><br>&#125;<br><br>function makeUniversalFramework &#123;<br><br>FRAMEWORK_RELATIVE_PATH=\&quot;Products/Library/Frameworks\&quot;<br><br>SIMULATOR_FRAMEWORK=\&quot;\$&#123;ARCHIVE_PATH_IOS_SIMULATOR&#125;/\$&#123;FRAMEWORK_RELATIVE_PATH&#125;/\$&#123;FREAMEWORK_NAME&#125;<span class="hljs-selector-class">.framework</span>\&quot;<br><br>DEVICE_FRAMEWORK=\&quot;\$&#123;ARCHIVE_PATH_IOS_DEVICE&#125;/\$&#123;FRAMEWORK_RELATIVE_PATH&#125;/\$&#123;FREAMEWORK_NAME&#125;<span class="hljs-selector-class">.framework</span>\&quot;<br><br>OUTPUT_FRAMEWORK=\&quot;\$&#123;FREAMEWORK_OUTPUT_DIR&#125;/\$&#123;FREAMEWORK_NAME&#125;<span class="hljs-selector-class">.framework</span>\&quot;<br><br>mkdir -<span class="hljs-selector-tag">p</span> \&quot;\$&#123;OUTPUT_FRAMEWORK&#125;\&quot;<br><br>\# Copy all the contents of iphoneos framework <span class="hljs-selector-tag">to</span> output framework dir.<br><br>cp -rf \&quot;\$&#123;DEVICE_FRAMEWORK&#125;/.\&quot; \&quot;\$&#123;OUTPUT_FRAMEWORK&#125;\&quot;<br><br>lipo \&quot;\$&#123;SIMULATOR_FRAMEWORK&#125;/\$&#123;FREAMEWORK_NAME&#125;\&quot;<br>\&quot;\$&#123;DEVICE_FRAMEWORK&#125;/\$&#123;FREAMEWORK_NAME&#125;\&quot; \\<br><br>-create -output \&quot;\$&#123;OUTPUT_FRAMEWORK&#125;/\$&#123;FREAMEWORK_NAME&#125;\&quot;<br><br>\# For Swift framework, Swiftmodule needs <span class="hljs-selector-tag">to</span> be copied in the universal<br>framework<br><br>if \<span class="hljs-selector-attr">[ -d\<span class="hljs-string">&quot;\$&#123;SIMULATOR_FRAMEWORK&#125;/Modules/\$&#123;FRAMEWORK_NAME&#125;.swiftmodule/\&quot; \];</span></span><br><span class="hljs-string"><span class="hljs-selector-attr">then</span></span><br><span class="hljs-string"><span class="hljs-selector-attr"></span></span><br><span class="hljs-string"><span class="hljs-selector-attr">cp -f</span></span><br><span class="hljs-string"><span class="hljs-selector-attr">\&quot;\$&#123;SIMULATOR_FRAMEWORK&#125;/Modules/\$&#123;FRAMEWORK_NAME&#125;.swiftmodule/\*\&quot;</span></span><br><span class="hljs-string"><span class="hljs-selector-attr">\&quot;\$&#123;OUTPUT_FRAMEWORK&#125;/Modules/\$&#123;FRAMEWORK_NAME&#125;.swiftmodule/\&quot; \| echo</span></span><br><span class="hljs-string"><span class="hljs-selector-attr"></span></span><br><span class="hljs-string"><span class="hljs-selector-attr">fi</span></span><br><span class="hljs-string"><span class="hljs-selector-attr"></span></span><br><span class="hljs-string"><span class="hljs-selector-attr">if \[ -d</span></span><br><span class="hljs-string"><span class="hljs-selector-attr">\&quot;\$&#123;DEVICE_FRAMEWORK&#125;/Modules/\$&#123;FRAMEWORK_NAME&#125;.swiftmodule/\&quot; \];</span></span><br><span class="hljs-string"><span class="hljs-selector-attr">then</span></span><br><span class="hljs-string"><span class="hljs-selector-attr"></span></span><br><span class="hljs-string"><span class="hljs-selector-attr">cp -f \&quot;\$&#123;DEVICE_FRAMEWORK&#125;/Modules/\$&#123;FRAMEWORK_NAME&#125;.swiftmodule/\*\&quot;</span></span><br><span class="hljs-string"><span class="hljs-selector-attr">\&quot;\$&#123;OUTPUT_FRAMEWORK&#125;/Modules/\$&#123;FRAMEWORK_NAME&#125;.swiftmodule/\&quot; \| echo</span></span><br><span class="hljs-string"><span class="hljs-selector-attr"></span></span><br><span class="hljs-string"><span class="hljs-selector-attr">fi</span></span><br><span class="hljs-string"><span class="hljs-selector-attr"></span></span><br><span class="hljs-string"><span class="hljs-selector-attr">&#125;</span></span><br><span class="hljs-string"><span class="hljs-selector-attr"></span></span><br><span class="hljs-string"><span class="hljs-selector-attr">echo \&quot;#####################\&quot;</span></span><br><span class="hljs-string"><span class="hljs-selector-attr"></span></span><br><span class="hljs-string"><span class="hljs-selector-attr">echo \&quot;▸ Cleaning Framework output dir: \$&#123;FREAMEWORK_OUTPUT_DIR&#125;\&quot;</span></span><br><span class="hljs-string"><span class="hljs-selector-attr"></span></span><br><span class="hljs-string"><span class="hljs-selector-attr">rm -rf \&quot;\$FREAMEWORK_OUTPUT_DIR\&quot;</span></span><br><span class="hljs-string"><span class="hljs-selector-attr"></span></span><br><span class="hljs-string"><span class="hljs-selector-attr">\#### Make Dynamic Framework</span></span><br><span class="hljs-string"><span class="hljs-selector-attr"></span></span><br><span class="hljs-string"><span class="hljs-selector-attr">echo \&quot;▸ Archive framework: \$&#123;FREAMEWORK_NAME&#125;\&quot;</span></span><br><span class="hljs-string"><span class="hljs-selector-attr"></span></span><br><span class="hljs-string"><span class="hljs-selector-attr">archiveAllPlatforms \&quot;\$FREAMEWORK_NAME\&quot;</span></span><br><span class="hljs-string"><span class="hljs-selector-attr"></span></span><br><span class="hljs-string"><span class="hljs-selector-attr">echo \&quot;▸ Make universal framework: \$&#123;FREAMEWORK_NAME&#125;.framework\&quot;</span></span><br><span class="hljs-string"><span class="hljs-selector-attr"></span></span><br><span class="hljs-string"><span class="hljs-selector-attr">makeUniversalFramework</span></span><br><span class="hljs-string"><span class="hljs-selector-attr"></span></span><br><span class="hljs-string"><span class="hljs-selector-attr">\# Clean Build</span></span><br><span class="hljs-string"><span class="hljs-selector-attr"></span></span><br><span class="hljs-string"><span class="hljs-selector-attr">rm -rf \&quot;&#123;\$BUILD_DIR&#125;\&quot;</span></span><br><span class="hljs-string"><span class="hljs-selector-attr"></span></span><br><span class="hljs-string"><span class="hljs-selector-attr">if \[ \$&#123;REVEAL_FRAMEWORK_IN_FINDER&#125; = true \]; then</span></span><br><span class="hljs-string"><span class="hljs-selector-attr"></span></span><br><span class="hljs-string"><span class="hljs-selector-attr">open \&quot;\$&#123;FREAMEWORK_OUTPUT_DIR&#125;/\&quot;</span></span><br><span class="hljs-string"><span class="hljs-selector-attr"></span></span><br><span class="hljs-string"><span class="hljs-selector-attr">fi</span></span><br></code></pre></td></tr></table></figure>

<h3 id="编译单个平台的函数"><a href="#编译单个平台的函数" class="headerlink" title="编译单个平台的函数"></a>编译单个平台的函数</h3><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">\# 制作完 framework 后，是否在 Finder 中打开<br><br>REVEAL_FRAMEWORK_IN_FINDER=true<br><br>\# Framework 的名字<br><br>FREAMEWORK_NAME=\&quot;\$&#123;PROJECT_NAME&#125;\&quot;<br><br>\# 制作好的 framework 会输出到这个文件夹下面<br><br>FREAMEWORK_OUTPUT_DIR=\&quot;\$&#123;PROJECT_DIR&#125;/Distribution\&quot;<br><br>\# Device Archive 生成的 <span class="hljs-selector-class">.xcarchive</span> 存放路径。在工程的根目录下生成 Build<br>文件夹。<br><br>ARCHIVE_PATH_IOS_DEVICE=\&quot;./Build/ios_device<span class="hljs-selector-class">.xcarchive</span>\&quot;<br><br>\# Simulator Archive 生成的 <span class="hljs-selector-class">.xcarchive</span> 存放路径。<br><br>ARCHIVE_PATH_IOS_SIMULATOR=\&quot;./Build/ios_simulator<span class="hljs-selector-class">.xcarchive</span>\&quot;<br><br>\# 我们可以编译更多平台的 xcarchive<br><br>\# ARCHIVE_PATH_MACOS=\&quot;./build/macos<span class="hljs-selector-class">.xcarchive</span>\&quot;<br><br>\# 生成单个平台的 <span class="hljs-selector-class">.xcarchive</span>. 接收<span class="hljs-number">4</span>个参数， scheme, destination,<br>archivePath，指令集.<br><br>\# xcpretty 可以删除，这里用来使 Xcode 输出的日志更加人性化。<br><br>function archiveOnePlatform &#123;<br><br>echo \&quot;▸ Starts archiving the scheme: \$&#123;<span class="hljs-number">1</span>&#125; for destination: \$&#123;<span class="hljs-number">2</span>&#125;;\\n▸<br>Archive path: \$&#123;<span class="hljs-number">3</span>&#125;\&quot;<br><br>xcodebuild archive \\<br><br>-scheme \&quot;\$&#123;<span class="hljs-number">1</span>&#125;\&quot; \\<br><br>-destination \&quot;\$&#123;<span class="hljs-number">2</span>&#125;\&quot; \\<br><br>-archivePath \&quot;\$&#123;<span class="hljs-number">3</span>&#125;\&quot; \\<br><br>VALID_ARCHS=\&quot;\$&#123;<span class="hljs-number">4</span>&#125;\&quot; \\<br><br>SKIP_INSTALL=NO \\<br><br>BUILD_LIBRARY_FOR_DISTRIBUTION=YES \| xcpretty<br><br>\# BUILD_LIBRARY_FOR_DISTRIBUTION=YES<br><br>\# sudo gem install -n /usr/local/bin xcpretty<br><br>\# xcpretty makes xcode compile information much more readable.<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="编译所有平台的函数"><a href="#编译所有平台的函数" class="headerlink" title="编译所有平台的函数"></a>编译所有平台的函数</h3><p>以下方法可以编译并生成iOS device,<br>simulator两个平台的.xcarchive，此方法接收一个参数：scheme, 即对应app<br>target的scheme。通常情况下，scheme和framework name是相同的。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">function archiveAllPlatforms &#123;<br><br>\# https://www.mokacoding.com/blog/xcodebuild-destination-options/<br><br>\# Platform Destination<br><br>\# iOS generic/platform=iOS<br><br>\# iOS Simulator generic/platform=iOS Simulator<br><br>\# iPadOS generic/platform=iPadOS<br><br>\# iPadOS Simulator generic/platform=iPadOS Simulator<br><br>\# macOS generic/platform=macOS<br><br>\# tvOS generic/platform=tvOS<br><br>\# watchOS generic/platform=watchOS<br><br>\# watchOS Simulator generic/platform=watchOS Simulator<br><br>\# carPlayOS generic/platform=carPlayOS<br><br>\# carPlayOS Simulator generic/platform=carPlayOS Simulator<br><br>SCHEME=\$&#123;<span class="hljs-number">1</span>&#125;<br><br>archiveOnePlatform \$SCHEME \&quot;generic/platform=iOS Simulator\&quot;<br>\$&#123;ARCHIVE_PATH_IOS_SIMULATOR&#125; \&quot;x86_64\&quot;<br><br>archiveOnePlatform \$SCHEME \&quot;generic/platform=iOS\&quot;<br>\$&#123;ARCHIVE_PATH_IOS_DEVICE&#125; \&quot;armv7 arm64\&quot;<br><br>\# archiveOnePlatform \$SCHEME \&quot;generic/platform=macOS\&quot;<br>\$&#123;ARCHIVE_PATH_MACOS&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个方法执行完后，在本例中会得到以下Build文件夹内的内容：</p>
<p><img src="/images/framework/document_image_rId14.png"></p>
<h3 id="生成Universal-Framework的函数"><a href="#生成Universal-Framework的函数" class="headerlink" title="生成Universal Framework的函数"></a>生成Universal Framework的函数</h3><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">function makeUniversalFramework &#123;<br><br>\# xcarchive 包中的 Frameworks 目录相对路径<br><br>FRAMEWORK_RELATIVE_PATH=\&quot;Products/Library/Frameworks\&quot;<br><br>\#<br>接下来的三个路径分别是模拟器平台的framework路径，真机平台的framework路径，以及输出的universal<br>framework路径<br><br>SIMULATOR_FRAMEWORK=\&quot;\$&#123;ARCHIVE_PATH_IOS_SIMULATOR&#125;/\$&#123;FRAMEWORK_RELATIVE_PATH&#125;/\$&#123;FREAMEWORK_NAME&#125;<span class="hljs-selector-class">.framework</span>\&quot;<br><br>DEVICE_FRAMEWORK=\&quot;\$&#123;ARCHIVE_PATH_IOS_DEVICE&#125;/\$&#123;FRAMEWORK_RELATIVE_PATH&#125;/\$&#123;FREAMEWORK_NAME&#125;<span class="hljs-selector-class">.framework</span>\&quot;<br><br>OUTPUT_FRAMEWORK=\&quot;\$&#123;FREAMEWORK_OUTPUT_DIR&#125;/\$&#123;FREAMEWORK_NAME&#125;<span class="hljs-selector-class">.framework</span>\&quot;<br><br>mkdir -<span class="hljs-selector-tag">p</span> \&quot;\$&#123;OUTPUT_FRAMEWORK&#125;\&quot;<br><br>\# Copy all the contents of iphoneos framework <span class="hljs-selector-tag">to</span> output framework dir.<br><br>cp -rf \&quot;\$&#123;DEVICE_FRAMEWORK&#125;/.\&quot; \&quot;\$&#123;OUTPUT_FRAMEWORK&#125;\&quot;<br><br>lipo \&quot;\$&#123;SIMULATOR_FRAMEWORK&#125;/\$&#123;FREAMEWORK_NAME&#125;\&quot;<br>\&quot;\$&#123;DEVICE_FRAMEWORK&#125;/\$&#123;FREAMEWORK_NAME&#125;\&quot; \\<br><br>-create -output \&quot;\$&#123;OUTPUT_FRAMEWORK&#125;/\$&#123;FREAMEWORK_NAME&#125;\&quot;<br><br>\# For Swift framework, Swiftmodule needs <span class="hljs-selector-tag">to</span> be copied in the universal<br>framework<br><br>if \<span class="hljs-selector-attr">[ -d\<span class="hljs-string">&quot;\$&#123;SIMULATOR_FRAMEWORK&#125;/Modules/\$&#123;FRAMEWORK_NAME&#125;.swiftmodule/\&quot; \];</span></span><br><span class="hljs-string"><span class="hljs-selector-attr">then</span></span><br><span class="hljs-string"><span class="hljs-selector-attr"></span></span><br><span class="hljs-string"><span class="hljs-selector-attr">cp -f</span></span><br><span class="hljs-string"><span class="hljs-selector-attr">\&quot;\$&#123;SIMULATOR_FRAMEWORK&#125;/Modules/\$&#123;FRAMEWORK_NAME&#125;.swiftmodule/\*\&quot;</span></span><br><span class="hljs-string"><span class="hljs-selector-attr">\&quot;\$&#123;OUTPUT_FRAMEWORK&#125;/Modules/\$&#123;FRAMEWORK_NAME&#125;.swiftmodule/\&quot; \| echo</span></span><br><span class="hljs-string"><span class="hljs-selector-attr"></span></span><br><span class="hljs-string"><span class="hljs-selector-attr">fi</span></span><br><span class="hljs-string"><span class="hljs-selector-attr"></span></span><br><span class="hljs-string"><span class="hljs-selector-attr">if \[ -d</span></span><br><span class="hljs-string"><span class="hljs-selector-attr">\&quot;\$&#123;DEVICE_FRAMEWORK&#125;/Modules/\$&#123;FRAMEWORK_NAME&#125;.swiftmodule/\&quot; \];</span></span><br><span class="hljs-string"><span class="hljs-selector-attr">then</span></span><br><span class="hljs-string"><span class="hljs-selector-attr"></span></span><br><span class="hljs-string"><span class="hljs-selector-attr">cp -f \&quot;\$&#123;DEVICE_FRAMEWORK&#125;/Modules/\$&#123;FRAMEWORK_NAME&#125;.swiftmodule/\*\&quot;</span></span><br><span class="hljs-string"><span class="hljs-selector-attr">\&quot;\$&#123;OUTPUT_FRAMEWORK&#125;/Modules/\$&#123;FRAMEWORK_NAME&#125;.swiftmodule/\&quot; \| echo</span></span><br><span class="hljs-string"><span class="hljs-selector-attr"></span></span><br><span class="hljs-string"><span class="hljs-selector-attr">fi</span></span><br><span class="hljs-string"><span class="hljs-selector-attr"></span></span><br><span class="hljs-string"><span class="hljs-selector-attr">&#125;</span></span><br></code></pre></td></tr></table></figure>

<h3 id="开始制作"><a href="#开始制作" class="headerlink" title="开始制作"></a>开始制作</h3><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">echo \&quot;#####################\&quot;<br><br>echo \&quot;▸ Cleaning Framework output dir: \$&#123;FREAMEWORK_OUTPUT_DIR&#125;\&quot;<br><br>rm -rf \&quot;\$FREAMEWORK_OUTPUT_DIR\&quot;<br><br>echo \&quot;▸ Archive framework: \$&#123;FREAMEWORK_NAME&#125;\&quot;<br><br>archiveAllPlatforms \&quot;\$FREAMEWORK_NAME\&quot;<br><br>echo \&quot;▸ Make universal framework: \$&#123;FREAMEWORK_NAME&#125;<span class="hljs-selector-class">.framework</span>\&quot;<br><br>makeUniversalFramework<br><br>\# Clean Build<br><br>rm -rf \&quot;./Build\&quot;<br><br>if \<span class="hljs-selector-attr">[ \$&#123;REVEAL_FRAMEWORK_IN_FINDER&#125; = true \]</span>; then<br><br>open \&quot;\$&#123;FREAMEWORK_OUTPUT_DIR&#125;/\&quot;<br><br>fi<br></code></pre></td></tr></table></figure>

<h3 id="去除动态库中的模拟器指令集"><a href="#去除动态库中的模拟器指令集" class="headerlink" title="去除动态库中的模拟器指令集"></a>去除动态库中的模拟器指令集</h3><p>App打包过程中，需要将App依赖的动态库中的模拟器指令集去除，这里是完整的脚本,<br>如何使用，请点Stripping unwanted architectures from dynamic<br>libraries。在app target 的 Build Phase下新建Run Script，并放到Embed<br>Frameworks下面，然后将脚本复制进去就行。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">#!/bin/sh<br><br>APP_PATH=\&quot;\$&#123;TARGET_BUILD_DIR&#125;/\$&#123;WRAPPER_NAME&#125;\&quot;<br><br>echo \$APP_PATH<br><br>\# This script loops through the frameworks embedded in the application<br>and<br><br>\# removes unused architectures.<br><br>find \&quot;\$APP_PATH\&quot; -name \&#x27;\*<span class="hljs-selector-class">.framework</span>\&#x27; -type d \| while read -r<br>FRAMEWORK<br><br>do<br><br>FRAMEWORK_EXECUTABLE_NAME=\$(defaults read \&quot;\$FRAMEWORK/Info<span class="hljs-selector-class">.plist</span>\&quot;<br>CFBundleExecutable)<br><br>FRAMEWORK_EXECUTABLE_PATH=\&quot;\$FRAMEWORK/\$FRAMEWORK_EXECUTABLE_NAME\&quot;<br><br>echo \&quot;Executable is \$FRAMEWORK_EXECUTABLE_PATH\&quot;<br><br>EXTRACTED_ARCHS=()<br><br>for ARCH in \$ARCHS<br><br>do<br><br>echo \&quot;Extracting \$ARCH <span class="hljs-selector-tag">from</span> \$FRAMEWORK_EXECUTABLE_NAME\&quot;<br><br>lipo -extract \&quot;\$ARCH\&quot; \&quot;\$FRAMEWORK_EXECUTABLE_PATH\&quot; -o<br>\&quot;\$FRAMEWORK_EXECUTABLE_PATH-\$ARCH\&quot;<br><br>EXTRACTED_ARCHS+=(\&quot;\$FRAMEWORK_EXECUTABLE_PATH-\$ARCH\&quot;)<br><br>done<br><br>echo \&quot;Merging extracted architectures: \$&#123;ARCHS&#125;\&quot;<br><br>lipo -o \&quot;\$FRAMEWORK_EXECUTABLE_PATH-merged\&quot; -create<br>\&quot;\$&#123;EXTRACTED_ARCHS\<span class="hljs-selector-attr">[@\]</span>&#125;\&quot;<br><br>rm \&quot;\$&#123;EXTRACTED_ARCHS\<span class="hljs-selector-attr">[@\]</span>&#125;\&quot;<br><br>echo \&quot;Replacing original executable with thinned version\&quot;<br><br>rm \&quot;\$FRAMEWORK_EXECUTABLE_PATH\&quot;<br><br>mv \&quot;\$FRAMEWORK_EXECUTABLE_PATH-merged\&quot;<br>\&quot;\$FRAMEWORK_EXECUTABLE_PATH\&quot;<br><br>done<br></code></pre></td></tr></table></figure>

<h2 id="制作XCFramework脚本"><a href="#制作XCFramework脚本" class="headerlink" title="制作XCFramework脚本"></a>制作XCFramework脚本</h2><p>XCFramework脚本制作与Universal Framework流程方式一致，存在生成规则的不同</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">#!/bin/sh -e<br><br>REVEAL_XCFRAMEWORK_IN_FINDER=true<br><br>FREAMEWORK_NAME=\&quot;\$&#123;PROJECT_NAME&#125;\&quot;<br><br>FREAMEWORK_OUTPUT_DIR=\&quot;\$&#123;PROJECT_DIR&#125;/Distribution\&quot;<br><br>ARCHIVE_PATH_IOS_DEVICE=\&quot;./Build/ios_device<span class="hljs-selector-class">.xcarchive</span>\&quot;<br><br>ARCHIVE_PATH_IOS_SIMULATOR=\&quot;./Build/ios_simulator<span class="hljs-selector-class">.xcarchive</span>\&quot;<br><br>\# ARCHIVE_PATH_MACOS=\&quot;./build/macos<span class="hljs-selector-class">.xcarchive</span>\&quot;<br><br>function archiveOnePlatform &#123;<br><br>echo \&quot;▸ Starts archiving the scheme: \$&#123;<span class="hljs-number">1</span>&#125; for destination: \$&#123;<span class="hljs-number">2</span>&#125;;\\n▸<br>Archive path: \$&#123;<span class="hljs-number">3</span>&#125;\&quot;<br><br>xcodebuild archive \\<br><br>-scheme \&quot;\$&#123;<span class="hljs-number">1</span>&#125;\&quot; \\<br><br>-destination \&quot;\$&#123;<span class="hljs-number">2</span>&#125;\&quot; \\<br><br>-archivePath \&quot;\$&#123;<span class="hljs-number">3</span>&#125;\&quot; \\<br><br>VALID_ARCHS=\&quot;\$&#123;<span class="hljs-number">4</span>&#125;\&quot; \\<br><br>SKIP_INSTALL=NO \\<br><br>BUILD_LIBRARY_FOR_DISTRIBUTION=YES \| xcpretty<br><br>\# sudo gem install -n /usr/local/bin xcpretty<br><br>\# xcpretty makes xcode compile information much more readable.<br><br>&#125;<br><br>function archiveAllPlatforms &#123;<br><br>\# https://www.mokacoding.com/blog/xcodebuild-destination-options/<br><br>\# Platform Destination<br><br>\# iOS generic/platform=iOS<br><br>\# iOS Simulator generic/platform=iOS Simulator<br><br>\# iPadOS generic/platform=iPadOS<br><br>\# iPadOS Simulator generic/platform=iPadOS Simulator<br><br>\# macOS generic/platform=macOS<br><br>\# tvOS generic/platform=tvOS<br><br>\# watchOS generic/platform=watchOS<br><br>\# watchOS Simulator generic/platform=watchOS Simulator<br><br>\# carPlayOS generic/platform=carPlayOS<br><br>\# carPlayOS Simulator generic/platform=carPlayOS Simulator<br><br>SCHEME=\$&#123;<span class="hljs-number">1</span>&#125;<br><br>archiveOnePlatform \$SCHEME \&quot;generic/platform=iOS Simulator\&quot;<br>\$&#123;ARCHIVE_PATH_IOS_SIMULATOR&#125; \&quot;x86_64\&quot;<br><br>archiveOnePlatform \$SCHEME \&quot;generic/platform=iOS\&quot;<br>\$&#123;ARCHIVE_PATH_IOS_DEVICE&#125; \&quot;armv7 arm64\&quot;<br><br>\# archiveOnePlatform \$SCHEME \&quot;generic/platform=macOS\&quot;<br>\$&#123;ARCHIVE_PATH_MACOS&#125;<br><br>&#125;<br><br>function makeXCFramework &#123;<br><br>FRAMEWORK_RELATIVE_PATH=\&quot;Products/Library/Frameworks\&quot;<br><br>OUTPUT_DIR=\&quot;\$&#123;FREAMEWORK_OUTPUT_DIR&#125;/DynamicFramework\&quot;<br><br>mkdir -<span class="hljs-selector-tag">p</span> \&quot;\$&#123;OUTPUT_DIR&#125;\&quot;<br><br>xcodebuild -create-xcframework \\<br><br>-framework<br>\&quot;\$&#123;ARCHIVE_PATH_IOS_DEVICE&#125;/\$&#123;FRAMEWORK_RELATIVE_PATH&#125;/\$&#123;FREAMEWORK_NAME&#125;<span class="hljs-selector-class">.framework</span>\&quot;<br>\\<br><br>-framework<br>\&quot;\$&#123;ARCHIVE_PATH_IOS_SIMULATOR&#125;/\$&#123;FRAMEWORK_RELATIVE_PATH&#125;/\$&#123;FREAMEWORK_NAME&#125;<span class="hljs-selector-class">.framework</span>\&quot;<br>\\<br><br>-output \&quot;\$&#123;OUTPUT_DIR&#125;/\$&#123;FREAMEWORK_NAME&#125;<span class="hljs-selector-class">.xcframework</span>\&quot;<br><br>&#125;<br><br>echo \&quot;#####################\&quot;<br><br>echo \&quot;▸ Cleaning XCFramework output dir: \$&#123;FREAMEWORK_OUTPUT_DIR&#125;\&quot;<br><br>rm -rf \$FREAMEWORK_OUTPUT_DIR<br><br>\#### Make XCFramework<br><br>echo \&quot;▸ Archive framework: \$&#123;FREAMEWORK_NAME&#125;\&quot;<br><br>archiveAllPlatforms \$FREAMEWORK_NAME<br><br>echo \&quot;▸ Make framework: \$&#123;FREAMEWORK_NAME&#125;<span class="hljs-selector-class">.xcframework</span>\&quot;<br><br>makeXCFramework<br><br>\# Clean Build<br><br>rm -rf \&quot;./Build\&quot;<br><br>if \<span class="hljs-selector-attr">[ \$&#123;REVEAL_XCFRAMEWORK_IN_FINDER&#125; = true \]</span>; then<br><br>open \&quot;\$&#123;FREAMEWORK_OUTPUT_DIR&#125;/\&quot;<br><br>fi<br></code></pre></td></tr></table></figure>

<h3 id="生成Universal-XCFramework的函数"><a href="#生成Universal-XCFramework的函数" class="headerlink" title="生成Universal XCFramework的函数"></a>生成Universal XCFramework的函数</h3><p>制作XCFramewrok的时候，需要将Build Settings中的Build Libraries for<br>Distribution设置为YES。不过即使不设置，脚本也会将其设置为YES。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">function makeXCFramework &#123;<br><br>FRAMEWORK_RELATIVE_PATH=\&quot;Products/Library/Frameworks\&quot;<br><br>OUTPUT_DIR=\&quot;\$&#123;FREAMEWORK_OUTPUT_DIR&#125;/DynamicFramework\&quot;<br><br>mkdir -<span class="hljs-selector-tag">p</span> \&quot;\$&#123;OUTPUT_DIR&#125;\&quot;<br><br>xcodebuild -create-xcframework \\<br><br>-framework<br>\&quot;\$&#123;ARCHIVE_PATH_IOS_DEVICE&#125;/\$&#123;FRAMEWORK_RELATIVE_PATH&#125;/\$&#123;FREAMEWORK_NAME&#125;<span class="hljs-selector-class">.framework</span>\&quot;<br>\\<br><br>-framework<br>\&quot;\$&#123;ARCHIVE_PATH_IOS_SIMULATOR&#125;/\$&#123;FRAMEWORK_RELATIVE_PATH&#125;/\$&#123;FREAMEWORK_NAME&#125;<span class="hljs-selector-class">.framework</span>\&quot;<br>\\<br><br>-output \&quot;\$&#123;OUTPUT_DIR&#125;/\$&#123;FREAMEWORK_NAME&#125;<span class="hljs-selector-class">.xcframework</span>\&quot;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="开始制作-1"><a href="#开始制作-1" class="headerlink" title="开始制作"></a>开始制作</h3><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">echo \&quot;#####################\&quot;<br><br>echo \&quot;▸ Cleaning XCFramework output dir: \$&#123;FREAMEWORK_OUTPUT_DIR&#125;\&quot;<br><br>rm -rf \$FREAMEWORK_OUTPUT_DIR<br><br>\#### Make XCFramework<br><br>echo \&quot;▸ Archive framework: \$&#123;FREAMEWORK_NAME&#125;\&quot;<br><br>archiveAllPlatforms \$FREAMEWORK_NAME<br><br>echo \&quot;▸ Make framework: \$&#123;FREAMEWORK_NAME&#125;<span class="hljs-selector-class">.xcframework</span>\&quot;<br><br>makeXCFramework<br><br>\# Clean Build<br><br>rm -rf \&quot;./Build\&quot;<br><br>if \<span class="hljs-selector-attr">[ \$&#123;REVEAL_XCFRAMEWORK_IN_FINDER&#125; = true \]</span>; then<br><br>open \&quot;\$&#123;FREAMEWORK_OUTPUT_DIR&#125;/\&quot;<br><br>fi<br></code></pre></td></tr></table></figure>

<p>最后生成的xcframework：</p>
<p><img src="/images/framework/document_image_rId15.png"></p>
<h2 id="对framework的命令处理"><a href="#对framework的命令处理" class="headerlink" title="对framework的命令处理"></a>对framework的命令处理</h2><ul>
<li>  查看framework包含的指令集</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">lipo -info /path/<span class="hljs-selector-tag">to</span>/xxx<span class="hljs-selector-class">.framework</span>/xxx<br></code></pre></td></tr></table></figure>

<ul>
<li>  查看dynamic framework是否支持bitcode</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">otool -arch armv7 -l /path/<span class="hljs-selector-tag">to</span>/xxx<span class="hljs-selector-class">.framework</span>/xxx \| grep \_\_bundle<br></code></pre></td></tr></table></figure>

<p>如果包含 bitcode, 你会看到sectname __bundle信息。如果不包含，Terminal<br>输出为空</p>
<ul>
<li>  查看static framework是否支持 bitcode</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">otool -arch armv7 -l /path/<span class="hljs-selector-tag">to</span>/xxx<span class="hljs-selector-class">.framework</span>/xxx \| grep \_\_bitcode<br></code></pre></td></tr></table></figure>

<p>同上输出信息</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.jianshu.com/p/14f2e2236d34">[使用 Xcode 制作 Framework 与 XCFramework -<br>简书]</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS, 编译原理，编译过程，framework，xcframework</tag>
      </tags>
  </entry>
  <entry>
    <title>多环境参数的配置</title>
    <url>/2022/01/20/iOS/%E5%A4%9A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="一、设计目的"><a href="#一、设计目的" class="headerlink" title="一、设计目的"></a>一、设计目的</h1><p>1、根据需求切换开发、测试、生产的环境，快速响应差异化;<br>2、统一团队配置，优化开发流程，实现环境配置的统一管理。</p>
<h1 id="二、应用环境"><a href="#二、应用环境" class="headerlink" title="二、应用环境"></a>二、应用环境</h1><p><strong>1、Dev</strong><br>日常业务或者组件开发，打印日志，查看页面元素、内存、定位问题等，最常使用环境；<br><strong>2、Test</strong><br>测试环境(预发布)，测试及验证，包含隐藏功能，比如内部token等信息的查看、日志信息查看等；<br><strong>3、Production</strong><br>生产环境，预备发布到App Store的最终版本，此版本调试功能不可用。  </p>
<h1 id="三、项目结构体系"><a href="#三、项目结构体系" class="headerlink" title="三、项目结构体系"></a>三、项目结构体系</h1><p>先看一下项目的结构配置示意图：<br><img src="/images/multiplyEnv/document_image_rId11.png"><br><strong>备注：</strong><br>这是一张关于项目的具体配置体系的结构图，包括各个部分的关系。<br>其中的红线代表构建一个完整的app经过的流程步骤。</p>
<h1 id="四、配置加载过程"><a href="#四、配置加载过程" class="headerlink" title="四、配置加载过程"></a>四、配置加载过程</h1><p>编译加载过程流程图：<br><img src="/images/multiplyEnv/document_image_rId12.png"><br>通过该加载流程我们可以知道进行动态处理”动手术”的地方就是红色区域标识的位置。</p>
<h1 id="五、配置可选方案"><a href="#五、配置可选方案" class="headerlink" title="五、配置可选方案"></a>五、配置可选方案</h1><p>明晰了项目配置的结构，那么首先这里<strong>Project</strong>是排除的，因为它并不与我们的环境设置挂钩。但是也需要先理解一下各个部分的定义：</p>
<p><strong>Project：</strong><br>组织源代码和资源文件，可包含多个<strong>Scheme</strong>，也可包含多个<strong>Target</strong>目标对象，包含整体项目资源和配置的集合体。  </p>
<p><strong>Target：</strong><br>定义构建产品(App、Extension、Framework),指定需要编译的源代码和打包的资源文件和构建的过程步骤。<br>根据不同的环境设置多个target，意味着设置三个target，对应开发、测试、生产，配合设置不同宏定义参数进行内部设置的区分，比如三方库appId，网络请求头参数设置等。  </p>
<p><strong>演示图1：</strong><br><img src="/images/multiplyEnv/document_image_rId13.png"><br><img src="/images/multiplyEnv/document_image_rId14.png">  </p>
<p>这里打开可以看到对应三个target，也就是可以切换不同的target来确定构建目标，不过一般来说，不会在这里切换，会对应环境构建<strong>Scheme</strong>来进行切换。</p>
<p><strong>Scheme：</strong><br>定义完整构建过程，指定<strong>Target</strong>进行对应的构建流程，允许创建多个，但是同一时刻只能允许一个生效，整合目标configuration编译环境。</p>
<p><strong>演示图2：</strong><br><img src="/images/multiplyEnv/document_image_rId15.png"><br><img src="/images/multiplyEnv/document_image_rId16.png">  </p>
<p><strong>优点：</strong><br>切换快速，一个target对应两套<strong>Build<br>Settings</strong>(release/debug)，如果代码变动不大，使用起来很方便.  </p>
<p><strong>缺点：</strong><br>1.每个target需要构建不同的bundleId,签名证书重新生成，增加到3个<br>2.如果后台业务与bundleId有绑定，则所有的逻辑也需要变更修改（后台视频业务、IM服务）<br>3.代码同步问题，一份代码三个target都需要引用勾选，漏掉后果很严重，如果存在环境的影响，还需要维护环境宏变量  </p>
<p><strong>Configurations</strong><br>先确定涉及到的定义：  </p>
<p><strong>Build Configuration：</strong><br>可以把<strong>Build Settings</strong>当作是一个集体设置族参数，而<strong>BuildConfiguration</strong>则是用来管理和分组不同族<strong>BuildSettings</strong>的管理器，一般管理的<strong>BuildSettings族</strong>有Debug和Release两种，意思是这里有两套<strong>BuildSettings</strong>的配置集合，用于构建不同性质的App.</p>
<p><strong>Build Settings：</strong><br>保存构建需要的设置信息，例如系统版本、异常支持、架构支持、三方库路径、编译顺序等.</p>
<blockquote>
<p>本身是配合<strong>xcconfig</strong>进行配置设置的<strong>Build<br>Configuration</strong>,该方案是无<strong>xcconfig</strong>的设置，结果就是<strong>Build<br>Settings</strong>里面需要对新增加的<strong>Configurations</strong>除了以前旧有的debug/release设置以外还需要提供修改支持。还有创建scheme打到多环境，每个<strong>Schem</strong>对应一个<strong>Configurations</strong>环境，形成一一对应的关系，便于直接通过切换<strong>Scheme</strong>变更环境，构建不同的步骤。</p>
<p>如果需要自定义参数配置，要么使用不同<strong>Configurations</strong>的环境定义宏，内部宏区分处理，同Duplicate方案</p>
<p>也可以User-Defined根据不同<strong>Configurations</strong>定义不同参数，同时在info.plist里面同key配置引入即可</p>
</blockquote>
<p><strong>示意图：</strong><br><img src="/images/multiplyEnv/document_image_rId17.png"><br><strong>优点：</strong><br>根据env环境配置单一的环境，切换就可完成<br><strong>缺点：</strong><br>1.完全一一对应env环境，不区分当前编译类型debug/release/test<br>2.完全一一对应env环境，具体编译的debug/release根据具体业务确定<br>3.纯粹手动<strong>BuildSettings</strong>配置，如果出现丢失或者删除，难以对比跟踪，带来编译错误也查找困难<br>4.不适合统一管理，成员各个修改，给配置合并带来问题  </p>
<p><strong>实例：</strong><br><img src="/images/multiplyEnv/document_image_rId18.png"><br><img src="/images/multiplyEnv/document_image_rId19.png"></p>
<p><strong>Configuration+xcconfig</strong><br><strong>xcconfig(Build Configuration File，构建配置文件)</strong>  </p>
<p>纯文本文件，是作用于<strong>Project或者Target的BuildSettings</strong>，也就是说它可以代替<strong>Build<br>Settings</strong>，由手工修改变成了”外界配置”，再按照上述定义来看，我们可以确定，我们需要的是一<strong>BuildSettings</strong>,那么也就是一组<strong>xcconfig</strong>文件，由于是文件，那么可以用git进行统一管理.里面的内容格式类似于：</p>
<p>BUILD_SETTING_NAME = VALUE<br>SWIFT_VERSION = 5.0</p>
<p>使之生效，则需要在<strong>BuildSettings</strong>最前面加上${inherited},表示不覆盖并且保留具有相同key值的设置.</p>
<p><strong>xcconfig</strong>文件的修改实际上是修改<strong>BuildSettings</strong>中的参数,这里包含3种层次的类型文件：<strong>Project xcconfigFile、Target xcconfig File、Pod xcconfig File</strong>(一般会自动生成，需要进行include引用)</p>
<p>一般项目中是不包含<strong>Project xcconfig File、Target xcconfig<br>File</strong>文件的,所以需要自己创建这里需要注意一下项目最终生效配置过程，特别是存在同名配置的情况下，这里有一个优先级的步骤。</p>
<p><strong>优先级：</strong><br><img src="/images/multiplyEnv/document_image_rId20.png"><br>如果想继承保留，使用value时，在前面添加${inherited},后面跟着具体设置的值或者在后面添加${inherited}，前面设置具体值  </p>
<p>例如：<br>SWIFT_ACTIVE_COMPILATION_CONDITIONS = $(inherited) RELEASE<br>或者<br>SWIFT_ACTIVE_COMPILATION_CONDITIONS = RELEASE $(inherited)  </p>
<p><strong>使用示意图：</strong><br><img src="/images/multiplyEnv/document_image_rId21.png"><br><img src="/images/multiplyEnv/document_image_rId22.png"><br>由此我们就完成了设置，剩下的就是补上<strong>xcconfig File</strong>文件的内容.</p>
<p>注意一下xcode项目里定义的<strong>BuildSettings</strong>参数，可以从project.pbxproj里面去找到，如图所示:<br><img src="/images/multiplyEnv/document_image_rId23.png">    </p>
<p>其中一部分对应：<br><img src="/images/multiplyEnv/document_image_rId24.png"><br><img src="/images/multiplyEnv/document_image_rId25.png"><br><img src="/images/multiplyEnv/document_image_rId26.png"><br>所以这里如果我们使用同名key值，就可能会造成覆盖，可以根据自己的需求来处理。</p>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>1.在2方案的基础上逐级下沉细节配置，按照业务需求可非手动动态添加或者修改配置，可以代<strong>BuildSettings</strong>里面的设置，可以看作是2方案的加强版<br>2.将手动配置变成了动态注入配置，剥离环境影响，解耦合，可扩展性更强大<br>3.无需对项目scheme、target等”动手术”.<br>4.统一参数配置更灵活，直接文件写好即可，层次清晰  </p>
<p><strong>缺点：</strong><br>1.需要了解<strong>xcconfig</strong>的配置语法和加载机制<br>2.维护成本，同一个设置多个文件，优先级区分处理  </p>
<p><strong>4、结论</strong><br>1、通过以上三个方案的比较，<strong>Duplicate</strong>最先放弃，因为起码需要构建不同bundleId的设置和对证书请求、业务方面造成的影响范围太广，工程量巨大，性价比最低.<br>2、<strong>Configurations</strong>方案最直接简单，需要手动设置好参数，对新增的参数的设置是间接处理，但是不管是漏掉设置还是删除都会造成严重的后果，跟踪机制薄弱，不适合统一管理.<br>3、<strong>Configuration+xcconfig</strong>细化了配置流程，将新增参数独立解耦出来，而且由于是文件，可以通过git统一管理跟踪，而且就算<strong>BuildSettings</strong>漏掉或者删掉，也会有动态设置补充，灵活且稳定性最好.<br>所以，这里我们选择第3个方案，实现<strong>Configuration+xcconfig</strong>的结合处理.</p>
<h1 id="六、整体设计"><a href="#六、整体设计" class="headerlink" title="六、整体设计"></a>六、整体设计</h1><p><strong>配置结构示意图：</strong><br><img src="/images/multiplyEnv/document_image_rId27.png"></p>
<h1 id="七、配置变量"><a href="#七、配置变量" class="headerlink" title="七、配置变量"></a>七、配置变量</h1><p><strong>常用编译配置变量：</strong><br><img src="/images/multiplyEnv/document_image_rId28.png"><br>上面的参数可以从官网里面获取，具体地址为：<br><a href="https://xcodebuildsettings.com/">[官方网址:][https://xcodebuildsettings.com/]</a><br>注意：这里是官方配置参数字段说明，如果需要覆盖掉buildsetting的参数，那么可以使用同名key字段，同时删除xcode中 buildsetting的参数； </p>
<p>如果需要另外定义，则可以取名与系统定义不一致，如果需要让buildsetting使用，部分非选择项可以直接将自定义字段名填入buildsetting中，也可以生效，但不建议，因为这样做的后果是xcconfig中配置的参数名不能改动，不能删除，否则会影响编译配置效果。</p>
<p><strong>目前初版参数对照表如下：</strong><br><img src="/images/multiplyEnv/document_image_rId31.png"><br>上述不是完整配置字段，但是变更环境后会造成上述参数变换的效果</p>
<p><strong>具体变量设置：</strong><br><strong>公共变量xcconfig</strong><br>由于project build setting与target buildsetting两者的设置基本一致，那么我们只是从业务层面去区分公共设置，这里常用的配置包括以下：<br><img src="/images/multiplyEnv/document_image_rId32.png">  </p>
<p><strong>Project xcconfig</strong><br>本项目梳理无，只包含一个基础xcconfig对公共变量xcconfig引入。<br><img src="/images/multiplyEnv/document_image_rId33.png">  </p>
<p><strong>Target xcconfig File</strong><br><img src="/images/multiplyEnv/document_image_rId34.png">  </p>
<h1 id="八、应用参数"><a href="#八、应用参数" class="headerlink" title="八、应用参数"></a>八、应用参数</h1><p><strong>B端当前参数梳理:</strong><br><img src="/images/multiplyEnv/document_image_rId35.png">  </p>
<p><strong>应用参数存储:</strong><br>1.确认当前参数是否保密参数，如果是非保密，则放在${configuration}Configurations.xcconfig中，主要是为了直观处理。<br><img src="/images/multiplyEnv/document_image_rId36.png"><br>根据环境填充即可，目前通过脚本会自动构建生成对应的plist文件，用于使用和查找。  </p>
<p><strong>附上脚本：</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;CONFIGURATION -&gt; \<span class="hljs-variable">$</span>&#123;CONFIGURATION&#125;\&quot;</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;SRCROOT -&gt; <span class="hljs-variable">$</span>&#123;SRCROOT&#125;&quot;</span><br>/usr/libexec/PlistBuddy <span class="hljs-literal">-c</span> <span class="hljs-string">&quot;Clear&quot;</span> <span class="hljs-variable">$</span>&#123;SRCROOT&#125;/buildsettings.plist<br>/usr/libexec/PlistBuddy <span class="hljs-literal">-c</span> <span class="hljs-string">&quot;Clear&quot;</span> <span class="hljs-variable">$</span>&#123;SRCROOT&#125;/buildConfiguration.plist<br>xcodebuild <span class="hljs-literal">-project</span> kanfangriji.xcodeproj <span class="hljs-literal">-target</span> kanfangriji <span class="hljs-literal">-configuration</span> <span class="hljs-variable">$</span>&#123;CONFIGURATION&#125; <span class="hljs-literal">-showBuildSettings</span> | grep <span class="hljs-string">&quot;=&quot;</span> &gt; <span class="hljs-variable">$</span>&#123;SRCROOT&#125;/buildsettings.txt<br><br><span class="hljs-built_in">cat</span> <span class="hljs-variable">$</span>&#123;SRCROOT&#125;/buildsettings.txt | <span class="hljs-keyword">while</span> read line;<br><span class="hljs-keyword">do</span><br>k=<span class="hljs-variable">$</span>&#123;line%=*&#125;<br>v=<span class="hljs-variable">$</span>&#123;line<span class="hljs-comment">##*=&#125;</span><br>/usr/libexec/PlistBuddy <span class="hljs-literal">-c</span> <span class="hljs-string">&quot;Add <span class="hljs-variable">$k</span> string <span class="hljs-variable">$v</span>&quot;</span> <span class="hljs-variable">$</span>&#123;SRCROOT&#125;/buildsettings.plist<br>done<br><br><span class="hljs-built_in">cat</span> <span class="hljs-variable">$</span>&#123;SRCROOT&#125;/kanfangriji/ShareConfigurations.xcconfig | grep <span class="hljs-string">&quot;=&quot;</span> | <span class="hljs-keyword">while</span> read line;<br><span class="hljs-keyword">do</span><br>k=<span class="hljs-variable">$</span>&#123;line%=*&#125;<br>v=<span class="hljs-variable">$</span>&#123;line<span class="hljs-comment">##*=&#125;</span><br>/usr/libexec/PlistBuddy <span class="hljs-literal">-c</span> <span class="hljs-string">&quot;Add <span class="hljs-variable">$k</span> string <span class="hljs-variable">$v</span>&quot;</span> <span class="hljs-variable">$</span>&#123;SRCROOT&#125;/buildConfiguration.plist<br>done<br><br><span class="hljs-built_in">cat</span> <span class="hljs-variable">$</span>&#123;SRCROOT&#125;/kanfangriji/<span class="hljs-variable">$</span>&#123;CONFIGURATION&#125;Project.xcconfig | grep <span class="hljs-string">&quot;=&quot;</span> | <span class="hljs-keyword">while</span> read line;<br><span class="hljs-keyword">do</span><br>k=<span class="hljs-variable">$</span>&#123;line%=*&#125;<br>v=<span class="hljs-variable">$</span>&#123;line<span class="hljs-comment">##*=&#125;</span><br>/usr/libexec/PlistBuddy <span class="hljs-literal">-c</span> <span class="hljs-string">&quot;Add <span class="hljs-variable">$k</span> string <span class="hljs-variable">$v</span>&quot;</span> <span class="hljs-variable">$</span>&#123;SRCROOT&#125;/buildConfiguration.plist<br>done<br><br><span class="hljs-built_in">cat</span> <span class="hljs-variable">$</span>&#123;SRCROOT&#125;/kanfangriji/<span class="hljs-variable">$</span>&#123;CONFIGURATION&#125;Target.xcconfig | grep <span class="hljs-string">&quot;=&quot;</span> | <span class="hljs-keyword">while</span> read line;<br><span class="hljs-keyword">do</span><br>k=<span class="hljs-variable">$</span>&#123;line%=*&#125;<br>v=<span class="hljs-variable">$</span>&#123;line<span class="hljs-comment">##*=&#125;</span><br>/usr/libexec/PlistBuddy <span class="hljs-literal">-c</span> <span class="hljs-string">&quot;Add <span class="hljs-variable">$k</span> string <span class="hljs-variable">$v</span>&quot;</span> <span class="hljs-variable">$</span>&#123;SRCROOT&#125;/buildConfiguration.plist<br>done<br><br><span class="hljs-built_in">cat</span> <span class="hljs-variable">$</span>&#123;SRCROOT&#125;/kanfangriji/<span class="hljs-variable">$</span>&#123;CONFIGURATION&#125;Configurations.xcconfig | grep <span class="hljs-string">&quot;=&quot;</span> | <span class="hljs-keyword">while</span> read line;<br><span class="hljs-keyword">do</span><br>k=<span class="hljs-variable">$</span>&#123;line%=*&#125;<br>v=<span class="hljs-variable">$</span>&#123;line<span class="hljs-comment">##*=&#125;</span><br>/usr/libexec/PlistBuddy <span class="hljs-literal">-c</span> <span class="hljs-string">&quot;Add <span class="hljs-variable">$k</span> string <span class="hljs-variable">$v</span>&quot;</span> <span class="hljs-variable">$</span>&#123;SRCROOT&#125;/buildConfiguration.plist<br>done<br><span class="hljs-built_in">rm</span> <span class="hljs-literal">-rf</span> <span class="hljs-variable">$</span>&#123;SRCROOT&#125;/buildsettings.txt<br></code></pre></td></tr></table></figure>
<p><strong>效果如下：</strong><br><img src="/images/multiplyEnv/document_image_rId37.png"><br><img src="/images/multiplyEnv/document_image_rId38.png">  </p>
<p>2.保密参数，则使用私有外联参数定义，隐藏内部参数<br><img src="/images/multiplyEnv/document_image_rId39.png"><br><img src="/images/multiplyEnv/document_image_rId40.png"><br>内部需要根据环境进行划分，使用时直接使用SKM_ServerHost就可以进行实现    </p>
<p><strong>新增配置项整体流程：</strong><br><img src="/images/multiplyEnv/document_image_rId41.png"></p>
<h1 id="九、任务执行流程"><a href="#九、任务执行流程" class="headerlink" title="九、任务执行流程"></a>九、任务执行流程</h1><p><strong>具体步骤：</strong><br><img src="/images/multiplyEnv/document_image_rId42.png">  </p>
<h1 id="十、应用及测试"><a href="#十、应用及测试" class="headerlink" title="十、应用及测试"></a>十、应用及测试</h1><p><strong>步骤：</strong><br>1.增加配置项后，这里区分，如果是私密应用参数，则忽略；<br>2.如果是其他的，启动编译；<br>3.工具类分别读取脚本生成的结果配置表和手动配置表自动进行对比；<br>4.无输出信息，则成功；否则，输出不一致项信息，进行弹窗提醒<br>5.如果有提示信息，则排错及纠正后重复2开始的步骤；<br>6.切换不同scheme环境，重复2开始的步骤；<br>7.成功，则配置项正确通过<br>8.结束流程  </p>
<p><strong>附上自动匹配代码段：</strong>  </p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">+ (NSString *)matchBuildSettings &#123;<br>    // 个人配置<br>    NSString *buildPath = <span class="hljs-selector-attr">[[NSBundle mainBundle]</span> pathForResource:@<span class="hljs-string">&quot;buildConfiguration&quot;</span> ofType:@<span class="hljs-string">&quot;plist&quot;</span>];<br>    // 最终结果<br>    NSString *resultPath = <span class="hljs-selector-attr">[[NSBundle mainBundle]</span> pathForResource:@<span class="hljs-string">&quot;buildsettings&quot;</span> ofType:@<span class="hljs-string">&quot;plist&quot;</span>];<br>    NSMutableString *muStr = <span class="hljs-selector-attr">[NSMutableString new]</span>;<br>    if (!buildPath) &#123;<br>        <span class="hljs-selector-attr">[muStr appendString:@<span class="hljs-string">&quot;buildConfiguration.plist文件缺失&quot;</span>]</span>;<br>        return muStr<span class="hljs-selector-class">.copy</span>;<br>    &#125;<br>    if (!resultPath) &#123;<br>        <span class="hljs-selector-attr">[muStr appendString:@<span class="hljs-string">&quot;buildsettings.plist文件缺失&quot;</span>]</span>;<br>        return muStr<span class="hljs-selector-class">.copy</span>;<br>    &#125;<br>    NSDictionary *buildData = <span class="hljs-selector-attr">[NSDictionary dictionaryWithContentsOfFile:buildPath]</span>;<br>    NSDictionary *resultData = <span class="hljs-selector-attr">[NSDictionary dictionaryWithContentsOfFile:resultPath]</span>;<br>    NSArray *buildKeys = <span class="hljs-selector-attr">[buildData allKeys]</span>;<br>    <span class="hljs-keyword">@autoreleasepool</span> &#123;<br>        for (NSString *key in buildKeys) &#123;<br>            NSString *buildValue = buildData<span class="hljs-selector-attr">[key]</span>;<br>            NSString *resultValue = resultData<span class="hljs-selector-attr">[key]</span>;<br>            if (buildValue<span class="hljs-selector-class">.length</span> == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-selector-attr">[muStr appendFormat:@<span class="hljs-string">&quot;%@为空\n&quot;</span>,key]</span>;<br>            &#125;<br>            if (buildValue<span class="hljs-selector-class">.length</span> &gt; <span class="hljs-number">0</span> &amp;&amp; resultValue<span class="hljs-selector-class">.length</span> &gt; <span class="hljs-number">0</span>) &#123;<br>                if (<span class="hljs-selector-attr">[buildValue containsString:@<span class="hljs-string">&quot;$(inherited)&quot;</span>]</span>) &#123;<br>                    NSString *temp = <span class="hljs-selector-attr">[buildValue stringByReplacingOccurrencesOfString:@<span class="hljs-string">&quot;$(inherited)&quot;</span> withString:@<span class="hljs-string">&quot;&quot;</span>]</span>;<br>                    if (!<span class="hljs-selector-attr">[resultValue containsString:temp]</span>) &#123;<br>                        <span class="hljs-selector-attr">[muStr appendFormat:@<span class="hljs-string">&quot;%@=%@配置有误\n&quot;</span>,key,buildValue]</span>;<br>                    &#125;<br>                &#125;else if(!<span class="hljs-selector-attr">[buildValue isEqualToString:resultValue]</span>)&#123;<br>                    <span class="hljs-selector-attr">[muStr appendFormat:@<span class="hljs-string">&quot;%@=%@配置有误\n&quot;</span>,key,buildValue]</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    NSString *resultStr = muStr<span class="hljs-selector-class">.copy</span>;<br>    if (resultStr<span class="hljs-selector-class">.length</span>) &#123;<br>        return resultStr;<br>    &#125;<br>    return nil;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="十一、其他"><a href="#十一、其他" class="headerlink" title="十一、其他"></a>十一、其他</h1><p><strong>问题1:</strong><br>统一管理后如何不小心在配置文件中更改了怎么办？<br>直接清空<strong>Build Settings</strong>那一栏，因为xcconfig文件内容会根据环境自动覆盖  </p>
<p><strong>问题2:</strong><br>对打包脚本的影响？<br>不影响，只要不修改configuration的的name值，不会影响。  </p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>xcode, 多环境, 编译参数, buildSettings</tag>
      </tags>
  </entry>
  <entry>
    <title>帝子降兮北渚，目眇眇兮愁予</title>
    <url>/2019/12/21/%E4%BA%8C%E6%AC%A1%E5%85%83/%E4%BA%8C%E6%AC%A1%E5%85%83/</url>
    <content><![CDATA[<p>“灵衣玉佩，一阴一阳；罗生堂下，秋兰长生”。说起二次元的气质美女们，很容易让大家联想到《秦时明月》里面风格迥异，气象万千的美女。</p>
<p><img src="/images/moon/moon_shaoshiming.jpeg"></p>
<p>空灵如仙的少司命，具有一股超凡脱俗的气质，夜色里荧蝶翩翩，微风撩起紫色长发，似是从山水画中走出来的精灵。“悲莫悲兮生别离，乐莫乐兮新相知”，剧中是一位年轻女性：令人闻风丧胆的死亡使者之一。性情冷漠，有着与年龄不相符的高深武功。总是以面纱遮面，传说她美若天仙，但这世上还没有人见过她面纱之下的真正面目。</p>
<p><img src="/images/moon/moon_dashiming.jpeg"></p>
<p>成熟妩媚的大司命，大司命是先秦时代中国传说中的神，是掌管人的寿夭之神。“广开兮天门，纷吾乘兮玄云。令飘风兮先驱，使谏雨兮洒尘。”，外表妖艳动人，手段阴辣狠毒，擅长使用幻术迷惑敌人。</p>
<p><img src="/images/moon/moon_honglian.jpeg"></p>
<p>妖艳魅惑的红莲，本是战国时期韩国贵胄，高高在上的韩国公主，可惜在国破家亡后，沦为聚散流散组织的杀手。她只希望能偶伴随卫庄左右，一直等到他的心不在死，哪怕一直等不到也没关系。</p>
<p><img src="/images/moon/moon_yanlingji.jpeg"></p>
<p>来自百越的柔媚如水，热情似火的焰灵姬，被称之为国漫第一女神。</p>
<p>武功很高，火魅术天下无双，只可惜爱而不得，深爱的人却不爱她，最后还是死了。</p>
<p>后面还有很多，这里就不一一描述了，我们总能从里面找到符合自己心目中女神标准的二次元美女款。</p>
<p>为什么现实里面发现没有这样的美女呢？这里原因当然很多啦，一方面是生活节奏快，大家没有时间也没有精力去了解；二是现代流行“女汉子”，讲求时尚，能有古典气质的美女早就快绝迹了；三是，这里我都不好意思讲了，那是因为太屌丝，这样层次的美女怎能够是你能接触到的呢！当然，如果确实想看现实的，也有的哦，各种漫展，cosplay等。</p>
<p>这里用秦时明月里面痴情的湘夫人来引申，“帝子降兮北渚，目眇眇兮愁予！”，带领大家去感受二次元的人物美。</p>
]]></content>
      <categories>
        <category>二次元</category>
      </categories>
      <tags>
        <tag>秦时明月, 二次元</tag>
      </tags>
  </entry>
  <entry>
    <title>足迹在桂林山水</title>
    <url>/2019/05/28/%E6%97%85%E6%B8%B8/%E6%A1%82%E6%9E%97/</url>
    <content><![CDATA[<p>2018年的3月，晨曦微微，惠风和畅，空气里也散发着生机与湿润的味道！我有幸跟着部门一起去广西桂林度过一个偷得浮生半日闲的周末。我们和导游说好在深圳北站集合，我向来是一个比较懒散的人，想着能卡点到达就好，可是等我到了那里才发现自己虽然在深圳呆了4年多，可是仍然对最靠近的深圳北站的地形是陌生的。七拐八绕之下，我心里着急，满头大汗，等与导游汇合时，我瞬间松了一口气，真是太不容易了！</p>
<p>因为是第一次去，心里是极其兴奋的，憧憬着桂林的壮丽风光。沿路眼睛里满是奇特，桂林的山不是我们平常看到的那种圆锥形的土丘形地貌，反而是一种险峻的圆柱形，如果纯粹想爬上去，似乎是不太可能，山脚与山峰近似成90度角，颇有“望洋兴叹，力不从心”的感觉。</p>
<p>行程虽然有3天的安排，但是有一部分感觉是华而不实的，因为就是大家深恶痛绝的导游带着你去“买买买”，还有一部分因为别人不让拍照，也就死心了！这里我就把几个印象最深的展示出来。<br><img src="/images/guilin/guilin-1.jpeg"><br><img src="/images/guilin/guilin-2.jpeg"><br><img src="/images/guilin/guilin-3.jpeg"><br>这是漓江，也就是我们20元纸币上面描绘的桂林山水的图画，那天刚好在下小雨，天气阴沉沉的，我们坐着游轮往返于江上，两岸是各种奇特的山峰，导游的广播里在介绍桂林山水的文化背景及历史由来，大多数山峰都是以形象物来命名，比如什么“五指山”、“龟山”等等，但是我一个也没看出来，我们专注于看风景，加上船上声音嘈杂，实际上啥也没记住。这条江属于桂林阳朔县，不是在桂林市区，估计到现在很多人还是认为桂林山水指的就是桂林，我当初也是这样错误认知的！沿途可以透过澄澈的水面看到波光粼粼，拍击着两岸的山石，山峰云雾缭绕，宛如仙境，可谓是“舟行碧波上，人在画中游”。<br><img src="/images/guilin/guilin-4.jpeg"><br><img src="/images/guilin/guilin-5.jpeg"><br><img src="/images/guilin/guilin-6.jpeg"><br><img src="/images/guilin/guilin-7.jpeg"><br><img src="/images/guilin/guilin-8.jpeg"><br><img src="/images/guilin/guilin-9.jpeg"><br><img src="/images/guilin/guilin-10.jpeg"><br><img src="/images/guilin/guilin-11.jpeg"><br>这个是桂林市区里面有名的“两江四湖”的夜景，在我看来算是这次行程最值得一看的美丽夜景了，“两江四湖”是指漓江、桃花江、木龙湖（含铁佛塘）、桂湖、榕湖、杉湖，湖上舟楫纵横，游人如织。在黑漆漆的夜色中，两岸闪烁着五颜六色色彩斑斓的灯光，偶尔会经过一座座点缀着朵朵灯花的石拱桥，再加上水中倒映着的明亮色灯塔，颇有“今夕是何年”的感慨。人们常说夜色深沉，但是处于这样的华丽盛景中，倒映着的却是一派绚丽多姿的盛世气象，夜晚不再是沉静的代表，反而是浪漫而多情的情怀展现。江面上人声鼎沸，时不时有人隔着船招招手或者发起一声吆喝，顿时整个江面都热闹起来，虽然大家来自天南海北，互相之间不熟悉，但也阻隔不了大家的热情。</p>
<p>有时候会经过一些比较民族风的亭子，因为亭子的颜色大多是哪种蜿蜒的红色加带着云气的白色，其中夹杂着民族服饰的样式风格，而亭子里有些侗族少女跳着民族舞蹈，因为隔得远，大都看不太清楚，游船一晃而过，疏忽同船不知道是谁调皮地“嗨”了一声，瞬间整艘船的人们都跟着吆喝起来，对面的少女们也不害羞，也对着大家招了招手，顿时整个船上更加热闹起来了。</p>
<p>桂林的山水的奇特瑰丽也引领者这里的人们也跟着浪漫而多情，百闻不如一见，当时这个夜景给我的印象最深，也最体现着情怀。<br><img src="/images/guilin/guilin-12.jpeg"><br><img src="/images/guilin/guilin-13.jpeg"><br><img src="/images/guilin/guilin-14.jpeg"><br><img src="/images/guilin/guilin-15.jpeg"><br><img src="/images/guilin/guilin-16.jpeg"><br>这个是桂林的银子岩洞，里面都是石钟乳形成的奇形怪状的岩石，这里的五颜六色并不是岩洞本身的颜色，而是安装的灯光效果。当时游人很多，而路面其实很狭窄，在加上洞里面很潮湿，所以每一步基本上都得小心翼翼，一个不小心可能就摔跤啦。走完全程大约花了1个小时，很多时间都是中途看到一些特殊的风景驻足拍摄浪费的，道路曲折蜿蜒，所以比较考验体力，中间有些路段因为太窄而没有光照，黑漆漆的，而且无法并排走人，只能一个个前后跟着才能往下走。前半段因为有绚丽的灯光，所以大家显得比较兴奋，主要是因为第一次看到这些奇形怪状宛若笋尖的岩石有着不一样的感觉。但是后面看的越多当新奇感过去后却让人有点不耐烦了，因为洞窄路黑，有点气闷，一直走着走着，感觉总也走不到尽头。人在黑暗中呆久了就会有恐慌感，所以我后面几乎是快步晃过去的，真心没留意啥了，等到出来，恍若重回人间，感觉说不上好，就是惊奇直接变成了惊吓，有些哭笑不得！<br><img src="/images/guilin/guilin-17.jpeg"><br><img src="/images/guilin/guilin-18.jpeg"><br>这个是《刘三姐》的演出剧，因为隔得太远，远远望去，只看到火把明亮，各种五颜六色的光影闪烁。演出场景很宏大，特殊民族风情直接扑面而来，道具特效很精致，让人眼前一亮。可能是因为这些却感觉失去了剧情本身的朴质精神，后面我直接昏昏欲睡了，因为真心不知道到底是在演个啥！别因为这样就笑话，这个场景不是我们熟知的场馆内，而是直接在山水之间，周围黑漆漆的不是夜色，而是环绕着的几座几乎垂直竖立的高山，而里面的舞台不是陆地，而是整个在湖里，湖面上架着几座桥，方便演员进出，演员大多时候都是在水里进行表演，竹排，火把，红布条，应有尽有。因为与众不同，别具一格，所以更让人惊叹啊。还没结束时我们就匆匆跑出来了，要问为什么，因为游人太多，通道口实际上很窄的，如果等结束再走，那就不是一到两分钟的事情了，很可能就是至少半小时的事情。</p>
<p>其他就是一些附加的拍摄，因为对当时场景拍摄的不是很完整，所以只能拿出来欣赏一下。<br><img src="/images/guilin/guilin-19.jpeg"><br><img src="/images/guilin/guilin-20.jpeg"><br>山水虽然美，但是不可留，不可恋，不可贪。只要有过曾经的足迹就好，但是生活不只有眼前的苟且，更要有诗和远方！</p>
]]></content>
      <categories>
        <category>旅游</category>
      </categories>
      <tags>
        <tag>旅游, 桂林山水</tag>
      </tags>
  </entry>
  <entry>
    <title>六朝古都，金陵遗梦</title>
    <url>/2019/05/27/%E6%97%85%E6%B8%B8/%E9%87%91%E9%99%B5/</url>
    <content><![CDATA[<p>2016年金色灿烂的秋光里，因为一个扬州宝应县的同学要结婚了，所以趁着这个机会去游览了古都名城—南京。当时我还在深圳，从广东省到江苏省，那么远的距离就只能选择飞机这一交通工具了。记得当时是端午佳节的日子，我们从深圳宝安机场乘机到南京禄口机场，不过挺幸运的是，在飞机上有空乘人员和我们一起过佳节，每个人都分到了一颗装扮精美的粽子，想想还挺高兴的。我知道最近因为古墓探宝电视剧比较流行，“粽子”这个词绝对不是什么好玩意，但是这里可是那种食物类，不要思维发散太远！</p>
<p>当天下午1点左右我们就到了南京，有人开车来接我们，然后坐了5个小时的车，从南京经过了盱眙县再直达扬州宝应县，实在太累，当时有个同学累的直接在车上睡着了，我可能是第一次来这么远的地方，有点小兴奋，似睡非睡的就这样一直到了目的地。后面具体的婚礼安排流程就不说了，有点透露别人隐私的嫌疑，一笔带过吧。</p>
<p>第二天参加完婚礼后我们直接就转站去南京了，我们的运气不怎么好，当天扬州阴云密布，大风起兮，再加上天气还比较闷热，我们过去的无比艰难，先做大巴到了扬州南站，然后再买票坐火车去的南京南站，下午3点左右出发，大约晚上接近8点到达南京南站。大家觉得去南京当然要去体验一下“烟笼寒水月笼沙，月泊秦淮近酒家”的秦淮河两岸啦。<br><img src="/images/jingling/jingling-1.jpeg"><br><img src="/images/jingling/jingling-2.jpeg"><br><img src="/images/jingling/jingling-3.jpeg"><br><img src="/images/jingling/jingling-4.jpeg"><br><img src="/images/jingling/jingling-5.jpeg"><br><img src="/images/jingling/jingling-6.jpeg"><br><img src="/images/jingling/jingling-7.jpeg"><br><img src="/images/jingling/jingling-8.jpeg"><br>“舞榭歌台，风流总被雨打风吹去。”夜晚的秦淮河真有一种不一样的精致，灯火通明，亭台楼阁，小桥流水，给人一种别样的古典温柔的气息，就如一位精致的古典仕女，撑着一把山水写意的油纸伞，在绵绵细雨中对着你低头浅笑，充满了诗情画意。因为是端午佳节，不管是河两岸还是河面上都是人山人海，行人的聊天谈笑，商贩的临街叫卖，孩童的玩耍嬉戏，再映衬着远处的光影彤彤，错觉上自己是不是成了清明上河图中的一个背景，在这大千红尘中沉沦。河面上几艘龙舟飞驰而过，晃眼间就不见了踪影，两岸不时传来叫好声，喧嚣而充满了人情味。</p>
<p>从大门往里走去，巷道阡陌纵横，到处都是古玩字画的商品，琳琅满目，我们经过了夫子庙，状元楼，王谢纪念馆，各种诗文词句应接不暇，有些听过，而有些完全是陌生的。当时那景，那诗，那人，宛若一幅幅古代的画卷在我面前，徐徐展开。正是这一幕幕的仿若碎纸的画面，拼凑成了南京这座古都的江南人文荟萃的盛景。</p>
<p>走着，逛着，笑着；明亮着，暗淡着，闪烁着；历史感，沧桑感，静谧感；这些各种各样的元素斑驳交瘁，构成了五彩缤纷的江南水乡的意境。因为目不暇接的是各种小古典工艺品，折扇，宣纸，墨竹，玉蝶，古色古香，所以笑着；因为远处璀璨的光影与古老旧址的冷寂交错，所以闪烁着；因为满目疮痍的墙角青苔遍地，时过千年的流水静静述说，所以是静谧感。随着人流穿行，更多的感受是江南的温柔已然浸入了这里人们的骨子里，精致的饮食，绵软的话语和对古典诗词歌赋的追求,“风吹柳花满店香，吴姬压酒唤客尝”。</p>
<p>途中经过了一家河边小店，我们很上道地尝了南京地道的“鸭血粉丝汤”，怎么说呢，味道想对我这个荆楚人士来说，比较淡，但是清凉爽口。正当我觉得不虚此行，觉得回味无穷时，第二天的行程立马打我脸了。<br><img src="/images/jingling/jingling-9.jpeg"><br><img src="/images/jingling/jingling-10.jpeg"><br><img src="/images/jingling/jingling-11.jpeg"><br><img src="/images/jingling/jingling-12.jpeg"><br><img src="/images/jingling/jingling-13.jpeg"><br>这是我们第二天上午参观的一个南京著名景点“总统府”，票价40元，还算比较合理吧，正门口就是宏伟的民国风格汉白石大门，这是我第一次比较正式的看到民国风格建筑，不用说，当然是立马拍一张。这地方是孙中山就任中华民国大总统时的旧址，并不是说这建筑有多么奇特瑰丽，主要是它的历史意义和纪念意义。进门出现在眼前的就是一条长长的庭院小道，两旁都是一些盆栽绿植，显得雍容大气，穿过小道就到了一个祠堂式的大堂，墙面上摆满了许多革命历史人物的相册，有蒋介石，孙中山，陈独秀等等，恕我历史学的浅，还有许多陌生的。跟随着人流穿行，走廊阁楼，绿树林荫，蜿蜒崎岖，浓浓的江南林园气息。</p>
<p>有一些阁楼上面还保留着民国时期的著名人物的办公地址，风格显得大气敞亮，漆红色的门，漆红色的地板，漆红色的办公室，满眼都是漆红色，米黄的灯色，因为年代久远显得有点陈旧暗淡，体现着民国时期黑暗的时代特点。</p>
<p>稍微让我有点惊讶的是里面竟然还有太平天国天王洪秀全的金銮宝座，当时我惊讶的不是一点半点，虽然知道太平天国定都了南京，但是天王府就是总统府，这是我完全想不到的。这个金銮殿是后面修缮的，跟许多电视剧里的没什么不同，也是是电视剧看多了，我对龙床，大理石柱和殿内台阶实在是没什么新奇感了。</p>
<p>进来主要就是一个字：逛！逛到你没有意思了，自然而然就出去了。我们花了半天左右，最大的收获就是体味了一把金陵的民国风和南国园林风，感觉就是面积博大，道路曲折，我进来后就已经晕头转向了，不过挺幸运的，我不是带路党，跟着人流走就对了。<br><img src="/images/jingling/jingling-14.jpeg"><br><img src="/images/jingling/jingling-15.jpeg"><br><img src="/images/jingling/jingling-16.jpeg"><br><img src="/images/jingling/jingling-17.jpeg"><br><img src="/images/jingling/jingling-19.jpeg"><br>最后因为时间的关系，我们最后去了南京的玄武湖，这也是一个著名景点，外面是石头城墙，南京素有“石头城”的称谓，看到那长长的一段城墙才明白“石头”从何而来。玄武湖的湖水澄澈透明，中间还能看到下面的水草静静飘摇，湖面被分为了两段，中间有一条长长的桥道，一段段路再加一座座石拱桥拼凑而成，岸边有些亭台水榭供游人休憩。我们租了2条船在湖面游玩，不过真心价格挺贵的，100元一个小时，最后划了两个半小时，总共花了500多，最后在玄武湖的入口拍了张照作为留念。</p>
<p>这里，南京之旅就算结束了，我们当天下午就有很多同学各奔东西了，北京的，上海的，每个人有每个人的生活，繁华过后留下的终是落寞，相聚过后留下的终是离别。我和深圳的几个同学一起算是最后走的一批人，最难受的永远是最后的那一个人，我深深体会到时光背后的陌生与孤单，时隔3年的再聚首或许也是大家人生中最后的一次再聚首。</p>
<p>六朝古都，江南形胜，我们为南国金陵的梦幻意境而沉醉，但更多地为故人再聚而兴奋。有人说：世间所有的相遇都是久别重逢，但我想说：人生所有的久别重逢都是再一次的别离。金陵遗梦不是金陵的风景意境之梦，而是古人相逢的喜悦，它深深地刻在我的脑海里。天南海北的大家再重逢是人生旅途中珍稀的一个梦，而在金陵，我们留下了这样的美梦！</p>
]]></content>
      <categories>
        <category>旅游</category>
      </categories>
      <tags>
        <tag>旅游, 金陵遗梦</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理</title>
    <url>/2022/02/13/iOS/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>通过了解平台从源码到机器可识别的代码的过程，有助于我们理解静态库与动态库的制作，也能有思路去优化app的性能，比如启动速度，还有包括app的”瘦身”计划等。</p>
<h1 id="编译过程简述"><a href="#编译过程简述" class="headerlink" title="编译过程简述"></a>编译过程简述</h1><p>首先需要了解一下编译的详细设计，这里有张图可以表示：</p>
<p><img src="/images/compiler/image1.jpg"></p>
<p>这里简单解释一下就是：</p>
<ul>
<li><p>  源码开始进行编译，首先第一步就是预处理，主要是进行导入库的源码替换操作，形成修改后的源程序</p>
</li>
<li><p>  编译器将处理后的代码编译成汇编程序</p>
</li>
<li><p>  汇编器将程序翻译成机器指令，包装成可重定向目标程序，这是一个二进制文件</p>
</li>
<li><p>  链接器对依赖的其余目标程序合并到本程序中，生成可执行程序</p>
</li>
<li><p>  可执行程序通过加载器加入内存，并由系统执行</p>
</li>
</ul>
<p>为什么会有这样一套流程，原因是计算机无法理解高级语言逻辑，所以我们需要有一套流程能够将高级语言转化成机器可以识别的二进制，这就有了编译器的出现。</p>
<h1 id="编译命令GCC"><a href="#编译命令GCC" class="headerlink" title="编译命令GCC"></a>编译命令GCC</h1><p>GCC（GNU Compiler Collection，GNU编译器套件）是由GNU开发的编程语言译器。GNU编译器套件包括C、C++、Objective-C、Fortran、Java、Ada和Go语言前端，也包括了这些语言的库（如libstdc++，libgcj等。）</p>
<h1 id="编写源程序"><a href="#编写源程序" class="headerlink" title="编写源程序"></a>编写源程序</h1><p>简单的一个C程序，如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#include</span> &lt;stdio<span class="hljs-selector-class">.h</span>&gt;<br>int <span class="hljs-selector-tag">main</span>()<br>&#123;<br>    printf(&quot;hello, world\n&quot;);<br>    return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="GCC编译"><a href="#GCC编译" class="headerlink" title="GCC编译"></a>GCC编译</h1><p>进入hello.c当前目录下，继续步骤如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">// 将hello<span class="hljs-selector-class">.c</span>文件编译成可执行程序hello<br>gcc -o hello hello<span class="hljs-selector-class">.c</span><br>// 执行hello程序<br>./hello<br><br></code></pre></td></tr></table></figure>
<p>结果：hello,world，由此可以知道刚才是直接将文件翻译成了机器二进制语言文件hello，然后这个文件机器是可以识别的，通过执行，与程序逻辑保持一致，那么我们可以探究一下其中具体做了哪些事情呢，这里有一张编译过程的网络引用图：</p>
<p><img src="/images/compiler/image2.jpg"></p>
<p>通过这张图，将编译过程进行拆分，可以分为四类：</p>
<ul>
<li><p>  预处理(text)</p>
</li>
<li><p>  编译(text)</p>
</li>
<li><p>  汇编(binary)</p>
</li>
<li><p>  链接(binary)</p>
</li>
</ul>
<h1 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h1><p>C预处理器，也可以为预编译器，是一个独立于C编译器的小程序，一般简称CPP,即C Pre-Processor，其主要功能用来实现源代码编译之前，实现文本替换</p>
<p>比如这里的hello.c文件，开头里面包含了 #include &lt;stdio.h&gt; ，这里告诉了预处理器需要先系统头文件stdio.h的内容读取后插入到hello.c源程序中来，同时替换掉 #include &lt;stdio.h&gt; </p>
<p>修改后的 C 程序一般另保存为 .i 后缀的文本文件(本例为 hello.i)，输出的hello.i 将用于下一个阶段。</p>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>编译器CC1，编译器通过将hello.i文件进行编译，得到.s后缀的汇编语言文本文件，这里得到最终结果hello.s。</p>
<p>编译成汇编语言程序有个好处，就是对于不同的编译器，不同的高级语言，都会编译输出一样的汇编程序。</p>
<p>也就是说这一步相当于生成统一的汇编中间代码，就是为了适应不同平台的需要。</p>
<h1 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h1><p>这不操作比较关键，需要理解概念可重定位目标文件 (Relocatable Object File)，包含可与其它 relocatable object file相结合的二进制代码和数据，由编译器和汇编器产生。</p>
<p>通过汇编(as)会直接生成可重定位目标文件，也就是实现了汇编语言到机器指令的转化，变成了hello.o的二进制文件，这个时候生成的文件机器已经可以识别，但是别忘了，原来逻辑中还是用了C标准库prinf方法，而目前的生成的hello.o中无法识别prinf的逻辑，所以还会有下一步。</p>
<p>再范围大一些的理解<strong>目标文件:</strong></p>
<ul>
<li><p>  可重定位目标文件</p>
</li>
<li><p>  可执行目标文件(Executable Object File),包含可直接复制到内存并执行的二进制代码和数据，由链接器生成。</p>
</li>
<li><p>  共享目标文件 (Shared Object File),特殊的可重定位目标文件，可以被装载入内存，并且可以在装载或运行的时候动态地链接。这里比如prinf.o.</p>
</li>
</ul>
<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p>在我们生成了hello.o文件后，由于逻辑中依赖了C标准库prinf方法，那么需要一种方法让机器能够识别并且执行，这时候就需要一种方式将prinf.o内容合并进来，那就是链接器的作用。</p>
<p>最后经过链接器的作用后，会生成hello可执行文件，通过loader加载入内存，并由系统执行，也就是./hello，最终整个程序就跑起来了。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS, 编译原理，编译过程</tag>
      </tags>
  </entry>
  <entry>
    <title>在线功能收集</title>
    <url>/2022/02/13/%E5%B7%A5%E5%85%B7/%E5%9C%A8%E7%BA%BF%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>通过收集整理到的在线功能链接，可以非常快速方便的得到想要的资源，这样有利于快速提高开发效率。下面会按照各个分类进行整理和逐渐完善</p>
<h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><p>在线webp转为其余格式：</p>
<p><a href="https://www.aconvert.com/cn/image/webp-to-jpg">https://www.aconvert.com/cn/image/webp-to-jpg</a></p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h1 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h1><p>在线格式化：</p>
<p><a href="https://tool.oschina.net/codeformat/json/">https://tool.oschina.net/codeformat/json/</a></p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>在线, 工具, webp, JSON, 格式化</tag>
      </tags>
  </entry>
  <entry>
    <title>基础库梳理二</title>
    <url>/2020/05/19/iOS/%E7%BB%84%E4%BB%B6%E5%8C%96(%E4%BA%8C)-%E5%9F%BA%E7%A1%80%E5%BA%93%E7%9A%84%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<h1 id="基础库UI及说明"><a href="#基础库UI及说明" class="headerlink" title="基础库UI及说明"></a>基础库UI及说明</h1><p>首先结构如下图所示：</p>
<p><img src="/images/iOS/structure_progra_baseFold.jpeg"></p>
<p>这里分成三层：</p>
<ul>
<li>公共设置common层</li>
<li>核心core层</li>
<li>公共方法PublicMethods层</li>
</ul>
<p>关于数据层主要跟随业务进行数据处理的封装，这里不做描述，后续根据自己的情况进行对应的添加补充，下面主要是进行UI结构上的说明。</p>
<hr>
<h3 id="common层"><a href="#common层" class="headerlink" title="common层"></a>common层</h3><h6 id="FGCategoryUtility"><a href="#FGCategoryUtility" class="headerlink" title="FGCategoryUtility"></a>FGCategoryUtility</h6><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby">/<span class="hljs-regexp">//</span> 设定视图四个角其中一个的数据结构<br>struct FGCorner &#123;<br>    UIRectCorner cornerType; <span class="hljs-regexp">//</span><span class="hljs-regexp">/&lt; The type of corner.</span><br><span class="hljs-regexp">    CGFloat radius; /</span><span class="hljs-regexp">//</span>&lt; The radius of corner.<br>&#125;;<br>typedef struct FGCorner FGCorner;<br><br><span class="hljs-regexp">//</span><span class="hljs-regexp">/ 设定视图阴影</span><br><span class="hljs-regexp">struct FGShadow &#123;</span><br><span class="hljs-regexp">    CGColorRef color; /</span><span class="hljs-regexp">//</span>&lt; The color of shadow.<br>    CGSize offset; <span class="hljs-regexp">//</span><span class="hljs-regexp">/&lt; The shadow offset.</span><br><span class="hljs-regexp">    CGFloat opacity; /</span><span class="hljs-regexp">//</span>&lt; The opacity of the shadow.<br>    CGFloat radius; <span class="hljs-regexp">//</span><span class="hljs-regexp">/&lt; The radius of the shadow.</span><br><span class="hljs-regexp">&#125;;</span><br><span class="hljs-regexp">typedef struct FGShadow FGShadow;</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">/</span><span class="hljs-regexp">//</span>设定边框<br>struct FGBorder &#123;<br>    CGColorRef color; <span class="hljs-regexp">//</span><span class="hljs-regexp">/&lt; The color of bolder.</span><br><span class="hljs-regexp">    CGFloat width; /</span><span class="hljs-regexp">//</span>&lt; The width of bolder.<br>&#125;;<br>typedef struct FGBorder FGBorder;<br><br><span class="hljs-regexp">//</span><span class="hljs-regexp">/以下是各个数据结构的内联构造函数</span><br><span class="hljs-regexp">/</span>*!<br> <span class="hljs-variable">@abstract</span> Get main screen<span class="hljs-string">&#x27;s scale.</span><br><span class="hljs-string"> */</span><br><span class="hljs-string">static inline CGFloat FGScreenScale() &#123;</span><br><span class="hljs-string">    return [UIScreen mainScreen].scale;</span><br><span class="hljs-string">&#125;;</span><br><span class="hljs-string"></span><br><span class="hljs-string">/*!</span><br><span class="hljs-string"> @abstract Get main screen&#x27;</span>s size.<br> *<span class="hljs-regexp">/</span><br><span class="hljs-regexp">static inline CGSize FGScreenSize() &#123;</span><br><span class="hljs-regexp">    return [UIScreen mainScreen].bounds.size;</span><br><span class="hljs-regexp">&#125;;</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">/</span>*!<br> <span class="hljs-variable">@abstract</span> Describe the layer shadow.<br> *<span class="hljs-regexp">/</span><br><span class="hljs-regexp">static inline FGShadow FGShadowMake(CGColorRef color, CGSize offset, CGFloat radius, CGFloat opacity) &#123;</span><br><span class="hljs-regexp">    FGShadow shadow;</span><br><span class="hljs-regexp">    shadow.color = color;</span><br><span class="hljs-regexp">    shadow.offset = offset;</span><br><span class="hljs-regexp">    shadow.radius = radius;</span><br><span class="hljs-regexp">    shadow.opacity = opacity;</span><br><span class="hljs-regexp">    return shadow;</span><br><span class="hljs-regexp">&#125;</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">/</span>*!<br> <span class="hljs-variable">@abstract</span> Describe the layer bolder.<br> *<span class="hljs-regexp">/</span><br><span class="hljs-regexp">static inline FGBorder FGBorderMake(CGColorRef color, CGFloat width) &#123;</span><br><span class="hljs-regexp">    FGBorder border;</span><br><span class="hljs-regexp">    border.color = color;</span><br><span class="hljs-regexp">    border.width = width;</span><br><span class="hljs-regexp">    return border;</span><br><span class="hljs-regexp">&#125;</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">/</span>*!<br> <span class="hljs-variable">@abstract</span> Describe the layer corner.<br> *<span class="hljs-regexp">/</span><br><span class="hljs-regexp">static inline FGCorner FGCornerMake(UIRectCorner cornerType, CGFloat radius) &#123;</span><br><span class="hljs-regexp">    FGCorner corner;</span><br><span class="hljs-regexp">    corner.cornerType = cornerType;</span><br><span class="hljs-regexp">    corner.radius = radius;</span><br><span class="hljs-regexp">    return corner;</span><br><span class="hljs-regexp">&#125;</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">/</span>*!<br> <span class="hljs-variable">@abstract</span> Convert point to pixel.<br> *<span class="hljs-regexp">/</span><br><span class="hljs-regexp">static inline CGFloat FGFloatToPixel(CGFloat value) &#123;</span><br><span class="hljs-regexp">    return value * FGScreenScale();</span><br><span class="hljs-regexp">&#125;</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">/</span>*!<br> <span class="hljs-variable">@abstract</span> Convert pixel to point.<br> *<span class="hljs-regexp">/</span><br><span class="hljs-regexp">static inline CGFloat FGFloatFromPixel(CGFloat value) &#123;</span><br><span class="hljs-regexp">    return value /</span> FGScreenScale();<br>&#125;<br><br></code></pre></td></tr></table></figure>
<hr>
<h6 id="FGCategoryMacro"><a href="#FGCategoryMacro" class="headerlink" title="FGCategoryMacro"></a>FGCategoryMacro</h6><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby">/<span class="hljs-regexp">//</span>宏定义函数，简化联结对象设置<br><span class="hljs-comment">#ifndef FGSYNTH_DUMMY_CLASS</span><br><span class="hljs-comment">#define FGSYNTH_DUMMY_CLASS(_name_) \</span><br><span class="hljs-variable">@interface</span> FGSYNTH_DUMMY_CLASS <span class="hljs-comment">## _name_ : NSObject <span class="hljs-doctag">@end</span> \</span><br><span class="hljs-variable">@implementation</span> FGSYNTH_DUMMY_CLASS <span class="hljs-comment">## _name_ <span class="hljs-doctag">@end</span></span><br><span class="hljs-comment">#endif</span><br><br><span class="hljs-comment">#ifndef FG_DYNAMIC_PROPERTY_OBJECT</span><br><span class="hljs-comment">#define FG_DYNAMIC_PROPERTY_OBJECT(_getter_, _setter_, _association_, _type_) \</span><br>- (void)_setter_ : (_type_)object &#123; \<br>[<span class="hljs-keyword">self</span> <span class="hljs-symbol">willChangeValueForKey:</span>@<span class="hljs-comment">#_getter_]; \</span><br>objc_setAssociatedObject(<span class="hljs-keyword">self</span>, _cmd, object, OBJC_ASSOCIATION_ <span class="hljs-comment">## _association_); \</span><br>[<span class="hljs-keyword">self</span> <span class="hljs-symbol">didChangeValueForKey:</span>@<span class="hljs-comment">#_getter_]; \</span><br>&#125; \<br>- (_type_)_getter_ &#123; \<br><span class="hljs-keyword">return</span> objc_getAssociatedObject(<span class="hljs-keyword">self</span>, <span class="hljs-variable">@selector</span>(<span class="hljs-symbol">_setter_:</span>)); \<br>&#125;<br><span class="hljs-comment">#endif</span><br><br><span class="hljs-comment">#ifndef FG_DYNAMIC_PROPERTY_CTYPE</span><br><span class="hljs-comment">#define FG_DYNAMIC_PROPERTY_CTYPE(_getter_, _setter_, _type_) \</span><br>- (void)_setter_ : (_type_)object &#123; \<br>[<span class="hljs-keyword">self</span> <span class="hljs-symbol">willChangeValueForKey:</span>@<span class="hljs-comment">#_getter_]; \</span><br>NSValue *value = [NSValue <span class="hljs-symbol">value:</span>&amp;object <span class="hljs-symbol">withObjCType:</span><span class="hljs-variable">@encode</span>(_type_)]; \<br>objc_setAssociatedObject(<span class="hljs-keyword">self</span>, _cmd, value, OBJC_ASSOCIATION_RETAIN); \<br>[<span class="hljs-keyword">self</span> <span class="hljs-symbol">didChangeValueForKey:</span>@<span class="hljs-comment">#_getter_]; \</span><br>&#125; \<br>- (_type_)_getter_ &#123; \<br>_type_ cValue = &#123; <span class="hljs-number">0</span> &#125;; \<br>NSValue *value = objc_getAssociatedObject(<span class="hljs-keyword">self</span>, <span class="hljs-variable">@selector</span>(<span class="hljs-symbol">_setter_:</span>)); \<br>[value <span class="hljs-symbol">getValue:</span>&amp;cValue]; \<br><span class="hljs-keyword">return</span> cValue; \<br>&#125;<br><span class="hljs-comment">#endif</span><br></code></pre></td></tr></table></figure>
<hr>
<h3 id="core层"><a href="#core层" class="headerlink" title="core层"></a>core层</h3><h6 id="UIViewController-FGAutorotate"><a href="#UIViewController-FGAutorotate" class="headerlink" title="UIViewController+FGAutorotate"></a>UIViewController+FGAutorotate</h6><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby">/<span class="hljs-regexp">//</span>控制器旋转属性<br><span class="hljs-variable">@property</span> (nonatomic) BOOL shouldAutorotate;<br><span class="hljs-variable">@property</span> (nonatomic) UIInterfaceOrientationMask supportedInterfaceOrientations;<br><span class="hljs-variable">@property</span> (nonatomic) UIInterfaceOrientation preferredInterfaceOrientationForPresentation;<br></code></pre></td></tr></table></figure>
<hr>
<h6 id="FGModalViewController-QMUIModalPresentationViewController"><a href="#FGModalViewController-QMUIModalPresentationViewController" class="headerlink" title="FGModalViewController: QMUIModalPresentationViewController"></a>FGModalViewController: QMUIModalPresentationViewController</h6><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby">/<span class="hljs-regexp">//</span> 快速创建一个从下往上弹出的modalView<br>/<span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> contentView 内容View<br>- (instancetype)<span class="hljs-symbol">initWithContentView:</span>(UIView *)contentView;<br><br><span class="hljs-regexp">//</span><span class="hljs-regexp">/ 快速创建一个从下往上弹出的modalView 并添加到window上</span><br><span class="hljs-regexp">/</span><span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> contentView 内容视图<br>/<span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> onClickDimmingBlock 点击背景回调方法<br>+ (void)<span class="hljs-symbol">fg_showModalView:</span>(UIView *)contentView <span class="hljs-symbol">inView:</span>(UIView *)superView <span class="hljs-symbol">onClickDimmingBlock:</span>(void(^)(void))onClickDimmingBlock;<br></code></pre></td></tr></table></figure>
<hr>
<h6 id="FGNavigationBarBackground-UIView"><a href="#FGNavigationBarBackground-UIView" class="headerlink" title="FGNavigationBarBackground : UIView"></a>FGNavigationBarBackground : UIView</h6><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">@property</span> (nonatomic, assign) FGShadow barShade UI_APPEARANCE_SELECTOR; <span class="hljs-regexp">//</span><span class="hljs-regexp">/&lt; 阴影</span><br><span class="hljs-regexp">@property (nonatomic, assign) BOOL barShadeHidden UI_APPEARANCE_SELECTOR; /</span><span class="hljs-regexp">//</span>&lt; 是否隐藏阴影, 默认NO<br><span class="hljs-variable">@property</span> (nonatomic, strong, nullable) UIImage *backgroundImage UI_APPEARANCE_SELECTOR; <span class="hljs-regexp">//</span><span class="hljs-regexp">/&lt; 背景图片</span><br><span class="hljs-regexp">@property (nonatomic, strong, nullable) UIColor *barTintColor UI_APPEARANCE_SELECTOR; /</span><span class="hljs-regexp">//</span>&lt; 背景色<br></code></pre></td></tr></table></figure>
<p>UI_APPEARANCE_SELECTOR是系统开关宏，作用是一次性全局统一设置，设置后便不再改变。</p>
<hr>
<h6 id="FGBaseNavigationViewController-QMUINavigationController"><a href="#FGBaseNavigationViewController-QMUINavigationController" class="headerlink" title="FGBaseNavigationViewController : QMUINavigationController"></a>FGBaseNavigationViewController : QMUINavigationController</h6><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">@property</span> (nonatomic, strong, readonly) FGNavigationBarBackground *navigationBarBackground;<span class="hljs-regexp">//</span>导航栏背景视图，用于处理导航栏状态不一致时瞬间的变化<br></code></pre></td></tr></table></figure>
<hr>
<h6 id="FGPickerViewController-QMUIModalPresentationViewController"><a href="#FGPickerViewController-QMUIModalPresentationViewController" class="headerlink" title="FGPickerViewController : QMUIModalPresentationViewController"></a>FGPickerViewController : QMUIModalPresentationViewController</h6><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby">type<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">void</span><span class="hljs-params">(^FGPickerSelectedBlock)</span></span>(NSString *content , NSInteger selectedIndex);<br>type<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">void</span><span class="hljs-params">(^FGPickerCancelBlock)</span></span>(void);<br><br><span class="hljs-variable">@property</span> (nonatomic, strong) UILabel *titleLabel;      <span class="hljs-regexp">//</span>标题<br><span class="hljs-variable">@property</span> (nonatomic, strong) UIButton *cancelButton;   <span class="hljs-regexp">//</span>取消按钮<br><span class="hljs-variable">@property</span> (nonatomic, strong) UIButton *sureButton;     <span class="hljs-regexp">//</span>确定按钮<br>/**<br> 展示一级picker控件<br> <span class="hljs-variable">@param</span> title 标题<br> <span class="hljs-variable">@param</span> dataSource 数据源<br> <span class="hljs-variable">@param</span> selectedIndex 默认选中下标<br> <span class="hljs-variable">@param</span> animation 是否动画<br> <span class="hljs-variable">@param</span> complete 选择完成确定<br> <span class="hljs-variable">@param</span> cancel 取消选择<br> *<span class="hljs-regexp">/</span><br><span class="hljs-regexp">+ (void)fg_showPickerWithTitle:(NSString *)title</span><br><span class="hljs-regexp">                 dataSource:(NSArray &lt;NSString *&gt;*)dataSource</span><br><span class="hljs-regexp">       defaultSelectedIndex:(NSInteger)selectedIndex</span><br><span class="hljs-regexp">   defaultSelectedAnimation:(BOOL)animation</span><br><span class="hljs-regexp">                   selected:(FGPickerSelectedBlock)complete</span><br><span class="hljs-regexp">                     cancel:(FGPickerCancelBlock)cancel;</span><br></code></pre></td></tr></table></figure>
<hr>
<h6 id="FGBaseTabbarViewController-QMUITabBarViewController"><a href="#FGBaseTabbarViewController-QMUITabBarViewController" class="headerlink" title="FGBaseTabbarViewController : QMUITabBarViewController"></a>FGBaseTabbarViewController : QMUITabBarViewController</h6><h6 id="FGBaseTableViewController-QMUICommonTableViewController"><a href="#FGBaseTableViewController-QMUICommonTableViewController" class="headerlink" title="FGBaseTableViewController : QMUICommonTableViewController"></a>FGBaseTableViewController : QMUICommonTableViewController</h6><h6 id="FGBaseViewController-QMUICommonViewController"><a href="#FGBaseViewController-QMUICommonViewController" class="headerlink" title="FGBaseViewController : QMUICommonViewController"></a>FGBaseViewController : QMUICommonViewController</h6><p>这里的tabbarVC/tableVC/baseVC都是基于qmui构建，做了一层隔离扩展，一方面是可以重写qmui里面的方法，另外也可以做到无缝替换。</p>
<hr>
<h3 id="PublicMethods层"><a href="#PublicMethods层" class="headerlink" title="PublicMethods层"></a>PublicMethods层</h3><h6 id="UIAlertController-FGBlocks"><a href="#UIAlertController-FGBlocks" class="headerlink" title="UIAlertController+FGBlocks"></a>UIAlertController+FGBlocks</h6><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby">/<span class="hljs-regexp">//</span> 弹出alert/actionsheet<br>/<span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> viewController 当前控制器<br>/<span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> title 标题<br>/<span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> message 内容<br>/<span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> preferredStyle 弹出方式<br>/<span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> cancelButtonTitle 取消按钮标题<br>/<span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> destructiveButtonTitle 作用按钮标题<br>/<span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> otherButtonTitles 附加按钮标题<br>/<span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> popoverPresentationControllerBlock 气泡菜单回调<br>/<span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> tapBlock 按钮点击回调<br>+ (nonnull instancetype)<span class="hljs-symbol">fg_showInViewController:</span>(nonnull UIViewController *)viewController<br>                                   <span class="hljs-symbol">withTitle:</span>(nullable NSString *)title<br>                                     <span class="hljs-symbol">message:</span>(nullable NSString *)message<br>                              <span class="hljs-symbol">preferredStyle:</span>(UIAlertControllerStyle)preferredStyle<br>                           <span class="hljs-symbol">cancelButtonTitle:</span>(nullable NSString *)cancelButtonTitle<br>                      <span class="hljs-symbol">destructiveButtonTitle:</span>(nullable NSString *)destructiveButtonTitle<br>                           <span class="hljs-symbol">otherButtonTitles:</span>(nullable NSArray *)otherButtonTitles<br><span class="hljs-comment">#if TARGET_OS_IOS</span><br>          <span class="hljs-symbol">popoverPresentationControllerBlock:</span>(nullable UIAlertControllerPopoverPresentationControllerBlock)popoverPresentationControllerBlock<br><span class="hljs-comment">#endif</span><br>                                    <span class="hljs-symbol">tapBlock:</span>(nullable UIAlertControllerCompletionBlock)tapBlock;<br><br><br><span class="hljs-regexp">//</span><span class="hljs-regexp">/ 弹出alert</span><br><span class="hljs-regexp">/</span><span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> viewController 当前控制器<br>/<span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> title 标题<br>/<span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> message 内容<br>/<span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> cancelButtonTitle  取消按钮标题<br>/<span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> destructiveButtonTitle 作用按钮标题<br>/<span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> otherButtonTitles 附加按钮标题<br>/<span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> tapBlock 按钮点击回调<br>+ (nonnull instancetype)<span class="hljs-symbol">fg_showAlertInViewController:</span>(nonnull UIViewController *)viewController<br>                                        <span class="hljs-symbol">withTitle:</span>(nullable NSString *)title<br>                                          <span class="hljs-symbol">message:</span>(nullable NSString *)message<br>                                <span class="hljs-symbol">cancelButtonTitle:</span>(nullable NSString *)cancelButtonTitle<br>                           <span class="hljs-symbol">destructiveButtonTitle:</span>(nullable NSString *)destructiveButtonTitle<br>                                <span class="hljs-symbol">otherButtonTitles:</span>(nullable NSArray *)otherButtonTitles<br>                                         <span class="hljs-symbol">tapBlock:</span>(nullable UIAlertControllerCompletionBlock)tapBlock;<br><br><br><br><span class="hljs-regexp">//</span><span class="hljs-regexp">/ 弹出actionsheet</span><br><span class="hljs-regexp">/</span><span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> viewController 当前控制器<br>/<span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> title 标题<br>/<span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> message 内容<br>/<span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> cancelButtonTitle 取消按钮标题<br>/<span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> destructiveButtonTitle 作用按钮标题<br>/<span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> otherButtonTitles 附加按钮标题<br>/<span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> popoverPresentationControllerBlock 气泡菜单回调<br>/<span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> tapBlock 按钮点击回调<br>+ (nonnull instancetype)<span class="hljs-symbol">fg_showActionSheetInViewController:</span>(nonnull UIViewController *)viewController<br>                                              <span class="hljs-symbol">withTitle:</span>(nullable NSString *)title<br>                                                <span class="hljs-symbol">message:</span>(nullable NSString *)message<br>                                      <span class="hljs-symbol">cancelButtonTitle:</span>(nullable NSString *)cancelButtonTitle<br>                                 <span class="hljs-symbol">destructiveButtonTitle:</span>(nullable NSString *)destructiveButtonTitle<br>                                      <span class="hljs-symbol">otherButtonTitles:</span>(nullable NSArray *)otherButtonTitles<br><span class="hljs-comment">#if TARGET_OS_IOS</span><br>                     <span class="hljs-symbol">popoverPresentationControllerBlock:</span>(nullable UIAlertControllerPopoverPresentationControllerBlock)popoverPresentationControllerBlock<br><span class="hljs-comment">#endif</span><br>                                               <span class="hljs-symbol">tapBlock:</span>(nullable UIAlertControllerCompletionBlock)tapBlock;<br><br><br><span class="hljs-variable">@property</span> (readonly, nonatomic) BOOL visible; <span class="hljs-regexp">//</span>是否可视<br><span class="hljs-variable">@property</span> (readonly, nonatomic) NSInteger cancelButtonIndex; <span class="hljs-regexp">//</span>取消索引<br><span class="hljs-variable">@property</span> (readonly, nonatomic) NSInteger firstOtherButtonIndex; <span class="hljs-regexp">//</span>第一个附加按钮索引<br><span class="hljs-variable">@property</span> (readonly, nonatomic) NSInteger destructiveButtonIndex; <span class="hljs-regexp">//</span>动作按钮索引<br></code></pre></td></tr></table></figure>
<hr>
<h6 id="UIBarButtonItem-FGBuildObject"><a href="#UIBarButtonItem-FGBuildObject" class="headerlink" title="UIBarButtonItem+FGBuildObject"></a>UIBarButtonItem+FGBuildObject</h6><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby">+ (instancetype)<span class="hljs-symbol">fg_itemWithImage:</span>(id)image<br>                          <span class="hljs-symbol">offset:</span>(CGFloat)offset<br>                          <span class="hljs-symbol">target:</span>(nullable id)target<br>                          <span class="hljs-symbol">action:</span>(nullable SEL)action;<br><br>+ (instancetype)<span class="hljs-symbol">fg_itemWithImage:</span>(id)image<br>                <span class="hljs-symbol">highlightedColor:</span>(nullable UIColor *)highlightedColor<br>                          <span class="hljs-symbol">offset:</span>(CGFloat)offset<br>                          <span class="hljs-symbol">target:</span>(nullable id)target<br>                          <span class="hljs-symbol">action:</span>(nullable SEL)action;<br><br>+ (instancetype)<span class="hljs-symbol">fg_itemWithTitle:</span>(NSString *)title<br>                          <span class="hljs-symbol">target:</span>(nullable id)target<br>                          <span class="hljs-symbol">action:</span>(nullable SEL)action;<br><br>+ (instancetype)<span class="hljs-symbol">fg_itemWithTitle:</span>(NSString *)title<br>                          <span class="hljs-symbol">offset:</span>(CGFloat)offset<br>                          <span class="hljs-symbol">target:</span>(nullable id)target<br>                          <span class="hljs-symbol">action:</span>(nullable SEL)action;<br><br>+ (instancetype)<span class="hljs-symbol">fg_itemWithTitle:</span>(NSString *)title<br>                <span class="hljs-symbol">normalAttributes:</span>(nullable NSDictionary *)normalAttributes<br>           <span class="hljs-symbol">highlightedAttributes:</span>(nullable NSDictionary *)highlightedAttributes<br>                          <span class="hljs-symbol">offset:</span>(CGFloat)offset<br>                          <span class="hljs-symbol">target:</span>(nullable id)target<br>                          <span class="hljs-symbol">action:</span>(nullable SEL)action;<br></code></pre></td></tr></table></figure>
<p>UIBarButtonItem的附加构造方法，加入了高亮色highlightedColor以及offset图片水平偏移的设置</p>
<hr>
<h6 id="UIButton-FGLoading"><a href="#UIButton-FGLoading" class="headerlink" title="UIButton+FGLoading"></a>UIButton+FGLoading</h6><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby">/<span class="hljs-regexp">//</span> 开始加载<br>- (void)fg_startLoading;<br><br><span class="hljs-regexp">//</span><span class="hljs-regexp">/ 结束加载</span><br><span class="hljs-regexp">- (void)fg_stopLoading;</span><br></code></pre></td></tr></table></figure>
<hr>
<h6 id="UICollectionViewCell-FGAdditions"><a href="#UICollectionViewCell-FGAdditions" class="headerlink" title="UICollectionViewCell+FGAdditions"></a>UICollectionViewCell+FGAdditions</h6><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby">/<span class="hljs-regexp">/内层底部视图</span><br><span class="hljs-regexp">@property (nonatomic, strong) UIView *insertsView;</span><br><span class="hljs-regexp">/</span><span class="hljs-regexp">/获取重用cellId</span><br><span class="hljs-regexp">+ (NSString *)fg_cellId;</span><br><span class="hljs-regexp">/</span><span class="hljs-regexp">//</span> 内层构建约束<br>/<span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> edge 内边距<br>- (void)<span class="hljs-symbol">fg_createInsertsView:</span>(UIEdgeInsets)edge;<br><span class="hljs-regexp">//</span>允许cell提供高度设置<br>+ (CGSize)fg_dynamicSizeCell;<br></code></pre></td></tr></table></figure>
<hr>
<h6 id="UIImage-FGUtilities"><a href="#UIImage-FGUtilities" class="headerlink" title="UIImage+FGUtilities"></a>UIImage+FGUtilities</h6><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby">/*!<br> <span class="hljs-variable">@abstract</span> Return the image object associated with the specified filename.<br> <span class="hljs-variable">@param</span> resource The name of file.<br> <span class="hljs-variable">@result</span> An UIImage object, <span class="hljs-keyword">or</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">if</span> no resource <span class="hljs-keyword">or</span> error resource.<br> <span class="hljs-variable">@discussion</span><br> This method loads the image data from the specified file, but <span class="hljs-keyword">not</span> caches it.<br> *<span class="hljs-regexp">/</span><br><span class="hljs-regexp">+ (nullable UIImage *)fg_imageWithResource:(NSString *)resource;</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">/</span>*!<br> <span class="hljs-variable">@abstract</span> Return the animated image object associated with the specified filename.<br> <span class="hljs-variable">@param</span> resource The name of file.<br> <span class="hljs-variable">@result</span> An UIImage object, <span class="hljs-keyword">or</span> <span class="hljs-literal">nil</span> <span class="hljs-keyword">if</span> no resource <span class="hljs-keyword">or</span> error resource.<br> *<span class="hljs-regexp">/</span><br><span class="hljs-regexp">+ (nullable UIImage *)fg_animatedImageWithResource:(NSString *)resource;</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">/</span>**<br> 压缩图片 限制图片的最大长边的长度为newImageWidth<br> <br> <span class="hljs-variable">@param</span> image 图片<br> <span class="hljs-variable">@param</span> newImageWidth 最大长边值<br> <span class="hljs-variable">@return</span> 裁剪后的新图片<br> *<span class="hljs-regexp">/</span><br><span class="hljs-regexp">+ (UIImage *)fg_compressImage:(UIImage *)image newWidth:(CGFloat)newImageWidth;</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">/</span>**<br> 压缩长图 限制图片的最小长边的长度为newImageWidth<br> <br> 长图： 宽&gt;=长*<span class="hljs-number">2</span>  或者 长&gt;=宽*<span class="hljs-number">2</span><br> <br> <span class="hljs-variable">@param</span> image 图片<br> <span class="hljs-variable">@param</span> newImageWidth 最大长边值<br> <span class="hljs-variable">@return</span> 裁剪后的新图片<br> *<span class="hljs-regexp">/</span><br><span class="hljs-regexp">+ (UIImage *) fg_compressLongImage:(UIImage *)image newWidth:(CGFloat)newImageWidth;</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">/</span>**<br> 是否为长图<br> <br> 长图： 宽&gt;=长*<span class="hljs-number">2</span>  或者 长&gt;=宽*<span class="hljs-number">2</span><br> <br> <span class="hljs-variable">@return</span> <span class="hljs-keyword">return</span> value description<br> *<span class="hljs-regexp">/</span><br><span class="hljs-regexp">- (BOOL) fg_isLongImage;</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">/</span><span class="hljs-regexp">//</span>  将原图片按照size绘制<br>/<span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> image 原图<br>/<span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> size 目的size<br>+ (UIImage*) <span class="hljs-symbol">fg_originImage:</span>(UIImage *)image <span class="hljs-symbol">scaleToSize:</span>(CGSize)size;<br><br><span class="hljs-regexp">//</span><span class="hljs-regexp">/ 修正图片的方向</span><br><span class="hljs-regexp">- (UIImage *)fg_fixOrientation;</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">/</span><span class="hljs-regexp">//</span> 更改图片本身的朝向<br>/<span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> orient 方向<br>- (UIImage *)<span class="hljs-symbol">fg_rotate:</span>(UIImageOrientation)orient;<br><br><br><span class="hljs-regexp">//</span><span class="hljs-regexp">/ 图片旋转</span><br><span class="hljs-regexp">/</span><span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> rotate 旋转角度参数<br>- (UIImage *)<span class="hljs-symbol">fg_rotateAngle:</span>(NSInteger)rotate;<br></code></pre></td></tr></table></figure>
<hr>
<h6 id="UILabel-FGLoadMutableAttibute"><a href="#UILabel-FGLoadMutableAttibute" class="headerlink" title="UILabel+FGLoadMutableAttibute"></a>UILabel+FGLoadMutableAttibute</h6><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby">/<span class="hljs-regexp">//</span> 加载html<br>/<span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> htmlStr html字符串<br>- (void)<span class="hljs-symbol">fg_loadHtml:</span>(NSString *)htmlStr;<br><br><span class="hljs-regexp">//</span><span class="hljs-regexp">/ 加载文件html</span><br><span class="hljs-regexp">/</span><span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> filePath 文件路径<br>- (void)<span class="hljs-symbol">fg_loadHtmlFromFilePath:</span>(NSString *)filePath;<br></code></pre></td></tr></table></figure>
<hr>
<h6 id="CALayer-FGDrawing-UIView-FGDrawing"><a href="#CALayer-FGDrawing-UIView-FGDrawing" class="headerlink" title="CALayer+FGDrawing/UIView+FGDrawing"></a>CALayer+FGDrawing/UIView+FGDrawing</h6><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby">/<span class="hljs-regexp">//</span> 添加阴影<br>/<span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> shadow 阴影结构数据<br>- (void)<span class="hljs-symbol">fg_addShadow:</span>(FGShadow)shadow;<br><br><span class="hljs-regexp">//</span><span class="hljs-regexp">/ 添加边框</span><br><span class="hljs-regexp">/</span><span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> border 边框结构数据<br>- (void)<span class="hljs-symbol">fg_addBorder:</span>(FGBorder)border;<br><br><span class="hljs-regexp">//</span><span class="hljs-regexp">/ 添加圆角</span><br><span class="hljs-regexp">/</span><span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> radius 圆角半径<br>- (void)<span class="hljs-symbol">fg_addCorner:</span>(CGFloat)radius;<br><br><span class="hljs-regexp">//</span><span class="hljs-regexp">/ 添加边框、圆角</span><br><span class="hljs-regexp">/</span><span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> border 边框结构数据<br>/<span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> radius 圆角结构数据<br>- (void)<span class="hljs-symbol">fg_addBorder:</span>(FGBorder)border <span class="hljs-symbol">radius:</span>(CGFloat)radius;<br></code></pre></td></tr></table></figure>
<hr>
<h6 id="UIScrollView-FGMultiply"><a href="#UIScrollView-FGMultiply" class="headerlink" title="UIScrollView+FGMultiply"></a>UIScrollView+FGMultiply</h6><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby">/<span class="hljs-regexp">//</span> 嵌套时是否随着手势生效<br><span class="hljs-variable">@property</span> (nonatomic, strong) NSNumber *recognizeScrollEnable;<br><span class="hljs-regexp">//</span>监听滚动停止<br><span class="hljs-variable">@property</span> (nonatomic, copy, nullable) FGMultiplyScrollHandle handle;<br></code></pre></td></tr></table></figure>
<hr>
<h6 id="UITabBar-FGCustomBadge"><a href="#UITabBar-FGCustomBadge" class="headerlink" title="UITabBar+FGCustomBadge"></a>UITabBar+FGCustomBadge</h6><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby">/**<br> *<br> *设置tab上icon的宽度，用于调整badge的位置<br> *<span class="hljs-regexp">/</span><br><span class="hljs-regexp">- (void)fg_setTabIconWidth:(CGFloat)width;</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">/</span>**<br> *设置badge的top<br> *<span class="hljs-regexp">/</span><br><span class="hljs-regexp">- (void)fg_setBadgeTop:(CGFloat)top;</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">/</span>**<br> *设置badge样、数字<br> *<span class="hljs-regexp">/</span><br><span class="hljs-regexp">- (void)fg_setBadgeStyle:(FGSKMCustomBadgeStyleType)type value:(NSInteger)badgeValue atIndex:(NSInteger)index;</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">/</span>**<br> 清空所有红点视图<br> *<span class="hljs-regexp">/</span><br><span class="hljs-regexp">- (void)fg_cleanAllBadgeView;</span><br></code></pre></td></tr></table></figure>
<hr>
<h6 id="UITabBarItem-FGBuildObject"><a href="#UITabBarItem-FGBuildObject" class="headerlink" title="UITabBarItem+FGBuildObject"></a>UITabBarItem+FGBuildObject</h6><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby">/<span class="hljs-regexp">/附加构建方法</span><br><span class="hljs-regexp">+ (instancetype)fg_itemWithTitle:(nullable NSString *)title image:(nullable NSString *)image tag:(NSInteger)tag;</span><br><span class="hljs-regexp">+ (instancetype)fg_itemWithTitle:(nullable NSString *)title image:(nullable NSString *)image selectedImage:(nullable NSString *)selectedImage;</span><br></code></pre></td></tr></table></figure>
<hr>
<h6 id="UITableView-FGWeexTable"><a href="#UITableView-FGWeexTable" class="headerlink" title="UITableView+FGWeexTable"></a>UITableView+FGWeexTable</h6><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby">/<span class="hljs-regexp">/底部footview隐藏</span><br><span class="hljs-regexp">- (void)fg_hideCellFootView;</span><br></code></pre></td></tr></table></figure>
<hr>
<h6 id="UITableViewCell-FGAdditions"><a href="#UITableViewCell-FGAdditions" class="headerlink" title="UITableViewCell+FGAdditions"></a>UITableViewCell+FGAdditions</h6><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby">/<span class="hljs-regexp">/内层底部视图</span><br><span class="hljs-regexp">@property (nonatomic, strong) UIView *insertsView;</span><br><span class="hljs-regexp">/</span><span class="hljs-regexp">/获取重用cellId</span><br><span class="hljs-regexp">+ (NSString *)fg_cellId;</span><br><span class="hljs-regexp">/</span><span class="hljs-regexp">//</span> 内层构建约束<br>/<span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> edge 内边距<br>- (void)<span class="hljs-symbol">fg_createInsertsView:</span>(UIEdgeInsets)edge;<br><br><span class="hljs-regexp">//</span>允许cell提供高度设置<br>- (CGFloat)<span class="hljs-symbol">fg_dynamicRowHeight:</span>(UITableViewCell *)cell<br>                  <span class="hljs-symbol">tableView:</span>(UITableView *)tableView;<br></code></pre></td></tr></table></figure>
<hr>
<h6 id="UITextField-FGUtilities"><a href="#UITextField-FGUtilities" class="headerlink" title="UITextField+FGUtilities"></a>UITextField+FGUtilities</h6><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-variable">@property</span> (nonatomic, nullable) UIColor *placeholdColor; <span class="hljs-regexp">//</span><span class="hljs-regexp">/&lt; The color of the placehold.</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">/</span>*!<br> <span class="hljs-variable">@abstract</span> Limit the maximum number of inputs. Emoji is regarded as a unit length.<br> <span class="hljs-variable">@param</span> number The maximum number of inputs.<br> <span class="hljs-variable">@param</span> autoIntercept Whether needs interception.<br> <span class="hljs-variable">@result</span> The number of inputs.<br> *<span class="hljs-regexp">/</span><br><span class="hljs-regexp">- (NSInteger) fg_limitMaxNumber:(NSInteger)number autoIntercept:(BOOL)autoIntercept;</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">/</span><span class="hljs-regexp">//</span> 失去第一响应<br>+ (void) fg_allResignFirstResponder;<br><br><span class="hljs-regexp">//</span><span class="hljs-regexp">/ 选中范围</span><br><span class="hljs-regexp">- (void) fg_selectTextAtRange:(NSRange)range;</span><br></code></pre></td></tr></table></figure>
<hr>
<h6 id="UITextView-FGUtilities"><a href="#UITextView-FGUtilities" class="headerlink" title="UITextView+FGUtilities"></a>UITextView+FGUtilities</h6><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby">/<span class="hljs-regexp">//</span> 限制字符长度<br>/<span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> number 长度<br>/<span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> autoIntercept 是否自动打断<br>- (NSInteger)<span class="hljs-symbol">fg_limitMaxNumber:</span>(NSInteger)number<br>                 <span class="hljs-symbol">autoIntercept:</span>(BOOL)autoIntercept;<br></code></pre></td></tr></table></figure>
<hr>
<h6 id="UIView-FGUtilities"><a href="#UIView-FGUtilities" class="headerlink" title="UIView+FGUtilities"></a>UIView+FGUtilities</h6><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby">/<span class="hljs-regexp">//</span> 绘制左上右上圆角<br>/<span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> radious 圆角半径<br>- (void)<span class="hljs-symbol">fg_roundedCornersOnTopWithRadious:</span>(CGFloat)radious;<br><br><span class="hljs-regexp">//</span><span class="hljs-regexp">/ 绘制左上圆角</span><br><span class="hljs-regexp">/</span><span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> radious 圆角半径<br>- (void)<span class="hljs-symbol">fg_roundedCornersOnTopLeftWithRadious:</span>(CGFloat)radious;<br><br><span class="hljs-regexp">//</span><span class="hljs-regexp">/ 绘制右上圆角</span><br><span class="hljs-regexp">/</span><span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> radious 圆角半径<br>- (void)<span class="hljs-symbol">fg_roundedCornersOnTopRightWithRadious:</span>(CGFloat)radious;<br><br><span class="hljs-regexp">//</span><span class="hljs-regexp">/ 绘制左下右下圆角</span><br><span class="hljs-regexp">/</span><span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> radious 圆角半径<br>- (void)<span class="hljs-symbol">fg_roundedCornersOnBottomWithRadious:</span>(CGFloat)radious;<br><br><span class="hljs-regexp">//</span><span class="hljs-regexp">/ 绘制左下圆角</span><br><span class="hljs-regexp">/</span><span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> radious 圆角半径<br>- (void)<span class="hljs-symbol">fg_roundedCornersOnBottomLeftWithRadious:</span>(CGFloat)radious;<br><br><span class="hljs-regexp">//</span><span class="hljs-regexp">/ 绘制右下圆角</span><br><span class="hljs-regexp">/</span><span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> radious 圆角半径<br>- (void)<span class="hljs-symbol">fg_roundedCornersOnBottomRightWithRadious:</span>(CGFloat)radious;<br><br><span class="hljs-regexp">//</span><span class="hljs-regexp">/ 绘制全部圆角</span><br><span class="hljs-regexp">/</span><span class="hljs-regexp">//</span> <span class="hljs-variable">@param</span> radious 圆角半径<br>- (void)<span class="hljs-symbol">fg_roundedCornersOnAllSideWithRadious:</span>(CGFloat)radious;<br></code></pre></td></tr></table></figure>
<hr>
<h6 id="FGViewCreateUtil"><a href="#FGViewCreateUtil" class="headerlink" title="FGViewCreateUtil"></a>FGViewCreateUtil</h6><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby">/<span class="hljs-regexp">/构建UILabel</span><br><span class="hljs-regexp">- (UILabel *)fg_label:(UIFont *)font</span><br><span class="hljs-regexp">             color:(UIColor *)color</span><br><span class="hljs-regexp">              text:(NSString *)text;</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">- (UILabel *)fg_label:(UIFont *)font</span><br><span class="hljs-regexp">             color:(UIColor *)color</span><br><span class="hljs-regexp">              text:(NSString *)text</span><br><span class="hljs-regexp">        numerLines:(NSInteger)lines;</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">- (UILabel *)fg_label:(UIFont *)font</span><br><span class="hljs-regexp">             color:(UIColor *)color</span><br><span class="hljs-regexp">              text:(NSString *)text</span><br><span class="hljs-regexp">      textAligment:(NSTextAlignment)textAlignment</span><br><span class="hljs-regexp">        numerLines:(NSInteger)lines;</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">/</span><span class="hljs-regexp">/构建UIButton</span><br><span class="hljs-regexp">- (UIButton *)fg_btn:(nonnull NSString *)text</span><br><span class="hljs-regexp">             font:(nonnull UIFont *)font</span><br><span class="hljs-regexp">            color:(nonnull UIColor *)color</span><br><span class="hljs-regexp">  backGroundColor:(nonnull UIColor *)backGroundColor;</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">- (UIButton *)fg_btn:(nonnull NSString *)normalImage</span><br><span class="hljs-regexp">    selectedImage:(nullable NSString *)selectedImage;</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">- (void)fg_btn:(UIButton *)btn</span><br><span class="hljs-regexp">         title:(NSString *)title</span><br><span class="hljs-regexp">    titleColor:(UIColor *)titleColor</span><br><span class="hljs-regexp">          font:(UIFont *)font</span><br><span class="hljs-regexp">   normalImage:(NSString *)normalImage;</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">/</span><span class="hljs-regexp">/构建UITableView</span><br><span class="hljs-regexp">- (UITableView *)fg_tableViewConfig:(id&lt;UITableViewDelegate,UITableViewDataSource&gt;)delegate</span><br><span class="hljs-regexp">                           style:(UITableViewStyle)style;</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">/</span><span class="hljs-regexp">/UITableView注册多个UITableViewCell类型</span><br><span class="hljs-regexp">- (void)fg_registerCells:(NSArray *)arr</span><br><span class="hljs-regexp">            tableView:(UITableView *)tableView;</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">- (void)fg_registerCellsDic:(NSDictionary *)dic</span><br><span class="hljs-regexp">               tableView:(UITableView *)tableView;</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">/</span><span class="hljs-regexp">/设置当前滚动视图contentInset不自动调整</span><br><span class="hljs-regexp">- (void)fg_setAutoContentAdjustment:(UIScrollView *)scrollView;</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">/</span><span class="hljs-regexp">/禁用UITableView的估算行高</span><br><span class="hljs-regexp">- (void)fg_stopTableViewEstimated:(UITableView *)tableView;</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">/</span><span class="hljs-regexp">/提供手势点击方法</span><br><span class="hljs-regexp">- (void)fg_addTapGesture:(UIView *)view</span><br><span class="hljs-regexp">               action:(SEL)action;</span><br></code></pre></td></tr></table></figure>
<hr>
<h6 id="WKWebView-FGUtilities"><a href="#WKWebView-FGUtilities" class="headerlink" title="WKWebView+FGUtilities"></a>WKWebView+FGUtilities</h6><figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby">/<span class="hljs-regexp">/截图</span><br><span class="hljs-regexp">- (void ) fg_screenFromContentSizeHeight:(float)height</span><br><span class="hljs-regexp">                            andSnapshot:(void(^)(UIImage *snapShotImage))finishBlock;</span><br></code></pre></td></tr></table></figure>
<hr>
<p>这里显示的都是关于UI设置及方法方面的，后续如果存在新增请在对应的分块中进行，并修改podspec文件后再升级。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>base, framework, 梳理</tag>
      </tags>
  </entry>
  <entry>
    <title>基础库梳理一</title>
    <url>/2020/04/13/iOS/%E7%BB%84%E4%BB%B6%E5%8C%96(%E4%B8%80)-%E5%9F%BA%E7%A1%80%E5%BA%93%E7%9A%84%E6%A2%B3%E7%90%86/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>当iOS的项目比较成熟后，下一步伴随着的设计必然是进行相关组件化的尝试，也就是最后的项目设计必然是模块化，而模块化的前提必然是进行公共组件或者业务的提取，构建成对应的成熟可扩展的framwork进行引入就可以使用其中的api业务。</p>
<hr>
<h3 id="整体结构图"><a href="#整体结构图" class="headerlink" title="整体结构图"></a>整体结构图</h3><p>下面是关于我们本身应用设计的整体组件结构图</p>
<p><img src="/images/iOS/structure_program.jpeg"></p>
<hr>
<h3 id="着手开始"><a href="#着手开始" class="headerlink" title="着手开始"></a>着手开始</h3><p>我们前面进行常用公共方法api集成构建的<code>PublicMethods</code>模块即可看做是其中初步实现的基础工具类集群framework，那下面我要处理的是项目中UI和数据等构建的基础视图库framework和基础数据库framework。</p>
<hr>
<h3 id="梳理第一章节"><a href="#梳理第一章节" class="headerlink" title="梳理第一章节"></a>梳理第一章节</h3><h4 id="基础视图库framework"><a href="#基础视图库framework" class="headerlink" title="基础视图库framework"></a>基础视图库framework</h4><p>目前比较成熟的基础UI库就是对应的QMUIKit框架，那么我们目前是以该框架为原型进行继承构建，主要是为了统一基础样式以及后续的可替换可维护性。这里对应的QMUI的视图不做介绍，这里只是对其缺失的需要进行相关的补充.</p>
<hr>
<h6 id="UIView–系统类基础视图"><a href="#UIView–系统类基础视图" class="headerlink" title="UIView–系统类基础视图"></a>UIView–系统类基础视图</h6><p>1.做分类category(组件化思考)，包括：</p>
<ul>
<li>空白视图(也可直接应用QMUIKit的QMUIEmptyView)</li>
<li>红点badge(可引入或者仿写第三方框架)</li>
<li>事件绑定</li>
<li>视图背景图加载</li>
</ul>
<hr>
<h5 id="UIButton–系统类基础按钮"><a href="#UIButton–系统类基础按钮" class="headerlink" title="UIButton–系统类基础按钮"></a>UIButton–系统类基础按钮</h5><p>分类实现，包括：</p>
<ul>
<li>按钮远程图片加载</li>
<li>响应区设置</li>
</ul>
<hr>
<h5 id="UIScrollView–系统类基础滚动视图"><a href="#UIScrollView–系统类基础滚动视图" class="headerlink" title="UIScrollView–系统类基础滚动视图"></a>UIScrollView–系统类基础滚动视图</h5><p>分类实现，包括：</p>
<ul>
<li>重复嵌套的手势识别字段控制</li>
</ul>
<hr>
<h5 id="UILabel–系统类基础标签文本视图"><a href="#UILabel–系统类基础标签文本视图" class="headerlink" title="UILabel–系统类基础标签文本视图"></a>UILabel–系统类基础标签文本视图</h5><p>这里继承QMUILabel即可，提供：</p>
<ul>
<li>提供加载html或者富文本的api</li>
</ul>
<hr>
<h5 id="UITextView–系统类基础多行文本视图"><a href="#UITextView–系统类基础多行文本视图" class="headerlink" title="UITextView–系统类基础多行文本视图"></a>UITextView–系统类基础多行文本视图</h5><p>这里继承QMUITextView即可，提供：</p>
<ul>
<li>验证输入代理</li>
<li>宽度计算</li>
</ul>
<hr>
<h5 id="UITableViewCell–系统类基础表单cell视图"><a href="#UITableViewCell–系统类基础表单cell视图" class="headerlink" title="UITableViewCell–系统类基础表单cell视图"></a>UITableViewCell–系统类基础表单cell视图</h5><p>这里走继承体系QMUITableViewCell,主要是为了承接多态设计</p>
<figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@interface</span> <span class="hljs-attribute">BaseTableViewCell </span>: QMUITableViewCell<br><br><span class="hljs-variable">@property</span> (nonatomic, strong) id model;<br><br><span class="hljs-selector-tag">-</span> (void)<span class="hljs-selector-tag">defaultSetting</span>;<br><br><span class="hljs-selector-tag">-</span> (void)<span class="hljs-selector-tag">setUI</span>;<br><br>@<span class="hljs-selector-tag">end</span><br></code></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">BaseTableViewCell</span></span><br>- (<span class="hljs-keyword">instancetype</span>)initWithStyle:(<span class="hljs-built_in">UITableViewCellStyle</span>)style reuseIdentifier:(<span class="hljs-built_in">NSString</span> *)reuseIdentifier &#123;<br>    <span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> initWithStyle:style reuseIdentifier:reuseIdentifier];<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>) &#123;<br>        [<span class="hljs-keyword">self</span> defaultSetting];<br>        [<span class="hljs-keyword">self</span> setUI];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)defaultSetting &#123;<br>    <span class="hljs-keyword">self</span>.layer.shouldRasterize = <span class="hljs-literal">YES</span>;<br>    <span class="hljs-keyword">self</span>.layer.rasterizationScale = [<span class="hljs-built_in">UIScreen</span> mainScreen].scale;<br>    <span class="hljs-keyword">self</span>.layer.contentsScale = [<span class="hljs-built_in">UIScreen</span> mainScreen].scale;<br>    <span class="hljs-keyword">self</span>.selectionStyle = <span class="hljs-built_in">UITableViewCellSelectionStyleNone</span>;<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)setUI &#123;<br>    [<span class="hljs-keyword">self</span> createInsertsView:<span class="hljs-built_in">UIEdgeInsetsMake</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)];<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>

<hr>
<h5 id="UICollectionViewCell–系统类基础九宫格cell视图"><a href="#UICollectionViewCell–系统类基础九宫格cell视图" class="headerlink" title="UICollectionViewCell–系统类基础九宫格cell视图"></a>UICollectionViewCell–系统类基础九宫格cell视图</h5><p>走继承UICollectionViewCell,主要是为了承接多态设计</p>
<figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@interface</span> <span class="hljs-attribute">BaseCollectionViewCell </span>: UICollectionViewCell<br><br><span class="hljs-variable">@property</span> (nonatomic, strong) id model;<br><span class="hljs-comment">//指明indexPath</span><br><span class="hljs-variable">@property</span> (nonatomic, strong) NSIndexPath *indexPath;<br><br><span class="hljs-selector-tag">-</span> (void)<span class="hljs-selector-tag">defaultSetting</span>;<br><br><span class="hljs-selector-tag">-</span> (void)<span class="hljs-selector-tag">setUI</span>;<br><br>@<span class="hljs-selector-tag">end</span><br></code></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">BaseCollectionViewCell</span></span><br><br>- (<span class="hljs-keyword">instancetype</span>)initWithFrame:(<span class="hljs-built_in">CGRect</span>)frame &#123;<br>    <span class="hljs-keyword">self</span> = [<span class="hljs-keyword">super</span> initWithFrame:frame];<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>) &#123;<br>        [<span class="hljs-keyword">self</span> defaultSetting];<br>        [<span class="hljs-keyword">self</span> setUI];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)defaultSetting &#123;<br>    <span class="hljs-keyword">self</span>.layer.masksToBounds = <span class="hljs-literal">NO</span>;<br>    <span class="hljs-keyword">self</span>.layer.contentsScale = [<span class="hljs-built_in">UIScreen</span> mainScreen].scale;<br>&#125;<br><br>- (<span class="hljs-keyword">void</span>)setUI &#123;<br>    [<span class="hljs-keyword">self</span> createInsertsView:<span class="hljs-built_in">UIEdgeInsetsMake</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)];<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h5 id="UIViewcontroller–基础控制器"><a href="#UIViewcontroller–基础控制器" class="headerlink" title="UIViewcontroller–基础控制器"></a>UIViewcontroller–基础控制器</h5><p>基础控制器一般是构建一个基础BaseViewcontroller继承UIViewcontroller作为顶层可扩展类。</p>
<p>划分结构：</p>
<p>1.状态栏statusBar样式</p>
<ul>
<li>使用UIViewcontroller的分类进行api的控制，因为子类可以重写改变</li>
</ul>
<p>2.自动旋转，目前应用不支持自动旋转，这里省略</p>
<p>3.视图操作</p>
<ul>
<li>构建viewDidLoad的默认setting方法，让子类重写</li>
<li>根据route进行参数映射公共方法解析</li>
</ul>
<hr>
<blockquote>
<p>基础的就是上面一些，下面就是关于BaseViewcontroller继承扩展的控制器：</p>
</blockquote>
<h6 id="1-BaseListViewController"><a href="#1-BaseListViewController" class="headerlink" title="1.BaseListViewController"></a>1.BaseListViewController</h6><p>顾名思义，就是列表视图的常用结构，提供子类重写便于扩展(如果想使用QMUITableView的组件机制也是可行的)</p>
<ul>
<li>提供上下刷新的组件分类</li>
<li>提供空白页显示的组件分类</li>
<li>提供刷新提示语控制的组件分类</li>
<li>其他业务操作组件分类</li>
</ul>
<h6 id="2-BaseWebViewController"><a href="#2-BaseWebViewController" class="headerlink" title="2.BaseWebViewController"></a>2.BaseWebViewController</h6><p>进行h5页面装载的容器控制器</p>
<ul>
<li>常规UI设置及url加载逻辑</li>
<li>桥接组件化分类</li>
<li>代理组件化分类</li>
<li>其他业务操作组件化分类</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>base, framework, 梳理</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS表单适配器</title>
    <url>/2020/04/10/iOS/%E8%A1%A8%E5%8D%95%E9%80%82%E9%85%8D%E5%99%A8/</url>
    <content><![CDATA[<p>最近结合安卓端对表单适配器的定义，考虑到iOS端一直以来在控制器里面做datasource和delegate的操作，所以进行了一些联想。我们知道iOS里面tableView的datasource和delegate其本质其实是一种适配器模式，而在安卓设计中，他们有具体的适配器协议和基础类，通过继承的方式由表单去更换适配器来达到数据更换的目的，所以由此形成下列关于表单的一项关于适配器处理的变化构图</p>
<p><img src="/images/iOS/tableview_adapter_struture.jpeg"></p>
<blockquote>
<p>具体的在图片里已经有说明，实质上也就是通过协议和适配器将数据和控制器达到某种程度上的分离，如果在delegate中关于视图操作更复杂化，那么要么扩展协议进行处理，要么就是不采用这种方式，灵活而定。其中子类1、子类2等就是让我们可以进行代理适配器的变更达到更换适配逻辑而不影响控制层或者是整体结构等的目的。</p>
</blockquote>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS表单适配器, datasource, delegate, 适配器</tag>
      </tags>
  </entry>
  <entry>
    <title>相册浏览器使用手册</title>
    <url>/2020/04/09/iOS/%E7%9B%B8%E5%86%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<p>最近做了相册浏览器的扩展开发功能，这里感谢缪烨大大，开发了基础功能，我只是站在巨人的肩膀上。这个扩展的核心点在于增加了适配器处理，简单点来说就是将UI显示做到与数据分离，所有的数据来源通过适配器调用，而UI与数据之间使用了一层协议进行隔离，消除后续数据类型变更造成全面修改，增加灵活性。</p>
<p>这里我们首先来看一下整体设计示意图：</p>
<p><img src="/images/iOS/album_preview_structure.jpeg"></p>
<p>这里解释一下：</p>
<ul>
<li>适配代理器指的是当前要自定义适配而实现适配协议的那个代理类，可以根据需要自己指定；</li>
<li>所有的数据模型必须实现定义的协议，协议的字段是可选的，根据需要进行转换；</li>
<li>数据模型适配器提供了两种解析方式：一是通过适配代理器进行协议方法实现数据转换，二是通过模型自己实现属性值的映射，然后将模型数据扔给适配器就可以自动实现数据模型转换，这两种的本质都是为了将不同模型转换成协议规定的字段；</li>
<li>预览展示分栏控制层引用适配器，可以通过更换适配器对象来实现数据的更换，预览视图的变化是根据适配器来的，也就是预览时图的代理数据就是适配器，因为适配器在最外层，也就是我们只需要关心数据变化本身，而不关心内部视图的实现。</li>
</ul>
<hr>
<h3 id="实际显示示意图"><a href="#实际显示示意图" class="headerlink" title="实际显示示意图"></a>实际显示示意图</h3><p><img src="/images/iOS/album_actual_result.gif"></p>
<blockquote>
<p>这里是一个初版的相册浏览器组件，包含了视频和图片的预览，可以看到目前图片可以进行分类展示，也就是我们所说的二维样板，视频在这里展示显示是一个，但是后续会在此基础上根据需求样板进行扩展，将视频做成多视频展示，并且包含视频中自定义视图的兼容，目前在适配器中已提供自定义视图的扩展介入，待确定UI样式类型。</p>
</blockquote>
<hr>
<h3 id="层次结构图"><a href="#层次结构图" class="headerlink" title="层次结构图"></a>层次结构图</h3><p><img src="/images/iOS/album_code_structure.jpeg"></p>
<p>说明：</p>
<ul>
<li>FJKPhotoBaseView是基础构建视图，用于提供公用模型数据对接方法</li>
<li>FJKPreViewModelAdapterProtocol 包含所有的数据规则协议、代理适配协议、预览数据加载协议等</li>
<li>FJKPreViewModelAdapter 用于提供数据解析及数据传递的适配器</li>
<li>FJKNewPhotoPreviewViewController 用于进行相册浏览的控制层，后续所有的预览信息入口由该控制器承载<br>其余的属于定制的视图及控制器，不在核心，这里不予多阐述</li>
</ul>
<hr>
<h3 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h3><h4 id="1-首先确定需要预览的模型实现各自对应的协议，比如二维数组元素协议："><a href="#1-首先确定需要预览的模型实现各自对应的协议，比如二维数组元素协议：" class="headerlink" title="1.首先确定需要预览的模型实现各自对应的协议，比如二维数组元素协议："></a>1.首先确定需要预览的模型实现各自对应的协议，比如二维数组元素协议：</h4><figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@interface</span> <span class="hljs-attribute">FJKAlbumPhotoInfoModel </span>: NSObject&lt;FJKPreviewBaseArrayAdapterProtocol&gt;<br><span class="hljs-variable">@property</span> (nonatomic, copy) NSString *tag;<br><span class="hljs-variable">@property</span> (nonatomic, assign) NSInteger count;<br><span class="hljs-variable">@property</span> (nonatomic, copy) NSArray &lt;FJKAlbumPhotoDetailInfoModel&lt;FJKPicModelAdapterProtocol&gt; *&gt; *photoInfoList;<br><span class="hljs-variable">@end</span><br></code></pre></td></tr></table></figure>
<figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@interface</span> <span class="hljs-attribute">FJKAlbumVideoModel </span>: NSObject&lt;FJKPreviewBaseArrayAdapterProtocol&gt;<br><span class="hljs-variable">@property</span> (nonatomic, copy) NSString *tag;<br><span class="hljs-variable">@property</span> (nonatomic, assign) NSInteger count;<br><span class="hljs-variable">@property</span> (nonatomic, copy) NSArray &lt;FJKAlbumVideoDetailInfoModel&lt;FJKVedioModelAdapterProtocol&gt; *&gt; *videoInfoList;<br><span class="hljs-variable">@end</span><br></code></pre></td></tr></table></figure>
<p>不管是图片的二维数组元素模型还是视频二维数组元素模型都需要实现<code>FJKPreviewBaseArrayAdapterProtocol</code>这个二维数组协议。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">FJKPicModelAdapterProtocol</span> &lt;<span class="hljs-title">FJKPreviewBaseModelAdapterProtocol</span>&gt;</span><br><span class="hljs-keyword">@optional</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> * _Nullable url;         <span class="hljs-comment">//图片或者视频的地址</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *_Nullable agentId;      <span class="hljs-comment">//拍摄者ID</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *_Nullable agentName;    <span class="hljs-comment">//拍摄者名称</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *_Nullable placeholderImage;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *_Nullable picId;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *_Nullable location;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *_Nullable tag;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *_Nullable truePhotoDescription;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>) <span class="hljs-built_in">NSInteger</span> approveStatus;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *_Nullable createTime;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *_Nullable shootTime;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>
<p>这是底层一维具体图片信息的协议，也就是二维数组元素<code>FJKAlbumPhotoInfoModel</code>里面<code>FJKAlbumPhotoDetailInfoModel</code>模型需要实现该协议，意思就是不管<code>FJKAlbumPhotoDetailInfoModel</code>是什么样子，最终需要的数据形式都是<code>FJKPicModelAdapterProtocol</code>的形式。那么一维具体视频信息也类似。</p>
<blockquote>
<p>这里<code>FJKPreviewBaseModelAdapterProtocol</code>数据基础协议，请看里面：</p>
</blockquote>
<figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"><span class="hljs-comment">//基础模型协议</span><br><span class="hljs-variable">@protocol</span> FJKPreviewBaseModelAdapterProtocol &lt;NSObject&gt;<br><span class="hljs-variable">@optional</span><br><span class="hljs-comment">//用于构造属性转换</span><br>- (NSDictionary *_Nullable)exChangeproperties;<br><span class="hljs-variable">@end</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>这里只提供一个进行字段转换的映射方法，因为每个模型都可能需要，这个<code>exChangeproperties</code>协议方法实际上主要是自动解析需要做的字段配置映射，参考MJExtension的模型字段映射就明白了，关于自动适配解析会在下面讲到。</p>
</blockquote>
<h4 id="2-适配器的使用"><a href="#2-适配器的使用" class="headerlink" title="2.适配器的使用"></a>2.适配器的使用</h4><ul>
<li><strong>代理自定义适配</strong></li>
<li><strong>自动适配</strong></li>
</ul>
<h6 id="代理自定义适配"><a href="#代理自定义适配" class="headerlink" title="代理自定义适配:"></a>代理自定义适配:</h6><p>请看下面的例子：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">FJKPreViewModelAdapter *adapter = [FJKPreViewModelAdapter new]<span class="hljs-comment">;</span><br>adapter.selectedIndexPath = indexPath<span class="hljs-comment">;</span><br>adapter.dataSource = self<span class="hljs-comment">;</span><br>FJKNewPhotoPreviewViewController *previewVC = [FJKNewPhotoPreviewViewController new]<span class="hljs-comment">;</span><br>previewVC.adapter = adapter<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>其中<code>FJKPreViewModelAdapter</code>就是适配器，这里的selectedIndexPath表示默认初始预览哪张图或者视频,如果不赋值则默认第一张，这里适配器的dataSource是当前的控制器，那么请看数据源代理。</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//获取标题数组</span><br><span class="hljs-operator">-</span> (<span class="hljs-type">NSArray</span>&lt;<span class="hljs-type">NSString</span> *&gt; <span class="hljs-operator">*</span>_Nullable)numberDataOfTitles &#123;<br>    <span class="hljs-type">NSMutableArray</span> <span class="hljs-operator">*</span>titles <span class="hljs-operator">=</span> [<span class="hljs-type">NSMutableArray</span> array];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">FJKAlbumPhotoInfoModel</span> <span class="hljs-operator">*</span>model <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span>.albumModel.photoList) &#123;<br>        <span class="hljs-comment">// 配置照片内的tagTitles</span><br>        <span class="hljs-type">NSString</span> <span class="hljs-operator">*</span>title <span class="hljs-operator">=</span> [<span class="hljs-type">NSString</span> stringWithFormat:@<span class="hljs-string">&quot;%@(%ld)&quot;</span>,model.tag,model.count];<br>        [titles addObject:title];<br>    &#125;<br>    <span class="hljs-keyword">return</span> titles;<br>&#125;<br><br><span class="hljs-comment">//获取图片模型数组</span><br><span class="hljs-operator">-</span> (<span class="hljs-type">NSArray</span>&lt;<span class="hljs-type">NSObject</span>&lt;<span class="hljs-type">FJKPicModelAdapterProtocol</span>&gt; *&gt; <span class="hljs-operator">*</span>_Nullable)numberDataOfPicModels &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.albumModel.photoList;<br>&#125;<br><br><span class="hljs-comment">//获取视频模型数组</span><br><span class="hljs-operator">-</span> (<span class="hljs-type">NSArray</span>&lt;<span class="hljs-type">NSObject</span>&lt;<span class="hljs-type">FJKVedioModelAdapterProtocol</span>&gt; *&gt; <span class="hljs-operator">*</span>_Nullable)numberDataOfVedioModels&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.albumModel.videoList;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>大家大概明白是怎么回事了，就是通过dataSource的这三个协议方法将数据载入适配器。然后我们用于展示相册浏览的控制器<code>FJKNewPhotoPreviewViewController</code>直接赋值adapter就可以了，剩余的事情交给adapter去做就可以了。</p>
<h6 id="自动适配"><a href="#自动适配" class="headerlink" title="自动适配:"></a>自动适配:</h6><p>请看下面的例子：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><code class="hljs haxe"> FJKPreViewModelAdapter *adapter = [FJKPreViewModelAdapter <span class="hljs-keyword">new</span><span class="hljs-type"></span>];<br> adapter.selectedIndexPath = indexPath;<br><span class="hljs-comment">// adapter.dataSource = self;</span><br>[adapter adapterModel:<span class="hljs-type">strongSelf</span>.albumModel.photoList vedios:<span class="hljs-type">strongSelf</span>.albumModel.videoList];<br>FJKNewPhotoPreviewViewController *previewVC = [FJKNewPhotoPreviewViewController <span class="hljs-keyword">new</span><span class="hljs-type"></span>];<br>previewVC.adapter = adapter;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>这里就是不使用datasouce方式，而是直接将图片和视频的二维数组模型扔进适配器，难道这样就可以了吗，当然没这么简单，前面不是提到自动适配会有一道数据映射吗，这是协议规定的。该如何定义呢，这里用一维模型<code>FJKAlbumPhotoDetailInfoModel</code>来进行说明。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">FJKAlbumPhotoDetailInfoModel</span> : <span class="hljs-title">NSObject</span>&lt;<span class="hljs-title">FJKPicModelAdapterProtocol</span>&gt;</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *url;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *picId;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *agentId;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *agentName;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *location;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *tag;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *truePhotoDescription;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>) <span class="hljs-built_in">NSInteger</span> approveStatus;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *createTime;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *shootTime;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">//基础图片数据模型协议</span><br><span class="hljs-class"><span class="hljs-keyword">@protocol</span> <span class="hljs-title">FJKPicModelAdapterProtocol</span> &lt;<span class="hljs-title">FJKPreviewBaseModelAdapterProtocol</span>&gt;</span><br><span class="hljs-keyword">@optional</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> * _Nullable url;         <span class="hljs-comment">//图片或者视频的地址</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *_Nullable agentId;      <span class="hljs-comment">//拍摄者ID</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *_Nullable agentName;    <span class="hljs-comment">//拍摄者名称</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *_Nullable placeholderImage;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *_Nullable picId;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *_Nullable location;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *_Nullable tag;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *_Nullable truePhotoDescription;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>) <span class="hljs-built_in">NSInteger</span> approveStatus;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *_Nullable createTime;<br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSString</span> *_Nullable shootTime;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>那么目前我们需要将<code>FJKAlbumPhotoDetailInfoModel</code>中的字段agentId转换到其实现的协议<code>FJKPicModelAdapterProtocol</code>中的picId，那么也就是项目里面使用picId时实际上使用的是<code>FJKAlbumPhotoDetailInfoModel</code>模型的agentId字段，我们只需要在<code>FJKAlbumPhotoDetailInfoModel</code>的implementation里面实现<code>exChangeproperties</code>协议方法，如下：</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">FJKAlbumPhotoDetailInfoModel</span></span><br>- (<span class="hljs-built_in">NSDictionary</span> *_Nullable)exChangeproperties &#123;<br>    <span class="hljs-keyword">return</span> @&#123;<span class="hljs-string">@&quot;agentId&quot;</span>:<span class="hljs-string">@&quot;picId&quot;</span>&#125;;<br>&#125;<br><span class="hljs-keyword">@end</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>这样适配器就能识别需要进行字段映射操作，进行值的变换。特别是需要进行使用的实际数据模型存在协议中不存在字段时，但是对应的是协议中一个字段，那么就可以通过这方式将其映射进去就可以了。</p>
</blockquote>
<hr>
<h3 id="预览视图的扩展"><a href="#预览视图的扩展" class="headerlink" title="预览视图的扩展"></a>预览视图的扩展</h3><p>在适配器里有一个协议<code>FJKPhotoPreviewViewAdapterProtocol</code>,这里将预览的数据处理交由适配器进行处理了，请看协议：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@class</span> FJKPhotoPreviewView;<br><span class="hljs-variable">@protocol</span> FJKPhotoPreviewViewAdapterProtocol &lt;NSObject&gt;<br><span class="hljs-variable">@optional</span><br><span class="hljs-comment">//图片整体数量</span><br>- (NSInteger)<span class="hljs-attribute">numberOfTotalItems</span>:(FJKPhotoPreviewView *_Nullable)photoPreviewView;<br><span class="hljs-comment">//获取当前图片url</span><br><span class="hljs-selector-tag">-</span> (NSURL *_Nullable)<span class="hljs-selector-tag">preview</span>:(FJKPhotoPreviewView *_Nullable)<span class="hljs-selector-tag">photoPreviewView</span> <span class="hljs-selector-tag">imagePreviewViewAtIndex</span>:(NSUInteger)<span class="hljs-selector-tag">index</span>;<br><span class="hljs-comment">//获取标题数组</span><br><span class="hljs-selector-tag">-</span> (NSArray&lt;NSString *&gt; *_Nullable)<span class="hljs-selector-tag">previewCategoryTitleViewTitlts</span>:(JXCategoryTitleView *_Nullable)<span class="hljs-selector-tag">categoryTitleView</span>;<br><br><span class="hljs-comment">//根据indexPath获取当前图片对应的模型数据</span><br><span class="hljs-selector-tag">-</span> (NSObject&lt;FJKPicModelAdapterProtocol&gt; * _Nullable)<span class="hljs-selector-tag">previewModel</span>:(FJKPhotoPreviewView *_Nullable)<span class="hljs-selector-tag">photoPreviewView</span> <span class="hljs-selector-tag">cellItemIndex</span>:(NSIndexPath *_Nonnull)<span class="hljs-selector-tag">indexPath</span>;<br><span class="hljs-comment">//根据整体数组下标获取当前图片对应的模型数据</span><br><span class="hljs-selector-tag">-</span> (NSObject&lt;FJKPicModelAdapterProtocol&gt; * _Nullable)<span class="hljs-selector-tag">preview</span>:(FJKPhotoPreviewView *_Nullable)<span class="hljs-selector-tag">photoPreviewView</span> <span class="hljs-selector-tag">cellItemIndex</span>:(NSInteger)<span class="hljs-selector-tag">currentIndex</span>;<br><br><span class="hljs-comment">//获取当前index位置分类的第一个图片位置</span><br><span class="hljs-selector-tag">-</span> (NSInteger)<span class="hljs-selector-tag">preview</span>:(FJKPhotoPreviewView *_Nullable)<span class="hljs-selector-tag">photoPreviewView</span> <span class="hljs-selector-tag">didClickSelectedItemAtIndex</span>:(NSInteger)<span class="hljs-selector-tag">index</span>;<br><span class="hljs-comment">//获取当前图片所在下标位置</span><br><span class="hljs-selector-tag">-</span> (NSInteger)<span class="hljs-selector-tag">preview</span>:(FJKPhotoPreviewView *_Nullable)<span class="hljs-selector-tag">photoPreviewView</span> <span class="hljs-selector-tag">indexPath</span>:(NSIndexPath *_Nonnull)<span class="hljs-selector-tag">indexPath</span>;<br><span class="hljs-comment">//验证当前下标的完整性</span><br><span class="hljs-selector-tag">-</span> (NSInteger)<span class="hljs-selector-tag">preview</span>:(FJKPhotoPreviewView *_Nullable)<span class="hljs-selector-tag">photoPreviewView</span> <span class="hljs-selector-tag">currentTagIndex</span>:(NSInteger)<span class="hljs-selector-tag">currentIndex</span>;<br><br><span class="hljs-comment">//extend view</span><br><span class="hljs-selector-tag">-</span> (UIView *_Nullable)<span class="hljs-selector-tag">previewExtendView</span>:(FJKPhotoPreviewView *_Nullable)<span class="hljs-selector-tag">photoPreviewView</span>;<br><br>@<span class="hljs-selector-tag">end</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>具体的含义也都有注释，根据注释去填充即可，这里特别注意一个<code>previewExtendView</code>方法，该方法是提供另外的视图view通过适配器的代理实现，也就是适配中还有一个视图代理方法</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><code class="hljs objectivec"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">weak</span>) <span class="hljs-keyword">id</span>&lt;FJKPreviewViewDelegateAdapterProtocol&gt; delegate;<br></code></pre></td></tr></table></figure>

<figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">-</span> (UIView *_Nullable)<span class="hljs-selector-tag">previewExtendView</span>:(FJKPhotoPreviewView *_Nullable)<span class="hljs-selector-tag">photoPreviewView</span> &#123;<br>    <span class="hljs-selector-tag">if</span> (self.delegate &amp;&amp; [self.delegate <span class="hljs-attribute">respondsToSelector</span>:<span class="hljs-variable">@selector</span>(previewExtendView)]) &#123;<br>        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-attr">[self.delegate previewExtendView]</span>;<br>    &#125;<br>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">nil</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>也就是预览中扩展视图的处理是通过适配器<code>FJKPreviewViewDelegateAdapterProtocol</code>代理来实现的，当然这个协议不是一成不变的，可以不断进行扩展的，但是有一点需要注意，为了不污染内部数据环境，所有的扩展视图的操作和事件都需要在适配器外部完成，适配器不会去处理对应的操作和事件信息。到这里关于扩展的使用说明完成。</p>
</blockquote>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>该扩展目前还需要补充的地方有两点，一是多视频的容器替换处理，二是扩展视图的具体处理，这个要根据两端具体的UI设计进行兼容，后期根据需求不断进行版本维护。</li>
<li>在自动解析数据适配方面还需要扩展提供多类型的数据形式解析api。</li>
<li>该组件依赖的三方库包括JXCategoryView、QMUIKit、MJExtension。</li>
<li>再次感谢缪烨大大的前期工作，为后期的开发打下了基础。</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>相册浏览, 预览, QMUI, 适配器</tag>
      </tags>
  </entry>
  <entry>
    <title>dispatch_group同步异常问题</title>
    <url>/2020/04/01/iOS/dispatch_group%E5%BC%95%E8%B5%B7%E7%9A%84%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<p>这次需要在这里梳理一下使用dispatch_group_t引起的同步异常问题，具体问题请看下面:</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-comment">#0 Thread</span><br><span class="hljs-attribute">SIGSEGV</span><br><span class="hljs-attribute">SEGV_ACCERR</span><br><br><span class="hljs-attribute">libdispatch</span>.dylib   _dispatch_group_leave$VARIANT$armv<span class="hljs-number">81</span> + <span class="hljs-number">8</span><br><span class="hljs-attribute">Shikamaru</span>   __<span class="hljs-number">57</span>-[SKMCommunityCircleListViewController loadCircleDataNum]_block_invoke (SKMCommunityCircleListViewController.m:<span class="hljs-number">77</span>)<br><span class="hljs-attribute">Shikamaru</span>   __<span class="hljs-number">43</span>-[SKMCirclePageViewModel requestCircleNum:]_block_invoke (SKMCirclePageViewModel.m:<span class="hljs-number">218</span>)<br><span class="hljs-attribute">Shikamaru</span>   __<span class="hljs-number">48</span>-[YTKNetworkAgent requestDidSucceedWithRequest:]_block_invoke (YTKNetworkAgent.m:<span class="hljs-number">387</span>)<br><span class="hljs-attribute">libdispatch</span>.dylib   __dispatch_call_block_and_release + <span class="hljs-number">24</span><br><span class="hljs-attribute">libdispatch</span>.dylib   __dispatch_client_callout + <span class="hljs-number">16</span><br><span class="hljs-attribute">libdispatch</span>.dylib   __dispatch_main_queue_callback_<span class="hljs-number">4</span>CF$VARIANT$armv<span class="hljs-number">81</span> + <span class="hljs-number">1008</span><br><span class="hljs-attribute">CoreFoundation</span>  ___CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE__ + <span class="hljs-number">12</span><br><span class="hljs-attribute">CoreFoundation</span>  ___CFRunLoopRun + <span class="hljs-number">1924</span><br><span class="hljs-attribute">CoreFoundation</span>  CFRunLoopRunSpecific + <span class="hljs-number">436</span><br><span class="hljs-attribute">GraphicsServices</span>    GSEventRunModal + <span class="hljs-number">104</span><br><span class="hljs-attribute">UIKitCore</span>   UIApplicationMain + <span class="hljs-number">212</span><br><span class="hljs-attribute">Shikamaru</span>   main (main.m:<span class="hljs-number">14</span>)<br><span class="hljs-attribute">libdyld</span>.dylib   _start + <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>

<p>从中可以看出这里出现的异常信号SIGSEGV属于野指针信号，意思是程序无效内存中止信号，一般是表示内存不合法，二是产生的错误信息，也指向 _dispatch_group_leave$VARIANT$armv81 + 8，为了解决这个问题，那么这里进行了如下的流程分析：  </p>
<ul>
<li>检查代码是否实现了dispatch_group_enter和dispatch_group_leave的配对；</li>
<li>存在请求回调block造成了dispatch_group_enter和dispatch_group_leave的配对数量差；</li>
<li>dispatch_group_enter和dispatch_group_leave的配对数量差造成的异常与引言异常的流程对比；</li>
<li>其他使用dispatch_group未发生异常的比较；</li>
<li>group为空造成的异常与引言异常的流程对比；</li>
<li>引起为空的条件和场景，实际测试；</li>
<li>整体项目整改；</li>
</ul>
<hr>
<h3 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h3><h4 id="代码逻辑配对分析"><a href="#代码逻辑配对分析" class="headerlink" title="代码逻辑配对分析"></a>代码逻辑配对分析</h4><p>通过该控制器vc的整体代码逻辑分析，这里是将group对象当作全局对象，然后将每一个请求当作方法进行了拆分，主要是为了方法重用性和独立性，那么也就是说这种方式不太可能出现配对的误差。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><code class="hljs csharp">- (<span class="hljs-keyword">void</span>)loadAllData &#123;<br>    self.circleVM.postNextId = nil;<br>    [<span class="hljs-meta">self resetPlayerAction</span>];<br>    [<span class="hljs-meta">MBProgressHUD showMessage:@<span class="hljs-meta-string">&quot;请稍等...&quot;</span></span>];<br><br>    [<span class="hljs-meta">self loadCircleData</span>];<br><br>    [<span class="hljs-meta">self loadPostDataByArticleId</span>];<br><br>    [<span class="hljs-meta">self loadPostData:YES</span>];<br><br>    <span class="hljs-function">SKMWeakSelf</span><br><span class="hljs-function">    <span class="hljs-title">dispatch_group_notify</span>(<span class="hljs-params">self.<span class="hljs-keyword">group</span>, dispatch_get_main_queue(</span>), ^</span>&#123;<br>        SKMStrongSelf<br>        [<span class="hljs-meta">MBProgressHUD hideHUD</span>];<br>        [<span class="hljs-meta">strongSelf.dataSource removeAllObjects</span>];<br>        <span class="hljs-keyword">if</span> (strongSelf.circleVM.circleList) &#123;<br>            [<span class="hljs-meta">strongSelf.dataSource addObject:strongSelf.circleVM.circleList</span>];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (strongSelf.headerModel) &#123;<br>            [<span class="hljs-meta">strongSelf.dataSource addObject:strongSelf.headerModel</span>];<br>        &#125;<br>        [<span class="hljs-meta">strongSelf.dataSource addObjectsFromArray:strongSelf.circleVM.postArr</span>];<br>        strongSelf.dataArr = strongSelf.dataSource;<br>        [<span class="hljs-meta">strongSelf actionWithRefresh</span>];<br>        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="hljs-number">0.5</span> * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;<br>           [<span class="hljs-meta">strongSelf handleScrollPlay</span>];<br>        &#125;);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-keyword">void</span>)loadCircleData &#123;<br>    dispatch_group_enter(<span class="hljs-keyword">self</span>.group);<br>    <span class="hljs-built_in">SKMWeakSelf</span><br>    [<span class="hljs-keyword">self</span>.circleVM requestCircleFirstPageList:^(<span class="hljs-built_in">SKMCircleInfoListModel</span> *circleList, <span class="hljs-built_in">NSError</span> * _Nonnull error) &#123;<br>        <span class="hljs-built_in">SKMStrongSelf</span><br>        <span class="hljs-keyword">if</span> (strongSelf) &#123;<br>            dispatch_group_leave(strongSelf.group);<br>        &#125;<br>    &#125;];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>剩下的就不一一举出了，看得出来代码逻辑上配对是没有问题的。</p>
<hr>
<h4 id="运行实际的配对分析"><a href="#运行实际的配对分析" class="headerlink" title="运行实际的配对分析"></a>运行实际的配对分析</h4><p>这里的本意是存在请求的block回调没有调用或者多次调用造成了配对误差，这种猜想是根据如下信息资料来的。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSArray</span> *imageURLArray = @[<span class="hljs-string">@&quot;1&quot;</span>, <span class="hljs-string">@&quot;2&quot;</span>, <span class="hljs-string">@&quot;3&quot;</span>, <span class="hljs-string">@&quot;4&quot;</span>];<br>dispatch_group_t group = dispatch_group_create();<br>[imageURLArray enumerateObjectsUsingBlock:^(<span class="hljs-keyword">id</span>  _Nonnull obj, <span class="hljs-built_in">NSUInteger</span> idx, <span class="hljs-built_in">BOOL</span> * _Nonnull stop) &#123;<br>        dispatch_group_enter(group);<br>        [[SDWebImageDownloader sharedDownloader] downloadImageWithURL:[<span class="hljs-built_in">NSURL</span> URLWithString:imageURLArray[idx]] options:SDWebImageDownloaderLowPriority progress:<span class="hljs-literal">nil</span> completed:^(<span class="hljs-built_in">UIImage</span> * _Nullable image, <span class="hljs-built_in">NSData</span> * _Nullable data, <span class="hljs-built_in">NSError</span> * _Nullable error, <span class="hljs-built_in">BOOL</span> finished) &#123;<br>            dispatch_group_leave(group);<br>            <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;idx:%zd&quot;</span>,idx);<br>        &#125;];<br>    &#125;];<br>    dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;<br>        <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;%@&quot;</span>, imageURLArray);<br>    &#125;);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>代码逻辑可以说是很简单：一个图片URL数组。使用SDWebImage多线程进行并发下载，直到所有图片都下载完成进行回调。但是就是这样一段代码居然会偶尔出现崩溃，和项目中其他地方使用到dispatch_group的地方进行过比较，也没发现有什么不同，没办法这时候只有先去看看dispatch_group的源码了,其中有一段是这样的。</p>
</blockquote>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">dispatch<span class="hljs-constructor">_group_leave(<span class="hljs-params">dispatch_group_t</span> <span class="hljs-params">dg</span>)</span> &#123;<br>    dispatch_semaphore_t dsema = (dispatch_semaphore_t)dg;<br>    dispatch<span class="hljs-constructor">_atomic_release_barrier()</span>;<br>    long value = dispatch<span class="hljs-constructor">_atomic_inc2o(<span class="hljs-params">dsema</span>, <span class="hljs-params">dsema_value</span>)</span>;<br>    <span class="hljs-keyword">if</span> (slowpath(value<span class="hljs-operator"> == </span>LONG_MIN)) &#123;<br>        <span class="hljs-constructor">DISPATCH_CLIENT_CRASH(<span class="hljs-string">&quot;Unbalanced call to dispatch_group_leave()&quot;</span>)</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (slowpath(value<span class="hljs-operator"> == </span>dsema-&gt;dsema_orig)) &#123;<br>        (void)<span class="hljs-constructor">_dispatch_group_wake(<span class="hljs-params">dsema</span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>通过源代码我们发现在调用dispatch_group_leave的时候是可能会发生crash的，这段代码的重点就是当这个value值和LONG_MIN相等的时候，这里会发生crash。我们需要关注下LONG_MIN这个数字，LONG_MIN = -LONG_MAX - 1。在dispatch_group_create里面发现了它的踪影：</p>
</blockquote>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">dispatch_group_t<br>dispatch<span class="hljs-constructor">_group_create(<span class="hljs-params">void</span>)</span>&#123;<br>    dispatch_group_t dg = <span class="hljs-constructor">_dispatch_alloc(DISPATCH_VTABLE(<span class="hljs-params">group</span>)</span>,sizeof(<span class="hljs-keyword">struct</span> dispatch_semaphore_s));<br>    <span class="hljs-constructor">_dispatch_semaphore_init(LONG_MAX, <span class="hljs-params">dg</span>)</span>;<br>    return dg;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>这两段代码的结合告诉了我们一个事实：当dq这个信号量加一导致溢出后，dispatch_group_leave就会Crash。通过查阅SDWebImageDownloader.m源码发现：</p>
</blockquote>
<figure class="highlight erlang-repl"><table><tr><td class="code"><pre><code class="hljs erlang-repl">dispatch_barrier_sync(self.barrierQueue, ^&#123;<br>    SDWebImageDownloaderOperation *operation = self.URLOperations[url];<br>    if (!operation) &#123;<br>    operation = createCallback();<br><br>    // !!!!!!!特别注意这行!!!!!!!!!<br>    self.URLOperations[url] = operation;<br><br>    __weak SDWebImageDownloaderOperation *woperation = operation;<br>    operation.completionBlock = ^&#123;<br>      SDWebImageDownloaderOperation *soperation = woperation;<br>      if (!soperation) return;<br>      if (self.URLOperations[url] == soperation) &#123;<br>          [self.URLOperations removeObjectForKey:url];<br>      &#125;;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>SDWebImage的下载器会根据URL做下载任务对应NSOperation映射，也即之前创建的下载回调Block。好，就是这行导致Crash的发生。为什么呢？<br>因为SDWebImage的下载器会根据URL做下载任务对应NSOperation映射，相同的URL会映射到同一个未执行的NSOperation。那么通过代码我当A组图片下载完成后，相同的url 回调是B组内 而不是A组内。此时B的计数为4 。当B 图片下载完后，结束计数为 5 。因为B图片enter 的次数为4 ,leave 的次数为5 ,因此会崩溃！</p>
</blockquote>
<p>下面我们在看代码分析里面使用组的情况是AFN请求，那么会不会AFN请求也发生了类似回调block替换的情况，请看源码。</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><code class="hljs objectivec">- (<span class="hljs-keyword">void</span>)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate<br>            forTask:(<span class="hljs-built_in">NSURLSessionTask</span> *)task<br>&#123;<br>    <span class="hljs-built_in">NSParameterAssert</span>(task);<br>    <span class="hljs-built_in">NSParameterAssert</span>(delegate);<br><br>    [<span class="hljs-keyword">self</span>.lock lock];<br><span class="hljs-comment">//注意这行，进行回调的代理使用了task.taskIdentifier标识</span><br>    <span class="hljs-keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;<br>    [<span class="hljs-keyword">self</span> addNotificationObserverForTask:task];<br>    [<span class="hljs-keyword">self</span>.lock unlock];<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="code"><pre><code class="hljs objectivec"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">NSURLSessionTask</span> : <span class="hljs-title">NSObject</span> &lt;<span class="hljs-title">NSCopying</span>, <span class="hljs-title">NSProgressReporting</span>&gt;</span><br><span class="hljs-comment">//task标识是一个数字型</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">readonly</span>)                 <span class="hljs-built_in">NSUInteger</span>    taskIdentifier;    <span class="hljs-comment">/* an identifier for this task, assigned by and unique to the owning session */</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nullable</span>, <span class="hljs-keyword">readonly</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSURLRequest</span>  *originalRequest;  <span class="hljs-comment">/* may be nil if this is a stream task */</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nullable</span>, <span class="hljs-keyword">readonly</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSURLRequest</span>  *currentRequest;   <span class="hljs-comment">/* may differ from originalRequest due to http server redirection */</span><br><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nullable</span>, <span class="hljs-keyword">readonly</span>, <span class="hljs-keyword">copy</span>) <span class="hljs-built_in">NSURLResponse</span> *response;         <span class="hljs-comment">/* may be nil if no response has been received */</span><br></code></pre></td></tr></table></figure>

<p>也就是说AFN的每个请求都会分配一个数字标识进行回调区分，不可能发生类似SDWebImage类似的情况。那么现在从原理上确认group请求的配对不会发生异常。</p>
<hr>
<h4 id="异常结果对比"><a href="#异常结果对比" class="headerlink" title="异常结果对比"></a>异常结果对比</h4><p>我们再确认一下配对造成的异常与实际异常结果的对比，可以在对应的请求里多进行一次dispatch_group_leave操作，造成crash，看看异常堆栈信息。</p>
<p><img src="/images/iOS/dispatch_group_crash.jpeg"></p>
<blockquote>
<p>看起来是不是与引言里的bug堆栈信息很类似，那就是配对问题，但是前面我们已经确认配对不可能出现问题，但是别急，我们还需要再确认一下异常信号信息。我们发现这里发生crash后抛出的是<code>Thread 1: EXC_BREAKPOINT (code=1, subcode=0x10b4abf20)</code>信息，意思是由断点指令或其它trap指令产生，产生了异常中断信号，不对呀，这与实际结果的野指针信号不匹配呀。所以我们可以进一步确认异常的产生不是因为配对的问题。</p>
</blockquote>
<hr>
<h4 id="与其他使用diaptch-group但未发生异常的对比"><a href="#与其他使用diaptch-group但未发生异常的对比" class="headerlink" title="与其他使用diaptch_group但未发生异常的对比"></a>与其他使用diaptch_group但未发生异常的对比</h4><figure class="highlight pf"><table><tr><td class="code"><pre><code class="hljs pf">dispatch_group_t <span class="hljs-keyword">group</span> = dispatch_group_create();<br>    SKMWeakSelf<br>    dispatch_group_enter(<span class="hljs-keyword">group</span>);<br>    [<span class="hljs-literal">self</span>.viewModel requestSurroundList:<span class="hljs-literal">self</span>.params completeBlock:^(SkmrSurroundInfoRsp *skmrSurroundInfoRsp, NSError * _Nonnull error) &#123;<br>        dispatch_group_leave(<span class="hljs-keyword">group</span>);<br>        if (skmrSurroundInfoRsp) &#123;<br>            SKMStrongSelf<br>            strongSelf.skmrSurroundInfoRsp = skmrSurroundInfoRsp;<br>            [strongSelf.<span class="hljs-built_in">table</span>View reloadData];<br>        &#125;<br>    &#125;];<br>    dispatch_group_enter(<span class="hljs-keyword">group</span>);<br>    [<span class="hljs-literal">self</span>.viewModel requestSearchCommunityList:<span class="hljs-literal">self</span>.params completeBlock:^(SkmrCommunityListRsp *skmrCommunityListRsp, NSError * _Nonnull error) &#123;<br>        dispatch_group_leave(<span class="hljs-keyword">group</span>);<br>        SKMStrongSelf<br>        if (skmrCommunityListRsp) &#123;<br>            strongSelf.skmrCommunityListRsp = skmrCommunityListRsp;<br>            [strongSelf.<span class="hljs-built_in">table</span>View reloadData];<br>        &#125;<br>    &#125;];<br>    dispatch_group_notify(<span class="hljs-keyword">group</span>, dispatch_get_main_queue(), ^&#123;<br>        SKMStrongSelf<br>        [strongSelf judgeNoResultAction];<br>        [strongSelf actionWithRefresh:YES];<br>    &#125;);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>上述是未发生异常的 dispatch_group的使用用法,是不是已经发现问题了，一个是局部定义的group，产生问题的使用的是全局定义的group,多了一个当前self的强引用。那么可以猜想的问题就只剩下一个了那就是self有可能为nil,那么下一步就是进行验证了，执行<code>dispatch_group_leave(nil)</code>。</p>
</blockquote>
<h4 id="验证group为nil的结果对比"><a href="#验证group为nil的结果对比" class="headerlink" title="验证group为nil的结果对比"></a>验证group为nil的结果对比</h4><p><img src="/images/iOS/dispatch_group_nil.jpeg"></p>
<blockquote>
<p>从图中也可以看出发生crash的流程一致，而且发出的异常信号是<code>EXC_BAD_ACCESS</code>，这是一个非法访问已经释放内存区域的异常，与原结论的SIGSEGV信号一致，那么大体上可以确认该异常起因就是这个。</p>
</blockquote>
<hr>
<h4 id="引起为空的条件和场景"><a href="#引起为空的条件和场景" class="headerlink" title="引起为空的条件和场景"></a>引起为空的条件和场景</h4><p>上述告知了我们引起异常的原因是<code>dispatch_group_leave(nil)</code>了，那么为什么group为nil，也就是为什么self为nil，什么况下self为nil了但是block还会执行，加上这是在一个请求方法里面，那么就很容易猜想，控制器vc本身(self)推出释放了，但是请求已经发出，当然block回调还是会继续执行。而且要达到这种效果要么就是用户很快进来，未等请求完成立马退出，但是平常我们测试的网速都是很快的，要想实践出来，当然必须要靠弱网测试了。</p>
<p><img src="/images/iOS/dispatch_group_weaknet.jpeg"></p>
<blockquote>
<p>图中可以看到设置成弱网请求后确实可以达成实现了我们的猜想，也复现了异常产生的场景。那么下一步就是如何解决了。实际上很简单了，那就是在执行<code>dispatch_group_leave(nil)</code>前我们先要做self的空判断，不为空则执行，否则直接跳过，经实际测试，可行，app正常运行。至此，关于异常的处理基本结束。</p>
</blockquote>
<hr>
<h4 id="完整项目收尾"><a href="#完整项目收尾" class="headerlink" title="完整项目收尾"></a>完整项目收尾</h4><p>上面已经分析了异常的分析流程、场景和解决方案，那么为了全面考虑，是否存在漏网之鱼，所以需要整体项目更改，但是这里为什么全局的group和局部定义的group区别这么大，按照原理是方法执行完后，局部变量自动释放，生命周期只在该方法内，所以用弱网环境验证一下，我们执行同样进来控制器vc不等请求完成立马退出，断点，结果如下。</p>
<p><img src="/images/iOS/dispatch_group_aspect.jpeg"></p>
<blockquote>
<p>OK，发现控制器释放了，但是group依然存在，那么说明局部变量应该是block在运行时直接将group复制到了堆内存，其内存管理由block生命周期管理，而前者全局变量group由vc进行了强引用，其生命周期由vc控制，vc释放了，group自然也销毁了。所以两者才会存在同一场景上造成结果的不同。</p>
</blockquote>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>dispatch_group_enter和dispatch_group_leave的配对必须配对。</li>
<li>注意使用dispatch_group时第三方库的影响。</li>
<li>注意group生命周期的管理，特别是弱网环境下的影响。</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>dispatch_group, 异常, 多线程, 同步</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程同步</title>
    <url>/2020/04/01/iOS/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>在进行项目开发时经常会遇到这样一个场景：当多个请求完成时，最后执行某个业务逻辑。一看上去这就是一个多线程控制同步的问题，常见的解决方案有三种。</p>
<ul>
<li>每个请求定义一个变量，然后在每个请求执行完后的block里执行最后执行业务逻辑的方法，方法里必然有着这几个变量的真判断。</li>
<li>使用队列NSOperationQueue控制多线程同步。</li>
<li>使用信号量dispatch_semaphore_t控制多线程同步。</li>
<li>使用进程同步dispatch_group_t控制多线程同步。</li>
</ul>
<hr>
<h3 id="比较及实现方式"><a href="#比较及实现方式" class="headerlink" title="比较及实现方式"></a>比较及实现方式</h3><ul>
<li><p> 第一种看上去很粗浅，就是每次请求就去判断一次各个变量，都通过了表示请求完成了，然后执行最后的业务逻辑。当然这种最好写，但是会加大内存开销和业务复杂度，一方面是有几个请求就得定义几个变量，程序运行时需要进行内存分配，另外还要维护每个变量的真假业务逻辑，如果存在刷新之类的操作更是如此，更有甚者，如果是几十上百个请求，难道要定义几十上百个变量，所以对于简单的多线程请求，稍微多一些或者复杂一些的不建议使用。不过，现在这种方式一般见不到。</p>
</li>
<li><p>第二种队列NSOperationQueue面向对象方式，多用于请求之间存在依赖关系，如果不存在依赖关于请求的完成无法控制，所以不存在依赖则这种方式一般不建议使用。</p>
</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><code class="hljs objectivec"><span class="hljs-built_in">NSBlockOperation</span> *operation_1 = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;1&quot;</span>);<br>[<span class="hljs-keyword">self</span> loadUserFriendsData];<br>&#125;];<br><span class="hljs-built_in">NSBlockOperation</span> *operation_2 = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;2&quot;</span>);<br>[<span class="hljs-keyword">self</span> loadBalaceData];<br>&#125;];<br><span class="hljs-built_in">NSBlockOperation</span> *operation_3 = [<span class="hljs-built_in">NSBlockOperation</span> blockOperationWithBlock:^&#123;<br><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@&quot;3&quot;</span>);<br>[<span class="hljs-keyword">self</span> loadUserData];<br>&#125;];<br><span class="hljs-comment">//设置依赖关系</span><br>[operation_2 addDependency:operation_3];<br>[operation_1 addDependency:operation_2];<br><span class="hljs-comment">//创建队列并添加任务 （这里要设置No）</span><br><span class="hljs-built_in">NSOperationQueue</span> *queue = [[<span class="hljs-built_in">NSOperationQueue</span> alloc]init]; [queue addOperations:@[operation_3,operation_2,operation_1] waitUntilFinished:<span class="hljs-literal">NO</span>];<br><span class="hljs-comment">//注意这里一定要是No,不然会阻塞线程</span><br></code></pre></td></tr></table></figure>

<ul>
<li> 第三种使用信号量dispatch_semaphore_t和使用dispatch_group_t有异曲同工之妙，所以这里直接上代码，怎么使用。</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//创建信号</span><br>dispatch_semaphore_t sema = dispatch<span class="hljs-constructor">_semaphore_create(0)</span>;<br><span class="hljs-comment">//发射信号</span><br>dispatch<span class="hljs-constructor">_semaphore_signal(<span class="hljs-params">sema</span>)</span>;<br><span class="hljs-comment">//等待信号</span><br>dispatch<span class="hljs-constructor">_semaphore_wait(<span class="hljs-params">sema</span>, DISPATCH_TIME_FOREVER)</span>;<br></code></pre></td></tr></table></figure>

<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">(void)request2&#123;<br><span class="hljs-regexp">//</span>创建信号量并设置计数默认为<span class="hljs-number">0</span><br>dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="hljs-number">0</span>);<br>NSDictionary * para ;<span class="hljs-regexp">//</span>参数 具体部分我就不暴露了<br>[WJFCollection postWithUrlString:@<span class="hljs-string">&quot;url&quot;</span> Parameter:para success:^(id responseObject) &#123;<br><span class="hljs-regexp">//</span>只要在这里发送信号<br>dispatch_semaphore_signal(semaphore);<br>&#125; failure:^(NSError *error) &#123;<br><span class="hljs-regexp">//</span>只要在这里发送信号<br>dispatch_semaphore_signal(semaphore);<br>NSLog(@<span class="hljs-string">&quot;%@&quot;</span>,error);<br>&#125;];<br><span class="hljs-regexp">//</span>若计数为<span class="hljs-number">0</span>则一直等待<br>dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li> 第四种使用dispatch_group_t，使用方式如下</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">dispatch_group_t group = dispatch<span class="hljs-constructor">_group_create()</span>;<br>dispatch<span class="hljs-constructor">_group_async(<span class="hljs-params">group</span>, <span class="hljs-params">dispatch_get_global_queue</span>(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</span>, ^&#123;<br><span class="hljs-literal">[<span class="hljs-identifier">self</span> <span class="hljs-identifier">requestData</span>]</span>;<br>&#125;) ;<br>dispatch<span class="hljs-constructor">_group_async(<span class="hljs-params">group</span>, <span class="hljs-params">dispatch_get_global_queue</span>(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</span>, ^&#123;<br><span class="hljs-literal">[<span class="hljs-identifier">self</span> <span class="hljs-identifier">requestData</span>]</span>;<br>&#125;) ;<br>dispatch<span class="hljs-constructor">_group_async(<span class="hljs-params">group</span>, <span class="hljs-params">dispatch_get_global_queue</span>(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</span>, ^&#123;<br><span class="hljs-literal">[<span class="hljs-identifier">self</span> <span class="hljs-identifier">requestData</span>]</span>;<br>&#125;) ;<br>dispatch<span class="hljs-constructor">_group_notify(<span class="hljs-params">group</span>, <span class="hljs-params">dispatch_get_main_queue</span>()</span>, ^&#123;<br><span class="hljs-comment">//展示页面</span><br><span class="hljs-literal">[<span class="hljs-identifier">self</span> <span class="hljs-identifier">showUserView</span>]</span>;<br>&#125;);<br></code></pre></td></tr></table></figure>

<figure class="highlight lasso"><table><tr><td class="code"><pre><code class="hljs lasso">- (<span class="hljs-literal">void</span>)requestData &#123;<br>    dispatch_group_enter(<span class="hljs-built_in">self</span>.<span class="hljs-keyword">group</span>);<br>    WeakSelf<br>    <span class="hljs-meta">[</span><span class="hljs-built_in">self</span>.VMModel request:^(id model, NSError * _Nonnull error) &#123;<br>        StrongSelf<br>        <span class="hljs-keyword">if</span> (strongSelf) &#123;<br>            dispatch_group_leave(strongSelf.<span class="hljs-keyword">group</span>);<br>        &#125;<br>    &#125;<span class="hljs-meta">]</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p> dispatch_semaphore和dispatch_group在使用方式上大同小异，但是dispatch_semaphore相对而言更涉及到底层，越底层使用起来越灵活，自定义程度越高，但是使用起来就会越复杂，而dispatch_group是在信号量dispatch_semaphore_t基础上进行的一层封装，所以使用起来方便一些。从使用对象来说，dispatch_group更加针对的是任务、进程而非线程，所以整体性处理起来更快捷。关于两者的层级请看dispatch_group_leave的源码使用。</p>
</blockquote>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">void dispatch<span class="hljs-constructor">_group_leave(<span class="hljs-params">dispatch_group_t</span> <span class="hljs-params">dg</span>)</span><br>&#123;<br>    dispatch_semaphore_t dsema = (dispatch_semaphore_t)dg;<br>    dispatch<span class="hljs-constructor">_atomic_release_barrier()</span>;<br>    long value = dispatch<span class="hljs-constructor">_atomic_inc2o(<span class="hljs-params">dsema</span>, <span class="hljs-params">dsema_value</span>)</span>;<span class="hljs-comment">//dsema_value原子性加1</span><br>    <span class="hljs-keyword">if</span> (slowpath(value<span class="hljs-operator"> == </span>LONG_MIN)) &#123;<span class="hljs-comment">//内存溢出，由于dispatch_group_leave在dispatch_group_enter之前调用</span><br>        <span class="hljs-constructor">DISPATCH_CLIENT_CRASH(<span class="hljs-string">&quot;Unbalanced call to dispatch_group_leave()&quot;</span>)</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (slowpath(value<span class="hljs-operator"> == </span>dsema-&gt;dsema_orig)) &#123;<span class="hljs-comment">//表示所有任务已经完成，唤醒group</span><br>        (void)<span class="hljs-constructor">_dispatch_group_wake(<span class="hljs-params">dsema</span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>线程同步, NSOperation, dispatch_semaphore_t, dispatch_group_t, 多线程, 同步</tag>
      </tags>
  </entry>
  <entry>
    <title>让 Tapd 的源码关联功能支持 Gitee 平台</title>
    <url>/2019/09/14/%E5%B7%A5%E5%85%B7/gitee-and-tapd/</url>
    <content><![CDATA[<p>Tapd 是腾讯提供的越来越完善的项目管理工具，Gitee 是国内相对比较稳的代码托管平台。本文记录了让 Tapd 的源码关联功能支持 Gitee 平台的方法，及摸索过程中遇到的问题的解决步骤。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>想要使用 Tapd + Gitee 的组合来管理业余项目，但 Tapd 目前官方支持的代码托管平台只有 Gitlab、GitHub 和腾讯工蜂，并不能直接支持 Gitee，直觉上 Gitee 是基于 Gitlab 开发的，所以尝试在 Tapd 里开启了 Gitlab 服务，然后直接将 webhook 地址配置到 Gitee 项目里，却并不能生效。</p>
<h2 id="求索"><a href="#求索" class="headerlink" title="求索"></a>求索</h2><p>这种问题我应该肯定不是第一个遇到，于是在 Tapd 的论坛里搜索 Gitee 关键字，果然在帖子 <a href="https://www.tapd.cn/forum/view/67001">https://www.tapd.cn/forum/view/67001</a> 里找到了方案。</p>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>方案的原理简单来说就是 Gitee 在触发 webhook 时，向目标网址发起的请求和 GitLab 很雷同，只是有个别 Header 的名字不一样，但缺失特定的 Header 信息后无法正常触发 Tapd 的源码关联，所以可以通过 Nginx 反向代理来将缺失的 Header 补全，然后将请求转发给 Tapd 即可。</p>
<h3 id="方案示意图"><a href="#方案示意图" class="headerlink" title="方案示意图"></a>方案示意图</h3><p><img src="/images/posts/tools/webhook-gitee.png"></p>
<p>对比直接支持的 Gitlab 的示意：</p>
<p><img src="/images/posts/tools/webhook-gitlab.png"></p>
<p>所以前提条件是你有一个可以在公网访问到的 Nginx 服务器，且可以自己修改配置。</p>
<p>网友介绍方案及原理的 GitHub 仓库：<a href="https://github.com/notzheng/Tapd-Git-Hooks">https://github.com/notzheng/Tapd-Git-Hooks</a></p>
<h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><ol>
<li><p>在 Tapd 项目里开启 Gitlab 服务；</p>
</li>
<li><p>在你可用的公网 Nginx 服务器的配置文件里添加一段配置：</p>
 <figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>  <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>  <span class="hljs-attribute">server_name</span> tapdhooks.yourdomain.com;<br>  <span class="hljs-attribute">location</span> <span class="hljs-regexp">~ ^/(\d+)/([a-z0-9]+)</span> &#123;<br>    <span class="hljs-attribute">proxy_set_header</span> X-Gitlab-Event $http_X_Gitee_Event ;<br>    <span class="hljs-attribute">proxy_set_header</span> X-Gitlab-Token $http_X_Gitee_Token ;<br>    <span class="hljs-attribute">proxy_pass</span> https://hook.tapd.cn ;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>将 tapdhooks.yourdomain.com 解析到该 Nginx 服务器 IP；</p>
</li>
<li><p>将替换过域名的 webhook 链接配置到 Gitee 项目里；</p>
<p> 比如原 webhook 链接：<a href="https://hook.tapd.cn/32198210/adcc961bc533c74a257ef96295812fa7">https://hook.tapd.cn/32198210/adcc961bc533c74a257ef96295812fa7</a></p>
<p> 将 <code>https://hook.tapd.cn</code> 替换成 <code>http://tapdhook.yourdomain.com</code> 得到新的链接</p>
<p> <a href="http://tapdhooks.yourdomain.com/32198210/adcc961bc533c74a257ef96295812fa7">http://tapdhooks.yourdomain.com/32198210/adcc961bc533c74a257ef96295812fa7</a></p>
</li>
</ol>
<p>搞定！</p>
<h3 id="小插曲"><a href="#小插曲" class="headerlink" title="小插曲"></a>小插曲</h3><p>事情就是这么简单，但往往实操的时候不会这么顺利，会有些小插曲，比如我就遇到了。</p>
<p>如上配置之后，我向 Gitee push 代码却发现并没有在 Tapd 看到源码关联，在 Gitee 配置 webhook 的地方 test 了一下，报 502 bad gateway。</p>
<p>把 test 请求在 postman 里构造出来，然后使用 hook.tapd.cn 的原链接，请求是成功的，加上 Nginx 新增的 Header，也没有问题，但换回自己域名的链接就报 502 了。在 Nginx 服务器上将错误日志打印出来：</p>
<blockquote>
<p>2019/09/12 15:51:25 [crit] 24721#24721: *287854 SSL_do_handshake() failed (SSL: error:1411B041:SSL routines:SSL3_GET_NEW_SESSION_TICKET:malloc failure) while SSL handshaking to upstream, client: 28.39.21.123, server: tapdhooks.yourdomain.com, request: “POST /32198210/adcc961bc533c74a257ef96295812fa7 HTTP/1.1”, upstream: “<a href="https://119.29.122.86/32198210/adcc961bc533c74a257ef96295812fa7&quot;">https://119.29.122.86:443/32198210/adcc961bc533c74a257ef96295812fa7&quot;</a>, host: “tapdhooks.yourdomain.com”</p>
</blockquote>
<p>所以是 Nginx 向 <a href="https://hook.tapd.cn/">https://hook.tapd.cn</a> 链接发起请求时，SSL 握手错误了。</p>
<p>在网上搜了一些网友们的帖子后，得出的结论基本是因为客户端与服务端支持的 SSL protocol 版本不一致导致的，用工具查了一下 Tapd 服务器支持的 protocol 版本是 TLSv2，而我 Nginx 服务器的 OpenSSL 版本较低，可能不支持这个，于是先是升级了服务器上的 OpenSSL 的版本，然后通过重新编译升级了 Nginx 的 OpenSSL 版本，之后问题解决。这两步自己维护 Ngninx 服务器的同学应该不在话下，在此不再赘述，以下是我参考的链接：</p>
<ul>
<li>升级服务器 OpenSSL 版本： <a href="https://blog.csdn.net/l1028386804/article/details/53165252">CentOS之——升级openssl为最新版</a></li>
<li>升级 Nginx 的 OpenSSL 版本：<a href="https://my.oschina.net/u/1449160/blog/220415">nginx旧版本openssl升级</a></li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.tapd.cn/forum/view/67001">分享一个让源码关联支持Gogs/Gitee等平台的解决方案</a></li>
<li><a href="https://github.com/notzheng/Tapd-Git-Hooks">Tapd Git Hooks</a></li>
<li><a href="https://my.oschina.net/u/1449160/blog/220415">nginx旧版本openssl升级</a></li>
<li><a href="https://blog.csdn.net/l1028386804/article/details/53165252">CentOS之——升级openssl为最新版</a></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Gitee, webhook, Tapd</tag>
      </tags>
  </entry>
  <entry>
    <title>网络架构设计</title>
    <url>/2019/07/31/iOS/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>一般情况下，我们设计的网络架构面向过程设计，那么设计的方案大多数会出现下面的现象： </p>
<ul>
<li>1.耦合，主要包括缓存、网络状态监听、请求头设置、请求设置、参数处理、请求结果模型解析、成功和失败的回调处理等；</li>
<li>2.糅合了业务，比如登录状态，cookie设置、参数业务处理；</li>
<li>3.灵活性低，更改初始化设置非常麻烦；</li>
<li>4.批量处理或者同步处理存在另外设计；</li>
<li>5.扩展性不强，比如希望在请求接口上做缓存或者签名，也杂糅在设计的网络架构里面；</li>
</ul>
<hr>
<p>那么具体该怎么设计呢，这里是个人见解，不喜勿喷：</p>
<p>1.划分层次，自顶向下，应该是<code>业务处理并发起请求--&gt;场景请求方式处理(批量请求或者同步控制或者不同方式请求等)--&gt;调用底层发起请求--&gt;底层请求结果传递--&gt;场景请求结果处理(动态模型封装或异常error传递)--&gt;业务类获取请求结果对应业务操作</code>，一般大体是这样的流程。</p>
<p>2.划分设计的层次结构，根据上述情况，业务类应该是最外层，属于不可公用部分，应该由不同的项目自身去扩展设计，只需要里面调用同样组件处理即可，这里我们需要考虑的一个是场景设计类，一个底层调用类，后续的组件也主要是以底层设计为主，场景为扩展区间。<br>底层设计属于可替换组件，只做网络请求，具体做哪方面的请求，这里并不需要知道，优点是我们可以更换不同的网络库，而不影响本身业务实现(这里考虑的是网络库的更新换代)。<br>场景设计只是对请求的进一步扩展，增添更多的功能来适应我们业务的需要，但是注意，它不关注具体业务是什么，只做对业务需求的兼容性，就如同网络请求提供了了get/post/put/head/delete等场景，但是具体调用哪一种，是业务本身来决定。</p>
<p>3.设计方式，从项目来看，整个网络请求设计了3层，现在要做的是如何设计这3层之间的数据传递，数据传递要做到解耦，那么我们去考虑的必然是面向对象设计，即在网络请求流向里流转的必然是一个对象。<br>这里又存在一个问题：<code>这个对象应该包含哪些东西？</code><br>根据我的理解，该对象应该实现问题1里面的各个特性，包括：是否需要缓存、是否做网络监听处理、请求头和参数怎么设置、结果模型是什么样的、超时时间等，成功和失败可以用于参数传递，这里可以不参与对象构造。<br>下面又有一个问题：<code>不同的项目去构造该对象模型怎么知道需要哪些东西？或者扩展了对象范围如何不影响原有结构？</code><br>这里就需要用到协议，除了必须的URL、参数等必须的外，加入的扩展协议方法都是可选，并且需要一直提供一个extra另外参数用于扩展<br>同理，返回的响应模型也是一个对象，也有对应的协议。<br>好处是： </p>
<ul>
<li>1.项目根据自己的业务需要去实现对应的协议，构造对象；</li>
<li>2.提供扩展和维护，用于升级；</li>
<li>3.对象可以携带更多的信息。</li>
</ul>
<p>4.场景设计这里忽略，底层设计里面，要将问所说的缓存、网络状态监听等独立出来，可以通过观察订阅模式或者中介者模式来获取对应信息，通过流转的对象项目配置信息来处理，我们需要在底层将可能出现的情况预先设计埋点。</p>
<hr>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS, 日期</tag>
      </tags>
  </entry>
  <entry>
    <title>Cocoapods的组件化私有库</title>
    <url>/2019/07/05/iOS/pod%E7%BB%84%E4%BB%B6%E5%8C%96/</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>随着项目的越来越臃肿，那么需要对项目进行拆分进行模块化设置，而模块化则需要先把公共的部分都提取出来，构建成组件，做到一份组件各个模块共用，但是还需要做到可用可取消，这里就用到了Cocoapods的库导入机制，也是项目模块化的基础—组件化，所以需要做Cocoapods的组件化私有库。</p>
<hr>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li>1.私有spec center repository的创建</li>
<li>2.私有库创建并将组件Spec 索引发布到私有center repository</li>
<li>3.私有库的pod引入</li>
<li>4.私有库的版本升级</li>
<li>5.私有库的源码与二进制码的切换</li>
</ul>
<hr>
<h3 id="私有spec-center-repository的创建"><a href="#私有spec-center-repository的创建" class="headerlink" title="私有spec center repository的创建"></a>私有spec center repository的创建</h3><h4 id="本地创建私有仓库的spec索引"><a href="#本地创建私有仓库的spec索引" class="headerlink" title="本地创建私有仓库的spec索引"></a>本地创建私有仓库的spec索引</h4><p>我们创建spec repository是基于gitlab的,我们在github上创建一个空的仓库，命名为publicSpec，这个仓库是用来存放我们自己所有的私有库的spec文件，就如同官方的<a href="https://github.com/CocoaPods/Specs">https://github.com/CocoaPods/Specs</a>是用来存放所有官方的specs文件一样。<br>现在gitlab上创建一个名为publicSpec的仓库,然后终端执行:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">pod repo add RGPublicSpec https:<span class="hljs-comment">//git.rograndec.com/publicModule/publicSpec.git</span><br></code></pre></td></tr></table></figure>

<p>注意：上面的命令的解释如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">pod repo add repo_name source_url<br></code></pre></td></tr></table></figure>

<blockquote>
<p>其中的 repo_name 是我们要添加的私有repo的名称（这里我们待会填的是: RGPublicSpec），后面是仓库的 gitlab 地址。这里做的其实是创建的工作，也就是在~/.cocoapods/repos目录下添加了一个以你的私有repo为名的文件夹，但是并没有添加spec文件。</p>
</blockquote>
<p>然后你可以到~/.cocoapods/repo文件中去看是否有RGPublicSpec文件。如果有那么我们已经在本地得到我们自己的私有仓库 RGPublicSpec ，这是一个空的仓库,也是接下来需要用到的私有中央仓库。</p>
<h4 id="clone仓库到本地"><a href="#clone仓库到本地" class="headerlink" title="clone仓库到本地"></a>clone仓库到本地</h4><p>将仓库 clone 到本地，这里有多种操作方式，可以选择你喜欢的一种，这边选择使用命令行。首先需要切换到你想在本地存储的目录，然后再 clone ，在用户的根目录上：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">cd ~<br>git clone https:<span class="hljs-comment">//git.rograndec.com/publicModule/publicSpec.git</span><br></code></pre></td></tr></table></figure>

<p>完成后，我们进入到 ~/publicSpec 目录,这时候你看到是LICENSE和README.md文件，这里还有一个隐藏的 .git 文件，后续我们的所有文件都在这个目录下进行。</p>
<p>README.md</p>
<blockquote>
<p>使用 github 的人应该都熟悉这个文件，它使一个成功的 github 仓库必不可少的一部分，使用 markdown 对仓库进行详细说明。</p>
</blockquote>
<p>LICENSE</p>
<blockquote>
<p>CocoaPods 强制要求所有的 Pods 依赖库都必须有 license 文件，否则验证不会通过。 license 文件有很多中，详情可以参考 tldrlegal。前面我们已经选择创建了一个 MIT 类型的 license。</p>
</blockquote>
<p>注意：打开隐藏目录，可以使用命令：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//打开隐藏的命令:</span><br>defaults write com.apple.finder AppleShowAllFiles -bool <span class="hljs-literal">true</span><br><br><span class="hljs-comment">//关闭隐藏的命令:</span><br>defaults write com.apple.finder AppleShowAllFiles -bool <span class="hljs-literal">false</span><br><span class="hljs-string">``</span><span class="hljs-string">`  </span><br><span class="hljs-string"></span><br><span class="hljs-string">然后我们可以在gitlab也能看到对应的仓库  </span><br><span class="hljs-string"></span><br><span class="hljs-string">![](/images/iOS/center_repository.jpeg)</span><br><span class="hljs-string"></span><br><span class="hljs-string">至此，整个spec center repository的创建就算全部完成了。</span><br><span class="hljs-string"></span><br><span class="hljs-string">-------</span><br><span class="hljs-string"></span><br><span class="hljs-string">### 私有库创建并将组件Spec 索引加入私有center repository  </span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">#### 1.首先创建一个文件夹SepcTest。  </span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">![](/images/iOS/component_dir.jpeg)  </span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">#### 2.终端进入当前文件夹SepcTest，执行下列命令：  </span><br><span class="hljs-string"></span><br><span class="hljs-string">![](/images/iOS/component_create.jpeg)  </span><br><span class="hljs-string"></span><br><span class="hljs-string">打开的项目结构如下：  </span><br><span class="hljs-string"></span><br><span class="hljs-string">![](/images/iOS/component_replace.jpeg)  </span><br><span class="hljs-string"></span><br><span class="hljs-string">这里注意，在第1步不能直接create group形式加入文件，这样加入的文件在文件夹根目录下，而文件源码需要加入`</span>SpecTest——&gt;SpectTestView——&gt;SpectTestView——&gt;Classes<span class="hljs-string">`路径下,最后是需要执行pod update将开发模式的源码引用到项目中，执行完后会发现加入的组件代码已经加进去了，如下图：  </span><br><span class="hljs-string"></span><br><span class="hljs-string">![](/images/iOS/component_originalcode.jpeg)  </span><br><span class="hljs-string"></span><br><span class="hljs-string">#### 3.编辑podspec文件信息  </span><br><span class="hljs-string"></span><br><span class="hljs-string">![](/images/iOS/component_podspec.jpeg)</span><br><span class="hljs-string"></span><br><span class="hljs-string">&gt; 接下来讲解一下每行代码的含义  </span><br><span class="hljs-string">s.name：名称，pod search 搜索的关键词,注意这里一定要和.podspec的名称一样,否则报错  </span><br><span class="hljs-string">s.version：版本号  </span><br><span class="hljs-string">s.ios.deployment_target:支持的pod最低版本  </span><br><span class="hljs-string">s.summary: 简介  </span><br><span class="hljs-string">s.homepage:项目主页地址  </span><br><span class="hljs-string">s.social_media_url:社交网址,如果你写的是你自己的博客的话,你的podspec发布成功后会@你  </span><br><span class="hljs-string">s.license:许可证  </span><br><span class="hljs-string">s.author:作者  </span><br><span class="hljs-string">s.source:项目的地址  </span><br><span class="hljs-string">s.requires_arc: 是否支持ARC  </span><br><span class="hljs-string">s.source_files:需要包含的源文件  </span><br><span class="hljs-string">s.public_header_files:公开的头文件  </span><br><span class="hljs-string">//其他  </span><br><span class="hljs-string">s.resources: 资源文件  </span><br><span class="hljs-string">s.dependency：依赖库，不能依赖未发布的库，可以写多个依赖库  </span><br><span class="hljs-string">常见的写法：  </span><br><span class="hljs-string">1、dependency:写法  </span><br><span class="hljs-string">`</span><span class="hljs-string">``</span>javascript<br>s.dependency = <span class="hljs-string">&#x27;AFNetworking&#x27;</span> , <span class="hljs-string">&#x27;SDWebImage&#x27;</span><br></code></pre></td></tr></table></figure>
<p>2、source_files: 写法(按照自身的目录结构来，默认是第一种)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;SpectTestView/Classes/**/*&#x27;</span><br><span class="hljs-string">&#x27;SpectTestView/SpectTestView/*.&#123;h,m&#125;&#x27;</span><br><span class="hljs-string">&#x27;SpectTestView/**/*.h&#x27;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c">&#x27;*&#x27;表示匹配所有文件<br>&#x27;*.&#123;h,m&#125;&#x27; 表示匹配所有以.h和.m结尾的文件<br>&#x27;**&#x27; 表示匹配所有子目录<br></code></pre></td></tr></table></figure>
<p>3、source: 常见写法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">s.source = &#123; :<span class="hljs-function"><span class="hljs-params">git</span> =&gt;</span> <span class="hljs-string">&quot;https://git.rograndec.com/publicModule/SpectTestView.git&quot;</span>, :<span class="hljs-function"><span class="hljs-params">commit</span> =&gt;</span> <span class="hljs-string">&quot;68defea&quot;</span> &#125;<br>s.source = &#123; :<span class="hljs-function"><span class="hljs-params">git</span> =&gt;</span> <span class="hljs-string">&quot;https://git.rograndec.com/publicModule/SpectTestView.git&quot;</span>, :<span class="hljs-function"><span class="hljs-params">commit</span> =&gt;</span> <span class="hljs-string">&quot;68defea&quot;</span>, :<span class="hljs-function"><span class="hljs-params">tag</span> =&gt;</span> <span class="hljs-number">1.0</span><span class="hljs-number">.0</span> &#125;<br>s.source = &#123; :<span class="hljs-function"><span class="hljs-params">git</span> =&gt;</span> <span class="hljs-string">&quot;https://git.rograndec.com/publicModule/SpectTestView.git&quot;</span>, :<span class="hljs-function"><span class="hljs-params">tag</span> =&gt;</span> s.version &#125;<br></code></pre></td></tr></table></figure>
<p>commit =&gt; “68defea” 表示将这个Pod版本与Git仓库中某个commit绑定<br>tag =&gt; 1.0.0 表示将这个Pod版本与Git仓库中某个版本的comit绑定<br>tag =&gt; s.version 表示将这个Pod版本与Git仓库中相同版本的comit绑定。</p>
<h4 id="4-上传到git"><a href="#4-上传到git" class="headerlink" title="4.上传到git"></a>4.上传到git</h4><p>进入到当前项目根目录下(包含有.podspec文件),按照下列命令执行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/// 本地验证(详细编译信息与忽略警告)</span><br>pod lib lint SpectTestView.podspec --verbose --allow-warnings<br>git add .<br>git commit -m <span class="hljs-string">&quot;first commit&quot;</span><br>git remote add origin https:<span class="hljs-comment">//git.rograndec.com/publicModule/SpectTestView.git</span><br>git push -u origin master<br></code></pre></td></tr></table></figure>
<p>第一步是本地验证添加的podspec文件和本地组件源码格式，若无需编译信息和忽略警告，则后面可以不加<code>--verbose --allow-warnings</code><br>后面几步就是git的提交步骤了<br>这里注意在最后一步会出现<code>remote: Not Found fatal: repository &#39;https://git.rograndec.com/publicModule/SpectTestView.git/&#39; not found</code>，说明gitlab上没有对应的仓库，那么我们需要先到gitlab上去创建一个仓库(必须命名为SpectTestView对应)，选择public权限(便于公共使用),创建后如图所示：</p>
<p><img src="/images/iOS/component_testSpecgit.jpeg"></p>
<p>然后重新命令行执行<code>git push -u origin master</code>就会将组件项目上传到创建的仓库里,如图所示：</p>
<p><img src="/images/iOS/component_uploadExample.jpeg"></p>
<p>到这里我们已经完成私有组件库的创建上传。</p>
<h4 id="5-将spec索引发布到私有center-repository。"><a href="#5-将spec索引发布到私有center-repository。" class="headerlink" title="5.将spec索引发布到私有center repository。"></a>5.将spec索引发布到私有center repository。</h4><p>1.设置版本号，仍然在当前项目根目录下执行命令行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">git tag <span class="hljs-number">0.1</span><span class="hljs-number">.0</span> -m <span class="hljs-string">&quot;0.1.0版本&quot;</span><br>git push --tags<br></code></pre></td></tr></table></figure>
<p>2.验证文件， 本地与网络验证</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/// 1. 本地验证(详细编译信息与忽略警告)</span><br>pod lib lint --verbose --allow-warnings<br><span class="hljs-comment">/// 2. 网络验证</span><br>pod spec lint<br></code></pre></td></tr></table></figure>
<p>若上述命令都出现<code>SpectTestView passed validation</code>则表示验证通过则私有库版本创建成功完成，否则则需要重新修改配置或者代码，并且重点注意任何修改都必须进行版本升级，否则会出现同版本的指向不明给后面的引用带来问题。</p>
<p>3.将spec索引发布到私有center repository<br>命令行执行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">pod repo push RGPublicSpec SpectTestView.podspec<br></code></pre></td></tr></table></figure>
<p>完成后可以到gitlab上私有center repository看看出现下列图示表示发布私有仓库成功。</p>
<p><img src="/images/iOS/component_addResponsitory.jpeg">  </p>
<hr>
<h3 id="私有库的pod引入"><a href="#私有库的pod引入" class="headerlink" title="私有库的pod引入"></a>私有库的pod引入</h3><p><img src="/images/iOS/component_podimport.jpeg"></p>
<p>要将我们创建的私有库的源地址和Cocoapods本身的中央仓库源地址都加上，因为以前不写默认用Cocoapods本身的中央仓库源地址，但是加上我们自己的私有中央仓库有可能会覆盖掉默认的，导致引用的其他三方库出现找不到的情况。最后pod update一下，得到下面的图示：</p>
<p><img src="/images/iOS/component_podOver.jpeg"></p>
<p>这里我们能看到私有库SpectTestView pod导入进来了，而且pod模式下会自动将其依赖库AFN也引入了，极其方便。这就是前面讲的为什么需要做剔除依赖的二进制，因为依赖在pod引入私有库的时候会自动引入，保证了代码的纯粹性和依赖库的解耦。</p>
<hr>
<h3 id="私有库的版本升级"><a href="#私有库的版本升级" class="headerlink" title="私有库的版本升级"></a>私有库的版本升级</h3><p>1.还原私有库的pod开发模式，主要是为了测试本地修改，如下图</p>
<p><img src="/images/iOS/component_poddev.jpeg"></p>
<p>然后通过命令行cd进入私有库项目根目录，然后<code>cd Example</code>进入存在podfile文件的目录下执行<code>pod update</code>这样就还原了开发模式。</p>
<p>2.更改升级需要进行的源代码，并且修改podspec文件描述及版本</p>
<p><img src="/images/iOS/component_versionupdate.jpeg"></p>
<p>3.退出到根目录，再执行上传git操作及将版本spec索引发布到私有center repository过程即可</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/// 本地验证(详细编译信息与忽略警告)</span><br>pod lib lint SpectTestView.podspec --verbose --allow-warnings<br>git add .<br>git commit -m <span class="hljs-string">&quot;修改版本&quot;</span><br>git push<br>git tag <span class="hljs-number">0.1</span><span class="hljs-number">.1</span> -m <span class="hljs-string">&quot;0.1.1版本&quot;</span><br>git push --tags<br>pod repo push RGPublicSpec SpectTestView.podspec<br></code></pre></td></tr></table></figure>
<p>最后得到私有仓库spec索引更新</p>
<p><img src="/images/iOS/component_versionspec.jpeg"></p>
<p>4.在使用该私有库的项目中<code>pod update --verbose --no-repo-update</code>即可更新到最新版本，如果发现到最新版本，那可能是Cocoapods版本较低，需要升级。</p>
<hr>
<h3 id="私有库的源码与二进制码的切换"><a href="#私有库的源码与二进制码的切换" class="headerlink" title="私有库的源码与二进制码的切换"></a>私有库的源码与二进制码的切换</h3><p>1.切换目的<br>项目编译较慢，开发的时候为了加快效率当然需要以二进制码来进行，但是偶尔出现私有库版本需要做调试的情况或者说逻辑检测，这时候我们希望能看到源码，但是我们又不可能来来回回去替换文件，不仅操作不方便，而且极易造成文件缺失等问题，这里希望有一种方案能够通过pod直接来进行源码和二进制码的切换。</p>
<p>2.在当前私有库根目录下使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">pod packge SpectTestView.podspec --force<br></code></pre></td></tr></table></figure>
<p>进行二进制打包,最后效果如下</p>
<p><img src="/images/iOS/component_package.jpeg"></p>
<p><img src="/images/iOS/component_packagedir.jpeg"></p>
<p><img src="/images/iOS/component_packageresult.jpeg"></p>
<p>最后需要的就是该framework文件</p>
<p>3.将打包生成的framework文件放入源码所在同一位置，这里我定义framework摆放位置<code>SpectTestView/Products/SpectTestView.framework</code>，注意这里的Products文件夹与<code>SpectTestView/Classes/**/*</code>中的classes位于同一层级,同时删除打包生成的根目录下文件夹<code>SpectTestView-0.1.1</code>，因为该文件已经没有作用了。</p>
<p>4.改写podSpec文件，定义的framework路径要与podSpec文件中设置的路径一致，同时加入IS_SOURCE和SpectTestView两个参数来判断切换。<br>当然源码和framwork代表的文件意义不一样，如图所示：</p>
<p><img src="/images/iOS/component_vendor.jpeg"></p>
<p>说明：<br>1.因为存在修改，所以一定要升级。<br>2.ENV表示环境参数判断，后面会告知如何使用，这里意思是IS_SOURCE或者SpectTestView参数不为空的情况下，加载s.source_files的源码，否则加载s.vendored_frameworks的二进制码内容。为什么这里需要有两个参数判断，原因是前者是所有私有库统一切换的判断参数，后者是单独对应的私有库切换的判断参数。</p>
<p>5.升级版本操作，上传gitlab和发布spec(过程请看私有库的版本升级篇)</p>
<p>6.源码和二进制码的pod处理</p>
<p>首先在podfile文件中正常引入配置</p>
<p><img src="/images/iOS/component_podimport.jpeg"></p>
<p>然后在podfile对应的根目录下执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">IS_SOURCE=<span class="hljs-number">1</span> pod update<br></code></pre></td></tr></table></figure>
<p>这一句在执行pod更新时将IS_SOURCE加入环境变量参数，按照第4步的说明应该是引入源码了，我们看看最终结果:</p>
<p><img src="/images/iOS/component_podsource.jpeg"></p>
<p>可以看到与我们设计的基本是一致的，那么同理执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">SpectTestView=<span class="hljs-number">1</span> pod update<br></code></pre></td></tr></table></figure>
<p>引入的也是源码</p>
<p>最后我们直接执行，不带上任何环境变量,按照设计应该载入的是打包的二进制码</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">pod update<br></code></pre></td></tr></table></figure>
<p>得到的结果视图为：</p>
<p><img src="/images/iOS/component_podsourcefail.jpeg"></p>
<p>出现这种原因是因为cocoapods的缓存，所以我们这里需要暴力处理，清除cocoapods的缓存，重新pod   update执行</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">sudo rm -fr ~<span class="hljs-regexp">/.cocoapods/</span>repos/RGPublicSpec/SpectTestView<br>pod cache clean SpectTestView<br></code></pre></td></tr></table></figure>
<p>最后的切换结果如图所示:</p>
<p><img src="/images/iOS/component_podbinary.jpeg"></p>
<p>至此，关于私有库源码与二进制的切换则说明完成。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS, 组件化</tag>
      </tags>
  </entry>
  <entry>
    <title>编译优化</title>
    <url>/2019/06/26/iOS/%E7%BC%96%E8%AF%91%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>引言<br>随着模块和代码量的增加，编译的效率会越来越低，有的多达几个小时，这时候需要考虑做编译优化：<br>1.查找耗时文件和代码<br>2.针对性文件和代码做优化(代码简化，减少宏定义，库二进制化等)<br>3.项目结构组件化和模块化，拆分功能减少编译量(这个属于组件化的范畴，这里忽略)  </p>
<p>查找和排序<br>这里需要脚本处理来获取编译数据日志 :  </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">#!<span class="hljs-regexp">/bin/</span>sh<br>myFile=<span class="hljs-string">&quot;./allFilesTimeCompile.txt&quot;</span><br>myFile2=<span class="hljs-string">&quot;./timeCompileSorted.txt&quot;</span><br><span class="hljs-keyword">if</span> [ ! -f <span class="hljs-string">&quot;$myFile&quot;</span> ]; then<br>    touch <span class="hljs-string">&quot;$myFile&quot;</span><br><span class="hljs-keyword">else</span><br>    rm -rf <span class="hljs-string">&quot;$myFile&quot;</span><br>fi<br><span class="hljs-keyword">if</span> [ ! -f <span class="hljs-string">&quot;$myFile2&quot;</span> ]; then<br>    touch <span class="hljs-string">&quot;$myFile2&quot;</span><br><span class="hljs-keyword">else</span><br>rm -rf <span class="hljs-string">&quot;$myFile2&quot;</span><br>fi<br>xcodebuild -workspace projectName.xcworkspace -scheme targetName -archivePath ~<span class="hljs-regexp">/Desktop/</span>targetName archive | xcpretty | gnomon <span class="hljs-number">1</span>&gt; <span class="hljs-string">&quot;$myFile&quot;</span> &amp;&amp;<br>sort -r <span class="hljs-string">&quot;$myFile&quot;</span> | head -n <span class="hljs-number">10000</span> <span class="hljs-number">1</span>&gt; <span class="hljs-string">&quot;$myFile2&quot;</span><br>wait<br></code></pre></td></tr></table></figure>
<p>查找耗时文件和代码<br>原理<br>将编译日志按行有序输出到allFilesTimeCompile.txt文件中，然后根据每行输出时间的间隔长短进行排序，将时间长的靠前10000行输出到timeCompileSorted.txt文件中。  </p>
<p>解释  </p>
<ul>
<li>xcodebuild是编译命令，这里”xcodebuild -workspace projectName.xcworkspace -scheme targetName -archivePath <del>/Desktop/targetName archive”表示编译打包的archive文件路径在”</del>/Desktop/targetName.archive”。</li>
<li>xcpretty是美化编译日志的，表示按行输出日志。</li>
<li>gnomon是标记出另外一个命令执行消耗的时间信息,这里用于每个文件编译的时间信息统计。</li>
<li>sort排序命令行，这里使用管道输出将allFilesTimeCompile.txt文件的前10000行写入timeCompileSorted.txt文件中。</li>
</ul>
<p>使用<br>将上面的脚本放入一个.sh文件中（里面的projectName和targetName替换成自己的项目名和target名，archive的路径也可以按照自己的需求来），然后将该.sh文件放入项目根目录下，在通过控制台进入该项目根目录执行该.sh文件等待即可。  </p>
<p>优化策略<br>代码简化<br>顾名思义就是进行代码冗余简化，重复代码进行合并或者是将冗余逻辑进行优化精简代码量，原理就是减少编译器的编译代码数量，从表层上降低编译器的编译时间。  </p>
<p>减少宏定义<br>主要是将大量的宏定义更改为静态全局变量，这样将本身的<code>预编译时间</code>延后到了<code>运行期</code>,这样以来达到精简编译时间的目的，当然这种方式优化有限，不过精益求精总是好的。  </p>
<p>库的二进制化<br>我们在项目中会大量使用一些第三方库或者自定义的私有库，这时候如果引入的是源码，当然会需要编译器的编译处理，部分第三方库在编译器里会占用大量编译时间。  </p>
<p><code>疑问一：二进制化指什么意思？</code><br>简单来说就是打包成framework或者.a文件，即是静态库，（动态库是Apple禁止的，但是iOS10以上放开限制，允许使用动态库进行主从app的共用）因为静态库里面已经是编译好的二进制码，所以编译时会直接跳过，这样就减少了编译时间。  </p>
<p><code>疑问二：二进制化后如果有依赖是否也在里面？要是其他静态库也包含了同样的依赖会不会编译冲突?</code><br>如果打包的是.a静态库，那么依赖肯定是在里面的，如果其他静态库也用到了同样的依赖，编译器会报重复编译冲突错误。所以一般都是不建议打包.a静态库的，除非本身不包含其他的依赖库。  </p>
<p>解决方案：打包成不包含依赖的framework静态库。  </p>
<p><code>二进制化方案</code><br>网上有很多方案，大体分为三种:  </p>
<ul>
<li>脚本，这种最常见，网上例子，可以去搜寻下，这里不多说了;  </li>
<li>Aggregate文件,这种方案与上面那种类似，不过是单独用一个Aggregate独立出来了，路径<code>File——&gt;New——&gt;Target——&gt;Cross-platform——&gt;Aggregate</code>，然后在Aggregate的target选中<code>Build Phases——&gt;+ New Run Script Phase——&gt;shell</code>加入脚本。执行脚本的流程即可;  </li>
<li>使用Cocoapods的package命令行，package命令需要先通过命令行安装<a href="https://github.com/CocoaPods/cocoapods-packager">cocoapods-packager</a>，在库项目的根目录下执行<code>pod package xxx.podspec --force</code>，当然这里有个注意事项，存在图片资源等bundle的需要从framework中单独提出来，放在framework中与代码文件夹并列的位置，否则库本身的资源文件无法读取出来。这里介绍的package方案比较全面，可以研究下<a href="https://www.jianshu.com/p/611049483be4">关于使用CocoaPods的package打包Framework以及使用注意</a>。</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS, 编译优化</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS10以上新机首次安装app，请求网络权限</title>
    <url>/2019/05/30/iOS/%E7%BD%91%E7%BB%9C%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<p>###引言<br>iOS10以上iphone在使用app时会出现请求网络权限的提示，这功能只满足下列条件时才会出现：<br>1.国行版本的iPhone手机<br>2.系统版本在iOS10及以上<br>3.首次安装一个App时,App只要进行网络请求,就会触发  </p>
<p>###提示示意图<br><img src="/images/network/networkPermission.png"><br>根据图中可以看出现有三个选项及含义分别是：<br>1.无线局域网与蜂窝移动网络，含义是该app即允许WLAN(理解成WiFi就行了)也允许4G/3G/2G等蜂窝网络访问；<br>2.仅限无线局域网，含义就是只能在WiFi环境下使用，用4G/3G等就会无网络；<br>3.不允许，顾名思义，完全离线，没办法网络使用。  </p>
<p>###可能出现问题的场景<br>1.新用户第一次打开app时已经开启了网络权限，但是仍然会出现<em>首页</em>空白无数据或者显示不正常的情况，原因是网络请求发生在允许网络权限之前，那时app仍然处于无网络权限状态，导致获取数据失败了。<br>2.用户不是第一次打开情况下，这种情况下一般是不会再次弹出提示的，这时候就要小心了。  </p>
<blockquote>
<p>第一次打开时用户直接关闭了，这种情况下app应用依然是没有网络权限的，但是也不会提示，当时无法访问数据，用户只会认为app应用<strong>有bug</strong>；<br>第一次如果选择了“不允许”，基本上同上；<br>第一次如果选择了“仅限无线局域网”，那基本上在WiFi情况下正常，但是如果当时用户用的是蜂窝网络，那么悲剧了，依然是<strong>有bug</strong>。  </p>
</blockquote>
<p>###解决思路<br>####第1中场景<br>办法很多，也是网上提到的最多的处理方式，大体上的解决方案有下面几种：  </p>
<blockquote>
<p>在<em>首页</em>中加入空白按钮，这里用的比较多的是OC版<a href="https://github.com/dzenbot/DZNEmptyDataSet">DZNEmptyDataSet</a>和swift版<a href="https://github.com/Xiaoye220/EmptyDataSet-Swift">EmptyDataSet-Swift</a>，这样在无数据显示的时候出现一个空白按钮提示，引导用户重新去刷新网络数据。  </p>
</blockquote>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS, 网络权限</tag>
      </tags>
  </entry>
  <entry>
    <title>记一个折磨了我一天半的 Bug</title>
    <url>/2019/05/25/Java/a-stupid-bug/</url>
    <content><![CDATA[<p>最近开始学习后台开发，虽然与我以前从事的 Android 开发一样都是使用 Java 语言，但是技术栈完全不同，有太多的必备的「新」概念要去学习，而在对它们，以及别人写的代码有充分的了解之前，就可能会遇上这种一杯茶，一根烟，一个 Bug 一天根本改不完的情况。</p>
<p>最近遇见的这个 Bug 是在修改项目遗留的问题时偶然发现的，简而言之就是这样：</p>
<p><strong>服务 A</strong> 在从外界接收到推送的一条数据后，将数据插入到库里，然后通过 MQ 推送一条消息给 <strong>服务 B</strong>，<strong>服务 B</strong> 会根据收到的消息进行一些处理，其中包括远程调用 <strong>服务 A</strong> 的方法去查询这条数据，但是在测试环境总是报查询不到这条数据。</p>
<p>遇到问题之后，先进行了一些排查：</p>
<ul>
<li><p>怀疑传参或者数据插库没有成功，于是将查询参数打印出来，手动复制参数到库里去查——有数据；</p>
</li>
<li><p>怀疑实际执行的 SQL 有问题，于是请同事帮忙配置 MyBatis 在日志里输出 SQL，原样复制出来去库里查——有数据；</p>
</li>
<li><p>在本地连接测试环境数据库，代码里下断点调试——能正常取到数据；</p>
</li>
</ul>
<p><img src="/images/posts/java/you-kidding-me.jpg"></p>
<p>纳闷了一阵以后，继续排查：</p>
<ul>
<li><p>怀疑测试环境程序数据库连接有问题，于是测试了一些其它查库的功能——数据正常；</p>
</li>
<li><p>怀疑测试环境的包有问题，于是请运维同事将 jar 包从容器里拷贝下来，核对配置——没问题；</p>
</li>
<li><p>怀疑测试环境远程调用失败了，于是在远程调用处加日志——没有异常；</p>
</li>
</ul>
<p><img src="/images/posts/java/what-is-wrong.jpeg"></p>
<ul>
<li><p>怀疑测试环境注册了多余的 <strong>服务 A</strong> 的节点，于是去 Dubbo Admin 里核对节点——数量正常，网段正常；</p>
</li>
<li><p>怀疑测试环境的部署的 <strong>服务 A</strong> 的某个节点部署有问题，于是请运维同事一个一个 telnet 上去手动执行远程调用——能正常取到数据；</p>
</li>
<li><p>在一条失败 case 之后，马上向 <strong>服务 B</strong> 手动再次推送相同的消息——能取到数据；</p>
</li>
</ul>
<p><img src="/images/posts/java/this-unscientific.jpeg"></p>
<p>直到我终于留意到一个现象：从日志来看，<strong>服务 A</strong> 插库与 <strong>服务 B</strong> 远程调用 <strong>服务 A</strong> 的方法的时间只相差 1 毫秒。会不会是一切发生得太快了，库里还查不到刚刚写入的数据？抑或者查询的时候插库还根本没有生效？</p>
<p>带着这个疑惑我终于认真去看插库并发消息那块的代码了，于是就看到这样一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Transactional(...)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;<br>    ...<br><br>    <span class="hljs-comment">// 插入数据</span><br><br>    <span class="hljs-comment">// 发送消息</span><br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>是的没错，插入数据和发送消息写在了一个事务里面。虽然我对数据库了解不多，但对事务的特性还是有所了解——发送消息的时候，数据库里确实还没有刚刚插入的数据，事务提交后才会生效，也就是说，<strong>服务 B</strong> 收到消息后远程调用回 <strong>服务 A</strong> 想查找刚刚插入的数据，能否查到全凭运气，取决于此时事务已经执行完。</p>
<p>问题时序示意：</p>
<p><img src="/images/posts/java/a-stupid-bug-wrong-sequence.png"></p>
<p>要确保消息发出时数据库里已经存在数据了也很简单，将事务粒度控制一下，只包含插入数据这块逻辑即可，插入成功了再发送消息。</p>
<p><em>PS：如果对消息投递可靠性要求高，可能需要对投递消息失败的情况做一些补偿机制。</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">doSomething</span><span class="hljs-params">()</span> </span>&#123;<br>    ...<br><br>    <span class="hljs-comment">// 事务开始</span><br><br>    <span class="hljs-comment">// 插入数据</span><br><br>    <span class="hljs-comment">// 事务结束</span><br><br>    <span class="hljs-keyword">if</span> (插入数据成功) &#123;<br>        <span class="hljs-comment">// 发送消息</span><br>    &#125;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>正常时序示意：</p>
<p><img src="/images/posts/java/a-stupid-bug-normal-sequence.png"></p>
<p>总结：</p>
<ol>
<li><p>在理解别人写的逻辑的时候不要做预设，你认为别人不可能犯如此低级的错误而直接排除在外的情况，可能恰好是问题所在；</p>
</li>
<li><p>在排查可能是时序导致的问题时，少用断点调试，用日志更合适；</p>
</li>
<li><p>本地调试时尽量将场景模拟完整一点，从中途某一环开始则有可能越过问题触发条件而无法复现。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java, Bug</tag>
      </tags>
  </entry>
  <entry>
    <title>一份简明的 Markdown 笔记与教程</title>
    <url>/2018/09/06/Markdown/markdown-intro/</url>
    <content><![CDATA[<p>为部门内知识分享准备的素材，记录了 Markdown 的优点、应用场景和编辑工具，介绍了标准语法与扩展语法，以及一些应用 Markdown 的奇技淫巧。个人使用 Markdown 的经验持续补充中，最新完整版请参见</p>
<p><a href="https://github.com/mzlogin/markdown-intro">https://github.com/mzlogin/markdown-intro</a></p>
<hr>
<p>自从 2014 年左右接触到 Markdown 以来，对它的使用就一发而不可收拾。从最开始使用它在 GitHub Pages 里写博客，到用它编辑项目的 README 文件，再到撰写开发文档，编辑微信公众号文章和邮件内容等等，这期间也见证了它在各类平台和网站上的普及和被原生支持，可以说，Markdown 如今已经渗透了我在技术和网络活动的方方面面，成为了我撰写文本文档的首选。</p>
<p>那么首先我们一起来看一下它的「定义」：</p>
<blockquote>
<p>Markdown 是一种轻量级标记语言，创始人为 John Gruber。它允许人们「使用易读易写的纯文本格式编写文档，然后转换成有效的 XHTML（或者 HTML）文档」。——维基百科</p>
</blockquote>
<p>本文档的目的不在于面面俱到地介绍 Markdown，只是作为我对其理解的笔记整理，希望能同时帮助一些对 Markdown 感兴趣的人快速上手，或是作为一个工具，供对其已经有所了解的人在需要时参考。</p>
<p>接下来请随我一起深入了解这门并不神秘的实用标记语言。</p>
<p><strong>目录</strong></p>
<ul>
<li>TOC<br>{:toc}</li>
</ul>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li><p>专注于文字内容；</p>
</li>
<li><p>纯文本，易读易写，可以方便地纳入版本控制；</p>
</li>
<li><p>语法简单，没有什么学习成本，能轻松在码字的同时做出美观大方的排版。</p>
</li>
</ol>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li><p>各类代码托管平台</p>
<p>  主流的代码托管平台，如 GitHub、GitLab、BitBucket、Coding、Gitee 等等，都支持 Markdown 语法，很多开源项目的 README、开发文档、帮助文档、Wiki 等都用 Markdown 写作。</p>
</li>
<li><p>技术社区和写作平台</p>
<p>  StackOverflow、CSDN、掘金、简书、GitBook、有道云笔记</p>
</li>
<li><p>论坛</p>
<p>  V2EX、光谷社区</p>
</li>
</ul>
<p>个人感觉比较遗憾的一点是各平台可能采用不同语言实现的 Markdown 解析引擎，或采用同一解析引擎的不同版本，而且可能有不同程度的定制与扩展，这导致在不同平台上使用 Markdown 写作时体验并不完全一致。不过幸好对于大家公认的一些标准语法，各家都是支持的。</p>
<h3 id="编辑工具"><a href="#编辑工具" class="headerlink" title="编辑工具"></a>编辑工具</h3><p>理论上任何一款文本编辑器都能用于编辑 Markdown 文档，它们分别提供了不同程度的语法高亮、预览等功能，以下只是列举其中一部分，选择自己称手的即可。</p>
<ul>
<li><p>现代编辑器</p>
<p>  VSCode / Atom</p>
</li>
<li><p>传统编辑器</p>
<p>  Vim / Emacs / Sublime Text / Notepad++</p>
</li>
<li><p>IDE 自带编辑器</p>
<p>  IntelliJ IDEA / Android Studio / WebStorm</p>
</li>
<li><p>专用编辑器</p>
<p>  Ulysses / Mou / Typora / Markpad</p>
</li>
<li><p>在线编辑器</p>
<p>  各种支持 Markdown 的网站都提供了在线编辑器</p>
</li>
</ul>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p><strong>Markdown：</strong></p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><code class="hljs asciidoc"># atx-style 一级标题<br><br>## 二级标题<br><br>###### 六级标题<br><br><span class="hljs-section">Setext-style 一级标题</span><br><span class="hljs-section">===</span><br><br><span class="hljs-section">二级标题</span><br><span class="hljs-section">---</span><br></code></pre></td></tr></table></figure>

<p><strong>预览效果：</strong></p>
<blockquote>
<h1 id="atx-style-一级标题"><a href="#atx-style-一级标题" class="headerlink" title="atx-style 一级标题"></a>atx-style 一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h1 id="Setext-style-一级标题"><a href="#Setext-style-一级标题" class="headerlink" title="Setext-style 一级标题"></a>Setext-style 一级标题</h1><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2></blockquote>
<p><strong>对应 HTML：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>atx-style 一级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>二级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">h6</span>&gt;</span>六级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h6</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Setext-style 一级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>二级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h3><p>中间没有空行的连续不断的几行文字被视为一个段落。</p>
<p><strong>Markdown：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">白日依山尽，<br><br>黄河入海流。<br>（句号后面没空格）<br><br>欲穷千里目，<br><br>更上一层楼。  <br>（句号后面有俩空格）<br></code></pre></td></tr></table></figure>

<p><strong>预览效果：</strong></p>
<p>白日依山尽，</p>
<p>黄河入海流。<br>（句号后面没空格）</p>
<p>欲穷千里目，</p>
<p>更上一层楼。<br>（句号后面有俩空格）</p>
<p><strong>对应 HTML：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>白日依山尽，<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>黄河入海流。<br>（句号后面没有空格）<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>欲穷千里目，<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>  更上一层楼。<br>  <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>  （句号后面有俩空格）<br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="行内格式"><a href="#行内格式" class="headerlink" title="行内格式"></a>行内格式</h3><p>对段落或者部分文本的强调效果。</p>
<p><strong>Markdown：</strong></p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><code class="hljs asciidoc">后面俩字<span class="hljs-strong">**加黑**</span><br><br>后面俩字<span class="hljs-strong">*斜体*</span><br></code></pre></td></tr></table></figure>

<p><strong>预览效果：</strong></p>
<p>后面俩字<strong>加黑</strong></p>
<p>后面俩字<em>斜体</em></p>
<p><strong>对应 HTML：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>  后面俩字<br>  <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>加黑<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>  后面俩字<br>  <span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>斜体<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="引用块"><a href="#引用块" class="headerlink" title="引用块"></a>引用块</h3><p><strong>Markdown：</strong></p>
<figure class="highlight node-repl"><table><tr><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta">&gt;</span> <span class="javascript">引用块段落一。</span><br><span class="hljs-meta">&gt;</span><br><span class="hljs-meta">&gt;</span> <span class="javascript">引用块段落二。</span><br>&gt;&gt; 内嵌引用块段落一。<br><span class="hljs-meta">&gt;</span><br><span class="hljs-meta">&gt;</span> <span class="javascript">### 引用块内的标题</span><br></code></pre></td></tr></table></figure>

<p><strong>预览效果：</strong></p>
<blockquote>
<p>引用块段落一。</p>
<p>引用块段落二。</p>
<blockquote>
<p>内嵌引用块段落一。</p>
</blockquote>
<h3 id="引用块内的标题"><a href="#引用块内的标题" class="headerlink" title="引用块内的标题"></a>引用块内的标题</h3></blockquote>
<p><strong>对应 HTML：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">blockquote</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>引用块段落一。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>引用块段落二。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">blockquote</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>内嵌引用块段落一。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">blockquote</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;引用块内的标题&quot;</span>&gt;</span>引用块内的标题<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">blockquote</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h3><p>Markdown 支持行内式链接和引用式链接。</p>
<p><strong>Markdown：</strong></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">行内式 <span class="hljs-selector-attr">[博客]</span>(https:<span class="hljs-comment">//mazhuang.org &quot;我的个人博客&quot;) 链接，带 title。</span><br><br>行内式 <span class="hljs-selector-attr">[GitHub]</span>(https:<span class="hljs-comment">//github.com/mzlogin) 链接。</span><br><br>引用式 <span class="hljs-selector-attr">[博客]</span><span class="hljs-selector-attr">[1]</span> 链接。<br><br>引用式 <span class="hljs-selector-attr">[GitHub]</span><span class="hljs-selector-attr">[2]</span> 链接，带 title。<br><br><span class="hljs-selector-attr">[1]</span>: https:<span class="hljs-comment">//mazhuang.org</span><br><span class="hljs-selector-attr">[2]</span>: https:<span class="hljs-comment">//github.com/mzlogin &quot;我的 GitHub 主页&quot;</span><br></code></pre></td></tr></table></figure>

<p><strong>预览效果：</strong></p>
<p>行内式 <a href="https://mazhuang.org/" title="我的个人博客">博客</a> 链接，带 title。</p>
<p>行内式 <a href="https://github.com/mzlogin">GitHub</a> 链接。</p>
<p>引用式 <a href="https://mazhuang.org/">博客</a> 链接。</p>
<p>引用式 <a href="https://github.com/mzlogin" title="我的 GitHub 主页">GitHub</a> 链接，带 title。</p>
<p><strong>对应 HTML：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>行内式 <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://mazhuang.org&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;我的个人博客&quot;</span>&gt;</span>博客<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> 链接，带 title。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>行内式 <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://github.com/mzlogin&quot;</span>&gt;</span>GitHub<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> 链接。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>引用式 <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://mazhuang.org&quot;</span>&gt;</span>博客<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> 链接。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>引用式 <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://github.com/mzlogin&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;我的 GitHub 主页&quot;</span>&gt;</span>GitHub<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> 链接，带 title。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>在超链接的写法前加一个 <code>!</code>，就是引用图片的方法。</p>
<p><strong>Markdown：</strong></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">![Alt text](https:<span class="hljs-regexp">//m</span>azhuang.org/favicon.ico <span class="hljs-string">&quot;favicon&quot;</span>)<br></code></pre></td></tr></table></figure>

<p><strong>预览效果：</strong></p>
<p><img  src="https://mazhuang.org/favicon.ico"   title="favicon"><span class="image-caption">Alt text</span></p>
<p><strong>对应 HTML：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://mazhuang.org/favicon.ico&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Alt text&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;favicon&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>包括有序列表和无序列表。</p>
<p><strong>Markdown：</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">-</span> 苹果<br><span class="hljs-bullet">-</span> 葡萄<br><span class="hljs-bullet">-</span> 榴莲<br><br><span class="hljs-bullet">1.</span> 苹果<br><span class="hljs-bullet">2.</span> 葡萄<br><span class="hljs-bullet">3.</span> 榴莲<br></code></pre></td></tr></table></figure>

<p><strong>预览效果：</strong></p>
<ul>
<li>苹果</li>
<li>葡萄</li>
<li>榴莲</li>
</ul>
<ol>
<li>苹果</li>
<li>葡萄</li>
<li>榴莲</li>
</ol>
<p><strong>对应 HTML：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>苹果<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>葡萄<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>榴莲<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>苹果<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>葡萄<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>榴莲<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>其中无序列表的标记可以使用 <code>+</code>、<code>-</code> 或 <code>*</code>，有序列表前的数字可以是乱序的。</p>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>支持行内代码和代码块。</p>
<p><strong>Markdown：</strong></p>
<pre><code>Android 里使用 `TextUtils` 类的 `isEmpty` 方法来判断字符串是否为空。

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (TextUtils.isEmpty(text)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
</code></pre>
<p><strong>预览效果：</strong></p>
<p>Android 里使用 <code>TextUtils</code> 类的 <code>isEmpty</code> 方法来判断字符串是否为空。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (TextUtils.isEmpty(text)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>对应 HTML：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Android 里使用 <span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>TextUtils<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span> 类的 <span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>isEmpty<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span> 方法来判断字符串是否为空。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;highlight highlight-source-java&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pl-k&quot;</span>&gt;</span>if<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> (<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pl-smi&quot;</span>&gt;</span>TextUtils<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pl-k&quot;</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>isEmpty(text)) &#123;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pl-k&quot;</span>&gt;</span>return<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pl-c1&quot;</span>&gt;</span>null<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>;<br>&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pre</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>上例中的语言标记 <code>java</code> 可选填，可用于在编辑器和渲染后的效果里添加语法高亮。</p>
<p>块式代码也可以对整个代码段缩进四个空格，或一个 Tab 来实现。</p>
<h3 id="水平分割线"><a href="#水平分割线" class="headerlink" title="水平分割线"></a>水平分割线</h3><p>使用一个单独行里的三个或以上 <code>*</code>、<code>-</code> 来生产一条水平分割线，它们之间可以有空格。</p>
<p><strong>Markdown：</strong></p>
<figure class="highlight diff"><table><tr><td class="code"><pre><code class="hljs diff">***<br><br><span class="hljs-comment">-----</span><br><br><span class="hljs-deletion">- - -</span><br></code></pre></td></tr></table></figure>

<p><strong>预览效果：</strong></p>
<hr>
<hr>
<hr>
<p><strong>对应 HTML：</strong></p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-section">&lt;hr /&gt;</span><br><br><span class="hljs-section">&lt;hr /&gt;</span><br><br><span class="hljs-section">&lt;hr /&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="嵌入-HTML"><a href="#嵌入-HTML" class="headerlink" title="嵌入 HTML"></a>嵌入 HTML</h3><p>Markdown 标记语言的目的不是替代 HTML，也不是发明一种更便捷的插入 HTML 标签的方式。它对应的只是 HTML 标签的一个很小的子集。</p>
<p>对于那些没有办法用 Markdown 语法来对应的 HTML 标签，直接使用 HTML 来写就好了。</p>
<h2 id="扩展语法"><a href="#扩展语法" class="headerlink" title="扩展语法"></a>扩展语法</h2><p>本节的内容是介绍一些受到广泛支持的 Markdown 扩展语法。</p>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p><strong>Markdown：</strong></p>
<pre><code>| 编号  | 姓名（左） | 年龄（右） | 性别（中） |
| ----- | :--------  | ---------: | :------:   |
| 0     | 张三       | 28         | 男         |
| 1     | 李四       | 29         | 男         |
</code></pre>
<p><strong>预览效果：</strong></p>
<table>
<thead>
<tr>
<th>编号</th>
<th align="left">姓名（左）</th>
<th align="right">年龄（右）</th>
<th align="center">性别（中）</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td align="left">张三</td>
<td align="right">28</td>
<td align="center">男</td>
</tr>
<tr>
<td>1</td>
<td align="left">李四</td>
<td align="right">29</td>
<td align="center">男</td>
</tr>
</tbody></table>
<p><strong>对应 HTML：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>编号<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>姓名（左）<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>年龄（右）<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">th</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>性别（中）<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>张三<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>28<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>李四<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>29<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><p>在 GitHub / GitLab 里有较好的支持。</p>
<p><strong>Markdown：</strong></p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">- </span>[x] 洗碗<br><span class="hljs-bullet">- </span>[ ] 清洗油烟机<br><span class="hljs-bullet">- </span>[ ] 拖地<br></code></pre></td></tr></table></figure>

<p><strong>预览效果：</strong></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 洗碗</li>
<li><input disabled="" type="checkbox"> 清洗油烟机</li>
<li><input disabled="" type="checkbox"> 拖地</li>
</ul>
<p><strong>对应 HTML：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;contains-task-list&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;task-list-item&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">disabled</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;task-list-item-checkbox&quot;</span> <span class="hljs-attr">checked</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span> 洗碗<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;task-list-item&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">disabled</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;task-list-item-checkbox&quot;</span>&gt;</span> 清洗油烟机<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;task-list-item&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">disabled</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;task-list-item-checkbox&quot;</span>&gt;</span> 拖地<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>如果是在 GitHub / GitLab 的 Issue 里，会附赠任务完成比例提示效果：</p>
<p><img  src="https://raw.githubusercontent.com/mzlogin/markdown-intro/master/assets/task-list-1.png"  ><span class="image-caption">task list 1</span></p>
<p>还可以直接在网页上拖动调整顺序，勾选和取消勾选。</p>
<p><img  src="https://raw.githubusercontent.com/mzlogin/markdown-intro/master/assets/task-list-2.png"  ><span class="image-caption">task list 2</span></p>
<h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p><strong>Markdown：</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">后面三个字打上~~删除线~~。<br></code></pre></td></tr></table></figure>

<p><strong>预览效果：</strong></p>
<p>后面三个字打上<del>删除线</del>。</p>
<p><strong>对应 HTML：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>后面三个字打上<span class="hljs-tag">&lt;<span class="hljs-name">del</span>&gt;</span>删除线<span class="hljs-tag">&lt;/<span class="hljs-name">del</span>&gt;</span>。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h3><p>自动链接扩展，即：当识别到 URL，或用 <code>&lt;</code>、<code>&gt;</code> 包括的 URL 时，会自动为其生成 <code>a</code> 标签。</p>
<p><strong>Markdown：</strong></p>
<figure class="highlight dts"><table><tr><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">https:</span><span class="hljs-comment">//github.com</span><br><br><span class="hljs-params">&lt;example@gmail.com&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>预览效果：</strong></p>
<p><a href="https://github.com/">https://github.com</a></p>
<p><a href="mailto:&#101;&#120;&#x61;&#109;&#x70;&#x6c;&#101;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;">&#101;&#120;&#x61;&#109;&#x70;&#x6c;&#101;&#x40;&#103;&#109;&#97;&#105;&#x6c;&#46;&#x63;&#111;&#x6d;</a></p>
<p><strong>对应 HTML：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://github.com&quot;</span>&gt;</span>https://github.com<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;mailto:example@gmail.com&quot;</span>&gt;</span>example@gmail.com<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="emoji"><a href="#emoji" class="headerlink" title="emoji"></a>emoji</h3><p>以 GitHub Pages 为例。</p>
<p><strong>Markdown：</strong></p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-meta">:camel:</span> :blush: :smile:<br></code></pre></td></tr></table></figure>

<p><strong>预览效果：</strong></p>
<p>:camel: :blush: :smile:</p>
<p><strong>对应 HTML：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;emoji&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;:camel:&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;:camel:&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f42b.png&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;20&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;20&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;emoji&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;:blush:&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;:blush:&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f60a.png&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;20&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;20&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;emoji&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;:smile:&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;:smile:&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://assets-cdn.github.com/images/icons/emoji/unicode/1f604.png&quot;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;20&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;20&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h2 id="奇技淫巧"><a href="#奇技淫巧" class="headerlink" title="奇技淫巧"></a>奇技淫巧</h2><p>脑洞清奇的工程师们还发掘了很多使用 Markdown 的方法，大部分都是引入第三方 JavaScript 插件来实现。对这部分我只做简述，对其中的部分功能比如作图等，还是推荐用专门的可视化工具去做。</p>
<h3 id="画流程图和时序图"><a href="#画流程图和时序图" class="headerlink" title="画流程图和时序图"></a>画流程图和时序图</h3><p>有部分网站和编辑器实现了对 Markdown 里流程图和时序图的支持，比如我们使用的项目管理工具 TAPD 的在线编辑器，还有 VSCode + 插件 Markdown Preview Enhanced 等。</p>
<p>以我们使用的项目管理工具 TAPD 的在线编辑器为例：</p>
<p><img  src="https://raw.githubusercontent.com/mzlogin/markdown-intro/master/assets/tapd-markdown-flowchart.png"  ><span class="image-caption">流程图</span></p>
<p><img  src="https://raw.githubusercontent.com/mzlogin/markdown-intro/master/assets/tapd-markdown-seq.png"  ><span class="image-caption">时序图</span></p>
<h3 id="插入数学公式"><a href="#插入数学公式" class="headerlink" title="插入数学公式"></a>插入数学公式</h3><p>仍然以 TAPD 为例：</p>
<p><img  src="https://raw.githubusercontent.com/mzlogin/markdown-intro/master/assets/tapd-markdown-math.png"  ><span class="image-caption">数学公式</span></p>
<p>应该是利用 JavaScript 支持了 LaTeX 公式语法。</p>
<h3 id="用-Markdown-做-PPT"><a href="#用-Markdown-做-PPT" class="headerlink" title="用 Markdown 做 PPT"></a>用 Markdown 做 PPT</h3><p>有专门的工具 <a href="https://github.com/yhatt/marp">Marp</a>，另外使用 VSCode + 插件 Markdown Preview Enhanced 也可以实现。</p>
<h3 id="用-Markdown-写微信公众号"><a href="#用-Markdown-写微信公众号" class="headerlink" title="用 Markdown 写微信公众号"></a>用 Markdown 写微信公众号</h3><p>可以将公众号素材用 Markdown 编辑好后，贴到在线排版工具以后，复制到公众号编辑器里即可。有多种页面主题和代码主题可选择。</p>
<p>我维护的工具地址：<a href="https://md.mazhuang.org/">https://md.mazhuang.org</a></p>
<p><img  src="https://raw.githubusercontent.com/mzlogin/markdown-intro/master/assets/wechat-markdown.png"  ><span class="image-caption">微信公众号</span></p>
<h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p>想象力丰富的工程师们还扩展了很多基于 Markdown 的玩法，包括但不限于：</p>
<ul>
<li>自动生成 / 更新 Table of Contents</li>
<li>流程图 / 时序图</li>
<li>制作幻灯片</li>
<li>集成 PlantUML / GraphViz 的能力</li>
<li>导出 HTML / PDF / 电子书</li>
<li>…</li>
</ul>
<p>以上功能基本都可以用 VSCode + 插件 Markdown Preview Enhanced 实现。</p>
<p>另外可以参考我以前的一篇博客 <a href="https://mazhuang.org/2017/09/01/markdown-odd-skills/">关于 Markdown 的一些奇技淫巧</a>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://daringfireball.net/projects/markdown/syntax">Markdown: Syntax - DARING FIREBALL</a></li>
<li><a href="https://zh.wikipedia.org/wiki/Markdown">Markdown - 维基百科</a></li>
<li><a href="https://github.github.com/gfm/">GitHub Flavored Markdown Spec</a></li>
<li><a href="https://mazhuang.org/2017/09/01/markdown-odd-skills/">关于 Markdown 的一些奇技淫巧</a></li>
</ul>
<hr>
<p>欢迎关注我的微信公众号，接收 markdown-intro 最新动态。</p>
<div align="center"><img width="192px" height="192px" src="https://mazhuang.org/assets/images/qrcode.jpg"/></div>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown, VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title>解决两个 Android 模拟器之间无法网络通信的问题</title>
    <url>/2017/12/03/Andriod/tcp-connect-between-android-emulators/</url>
    <content><![CDATA[<p>本文解决的是一个小众场景的问题：</p>
<p>出差在外，需要调试局域网内的两台 Android 设备之间通过 TCP 通信的情况，可手边又不是随时有多台可用的设备，于是想在笔记本上同时跑两台 Android 模拟器来构造调试环境，但是发现它俩的 IP 地址竟然都是 10.0.2.15，场面一度十分尴尬……</p>
<p><img src="/images/posts/android/ip-address.png"></p>
<p>谷狗之后，众多相关的博客和问答贴将我引向了官方文档页面：</p>
<p><a href="https://developer.android.com/studio/run/emulator-networking.html#connecting">Interconnecting emulator instances</a></p>
<p>原来官方指南上解释过相关的知识，现将我关心和以前迷惑的部分翻译摘录如下，如果希望对此有个更全面的了解，还是推荐完整阅读 Android 官方文档里有关 Emulator 的章节 <a href="https://developer.android.com/studio/run/emulator.html">https://developer.android.com/studio/run/emulator.html</a></p>
<p>首先讲一点预备知识，再说解决方案。</p>
<h2 id="模拟器的网络地址空间"><a href="#模拟器的网络地址空间" class="headerlink" title="模拟器的网络地址空间"></a>模拟器的网络地址空间</h2><p>每个模拟器都运行在一个虚拟路由/防火墙服务后面，这个服务将模拟器和宿主机器的网络接口、配置以及 Internet 隔离开来。对模拟器而言，宿主机器和其它模拟器对它是不可见的，它只知道自己是通过以太网连接到路由/防火墙。</p>
<p>每个模拟器的虚拟路由管理 10.0.2/24 的网络地址空间，所有地址都是 10.0.2.xx 格式。地址预分配的情况如下：</p>
<table>
<thead>
<tr>
<th>网络地址</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>10.0.2.1</td>
<td>路由/网络地址</td>
</tr>
<tr>
<td>10.0.2.2</td>
<td>宿主机器的 loopback interface，相当于电脑上的 127.0.0.1</td>
</tr>
<tr>
<td>10.0.2.3</td>
<td>首选 DNS Server</td>
</tr>
<tr>
<td>10.0.2.4 <br /> 10.0.2.5 <br /> 10.0.2.6</td>
<td>可选的第二、第三、第四 DNS Server</td>
</tr>
<tr>
<td>10.0.2.15</td>
<td>模拟器的网络地址</td>
</tr>
<tr>
<td>127.0.0.1</td>
<td>模拟器的 loopback interface</td>
</tr>
</tbody></table>
<p>需要注意的是所有模拟器的网络地址分配都是一样的，这样一来，如果有两个模拟器同时运行在一台电脑上，它们都会有各自的路由，并且给两个模拟器分配的 IP 都是 10.0.2.15。它们被路由隔离，相互不可见。</p>
<p>另外一点就是模拟器上的 127.0.0.1 是指它自己，所以如果想访问宿主机器上运行的服务，要使用 10.0.2.2。</p>
<h2 id="实现两台模拟器之间的通信"><a href="#实现两台模拟器之间的通信" class="headerlink" title="实现两台模拟器之间的通信"></a>实现两台模拟器之间的通信</h2><p>现在来解决标题和文首提到的问题，主要用到了网络重定向。</p>
<p>假设开发环境是：</p>
<ul>
<li><p>PC 是指运行模拟器的宿主电脑</p>
</li>
<li><p>emulator-5554 是模拟器 1，将在 TCP 通信中作为 server 端</p>
</li>
<li><p>emulator-5556 是模拟器 2，将在 TCP 通信中作为 client 端</p>
</li>
</ul>
<p>配置步骤：</p>
<ol>
<li><p>在 emulator-5554 上运行 server，侦听 10.0.2.15:58080</p>
</li>
<li><p>在 PC 上运行 <code>cat ~/.emulator_console_auth_token</code>，得到一个 token</p>
</li>
<li><p>在 PC 上运行</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">telnet localhost 5554<br>auth &lt;token&gt;<br>redir add tcp:51212:58080<br></code></pre></td></tr></table></figure>

<p> <code>&lt;token&gt;</code> 是指第 2 步中得到的 token。</p>
<p> 51212 是 PC 端口，58080 是 5554 模拟器的端口。</p>
</li>
<li><p>在 emulator-5556 上运行 client 程序，连接 10.0.2.2:51212</p>
</li>
</ol>
<p>至此，两台模拟器之间已经可以通过 TCP 愉快地通信了。</p>
<p>它们之间的网络连接和通信示意图如下：</p>
<p><img src="/images/posts/android/emulators-communication.png"></p>
<p><strong>注：</strong> </p>
<ul>
<li><p>以上步骤中用到的端口号都是可以根据你的需求替换的</p>
</li>
<li><p>Windows 下 telnet 命令默认没有启用，具体启用方法请搜狗一下</p>
</li>
</ul>
<h2 id="模拟器的网络限制"><a href="#模拟器的网络限制" class="headerlink" title="模拟器的网络限制"></a>模拟器的网络限制</h2><ol>
<li><p>模拟器上运行的 Apps 可以连接到宿主电脑上的网络，但这是通过模拟器间接实现，不是直接连到宿主电脑的网卡。模拟器可以看作是宿主电脑上运行的一个普通程序。</p>
</li>
<li><p>因为模拟器的特殊网络配置，可能无法支持一些网络协议，比如 ping 命令使用的 ICMP 协议。目前，模拟器不支持 IGMP 和 multicast。</p>
<p> <em>试验了一下，模拟器的 shell 里 <code>ping www.sogou.com</code> 一直卡在那，在手机的 shell 里就可以。</em></p>
</li>
</ol>
<h2 id="额外的发现"><a href="#额外的发现" class="headerlink" title="额外的发现"></a>额外的发现</h2><p>在阅读 Android 官方文档里关于模拟器的章节时，意外地发现有一节 <a href="https://developer.android.com/studio/run/emulator-networking.html#calling">Sending a voice call or SMS to another emulator instance</a></p>
<p>就是说模拟器可以给另外的模拟器打电话和发短信，电话号码就是端口号，比如 emulator-5554 模拟器，电话号码就是 5554，这个号码也可以从模拟器的窗口标题栏上找到，比如 <code>Android Emulator - Nexus_5X_API_19:5554</code>，里面那个 5554 就是。</p>
<h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>天下博文，大部分都逃不出官方文档与公开源码的范畴（比如本文就是），而且都是选定文档里讲的某一小部分来进行讲解演绎，这在作为扩展视野、快速上手、快速解决问题等用途时还是比较实用的，但如果想系统、全面地学习，官方文档一般是更好的选择。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android, Emulator, TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 源码分析 —— 从 Toast 出发</title>
    <url>/2017/11/12/Andriod/start-from-toast/</url>
    <content><![CDATA[<p>本系列文章在 <a href="https://github.com/mzlogin/rtfsc-android">https://github.com/mzlogin/rtfsc-android</a> 持续更新中，欢迎有兴趣的童鞋们关注。</p>
<p><img src="/images/posts/android/toast.png"></p>
<p>（图 from Android Developers）</p>
<p>Toast 是 Android 开发里较常用的一个类了，有时候用它给用户弹提示信息和界面反馈，有时候用它来作为辅助调试的手段。用得多了，自然想对其表层之下的运行机制有所了解，所以在此将它选为我的第一个 RTFSC Roots。</p>
<p>本篇采用的记录方式是先对它有个整体的了解，然后提出一些问题，再通过阅读源码，对问题进行一一解读而后得出答案。</p>
<p>本文使用的工具与源码为：Chrome、插件 insight.io、GitHub 项目 <a href="https://github.com/aosp-mirror/platform_frameworks_base">aosp-mirror/platform_frameworks_base</a></p>
<p><strong>目录</strong></p>
<!-- vim-markdown-toc GFM -->

<ul>
<li><a href="#toast-%E5%8D%B0%E8%B1%A1">Toast 印象</a></li>
<li><a href="#%E6%8F%90%E5%87%BA%E9%97%AE%E9%A2%98">提出问题</a></li>
<li><a href="#%E8%A7%A3%E7%AD%94%E9%97%AE%E9%A2%98">解答问题</a><ul>
<li><a href="#toast-%E7%9A%84%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4">Toast 的超时时间</a></li>
<li><a href="#%E8%83%BD%E4%B8%8D%E8%83%BD%E5%BC%B9%E4%B8%80%E4%B8%AA%E6%97%B6%E9%97%B4%E8%B6%85%E9%95%BF%E7%9A%84-toast">能不能弹一个时间超长的 Toast？</a></li>
<li><a href="#toast-%E8%83%BD%E4%B8%8D%E8%83%BD%E5%9C%A8%E9%9D%9E-ui-%E7%BA%BF%E7%A8%8B%E8%B0%83%E7%94%A8">Toast 能不能在非 UI 线程调用？</a></li>
<li><a href="#%E5%BA%94%E7%94%A8%E5%9C%A8%E5%90%8E%E5%8F%B0%E6%97%B6%E8%83%BD%E4%B8%8D%E8%83%BD-toast">应用在后台时能不能 Toast？</a></li>
<li><a href="#toast-%E6%95%B0%E9%87%8F%E6%9C%89%E6%B2%A1%E6%9C%89%E9%99%90%E5%88%B6">Toast 数量有没有限制？</a></li>
<li><a href="#toastmaketextshow-%E5%85%B7%E4%BD%93%E9%83%BD%E5%81%9A%E4%BA%86%E4%BA%9B%E4%BB%80%E4%B9%88"><code>Toast.makeText(…).show()</code> 具体都做了些什么？</a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a><ul>
<li><a href="#%E8%A1%A5%E5%85%85%E5%90%8E%E7%9A%84-toast-%E7%9F%A5%E8%AF%86%E7%82%B9%E5%88%97%E8%A1%A8">补充后的 Toast 知识点列表</a></li>
<li><a href="#%E9%81%97%E7%95%99%E7%9F%A5%E8%AF%86%E7%82%B9">遗留知识点</a></li>
<li><a href="#%E6%9C%AC%E7%AF%87%E7%94%A8%E5%88%B0%E7%9A%84%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95">本篇用到的源码分析方法</a></li>
</ul>
</li>
<li><a href="#%E5%90%8E%E8%AF%9D">后话</a></li>
</ul>
<!-- vim-markdown-toc -->

<h2 id="Toast-印象"><a href="#Toast-印象" class="headerlink" title="Toast 印象"></a>Toast 印象</h2><p>首先我们从 Toast 类的 <a href="1">官方文档</a> 和 <a href="2">API 指南</a> 中可以得出它具备如下特性：</p>
<ol>
<li><p>Toast 不是 View，它用于帮助创建并展示包含一条小消息的 View；</p>
</li>
<li><p>它的设计理念是尽量不惹眼，但又能展示想让用户看到的信息；</p>
</li>
<li><p>被展示时，浮在应用界面之上；</p>
</li>
<li><p>永远不会获取到焦点；</p>
</li>
<li><p>大小取决于消息的长度；</p>
</li>
<li><p>超时后会自动消失；</p>
</li>
<li><p>可以自定义显示在屏幕上的位置（默认左右居中显示在靠近屏幕底部的位置）；</p>
</li>
<li><p>可以使用自定义布局，也只有在自定义布局的时候才需要直接调用 Toast 的构造方法，其它时候都是使用 makeText 方法来创建 Toast；</p>
</li>
<li><p>Toast 弹出后当前 Activity 会保持可见性和可交互性；</p>
</li>
<li><p>使用 <code>cancel</code> 方法可以立即将已显示的 Toast 关闭，让未显示的 Toast 不再显示；</p>
</li>
<li><p>Toast 也算是一个「通知」，如果弹出状态消息后期望得到用户响应，应该使用 Notification。</p>
</li>
</ol>
<p>不知道你看到这个列表，是否学到了新知识或者明确了以前不确定的东西，反正我在整理列表的时候是有的。</p>
<h2 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h2><p>根据以上特性，再结合平时对 Toast 的使用，提出如下问题来继续本次源码分析之旅（大致由易到难排列，后文用 小 demo 或者源码分析来解答）：</p>
<ol>
<li><p>Toast 的超时时间具体是多少？</p>
</li>
<li><p>能不能弹一个时间超长的 Toast？</p>
</li>
<li><p>Toast 能不能在非 UI 线程调用？</p>
</li>
<li><p>应用在后台时能不能 Toast？</p>
</li>
<li><p>Toast 数量有没有限制？</p>
</li>
<li><p><code>Toast.makeText(…).show()</code> 具体都做了些什么？</p>
</li>
</ol>
<h2 id="解答问题"><a href="#解答问题" class="headerlink" title="解答问题"></a>解答问题</h2><h3 id="Toast-的超时时间"><a href="#Toast-的超时时间" class="headerlink" title="Toast 的超时时间"></a>Toast 的超时时间</h3><p>用这样的一个问题开始「Android 源码分析」，真的好怕被打死……大部分人都会嗤之以鼻：Are you kidding me? So easy. 各位大佬们稍安勿躁，阅读大型源码不是个容易的活，让我们从最简单的开始，一点一点建立自信，将这项伟大的事业进行下去。</p>
<p>面对这个问题，我的第一反应是去查 <code>Toast.LENGTH_LONG</code> 和 <code>Toast.LENGTH_SHORT</code> 的值，毕竟平时都是用这两个值来控制显示长/短 Toast 的。</p>
<p>文件 <a href="https://github.com/aosp-mirror/platform_frameworks_base/blob/master/core/java/android/widget/Toast.java">platform_frameworks_base/core/java/android/widget/Toast.java</a> 中能看到它们俩的定义是这样的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Show the view or text notification for a short period of time.  This time</span><br><span class="hljs-comment"> * could be user-definable.  This is the default.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #setDuration</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> LENGTH_SHORT = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Show the view or text notification for a long period of time.  This time</span><br><span class="hljs-comment"> * could be user-definable.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> #setDuration</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> LENGTH_LONG = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<p>啊哦~原来它们只是两个 flag，并非确切的时间值。</p>
<p>既然是 flag，那自然就会有根据不同的 flag 来设置不同的具体值的地方，于是使用 insight.io 点击 <code>LENGTH_SHORT</code> 的定义搜索一波 <code>Toast.LENGTH_SHORT</code> 的引用，在 <a href="https://github.com/aosp-mirror/platform_frameworks_base">aosp-mirror/platform_frameworks_base</a> 里一共有 50 处引用，但都是调用 <code>Toast.makeText(...)</code> 时出现的。</p>
<p>继续搜索 <code>Toast.LENGTH_LONG</code> 的引用，在 <a href="https://github.com/aosp-mirror/platform_frameworks_base">aosp-mirror/platform_frameworks_base</a> 中共出现 42 次，其中有两处长得像是我们想找的：</p>
<p>第一处，文件 <a href="https://github.com/aosp-mirror/platform_frameworks_base/blob/master/core/java/android/widget/Toast.java">platform_frameworks_base/core/java/android/widget/Toast.java</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TN</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ITransientNotification</span>.<span class="hljs-title">Stub</span> </span>&#123;<br>    ...<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> SHORT_DURATION_TIMEOUT = <span class="hljs-number">4000</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> LONG_DURATION_TIMEOUT = <span class="hljs-number">7000</span>; <br>    ...<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleShow</span><span class="hljs-params">(IBinder windowToken)</span> </span>&#123;<br>        ...<br>        mParams.hideTimeoutMilliseconds = mDuration ==<br>            Toast.LENGTH_LONG ? LONG_DURATION_TIMEOUT : SHORT_DURATION_TIMEOUT;<br>        ...<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个 hideTimeoutMilliseconds 是干嘛的呢？</p>
<p>文件 <a href="https://github.com/aosp-mirror/platform_frameworks_base/blob/master/core/java/android/view/WindowManager.java">platform_frameworks_base/core/java/android/view/WindowManager.java</a> 里能看到这个 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ...</span><br><span class="hljs-comment"> * ...                                        . Therefore, we do hide</span><br><span class="hljs-comment"> * such windows to prevent them from overlaying other apps.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@hide</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> hideTimeoutMilliseconds = -<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<p>在 GitHub 用 blame 查看到改动这一行的最近一次提交 <a href="https://github.com/aosp-mirror/platform_frameworks_base/commit/aa07653d2eea38a7a5bda5944c8a353586916ae9">aa07653d</a>，它的 commit message 能表明它的用途：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">Prevent apps <span class="hljs-keyword">to</span> overlay other apps via toast windows<br><br>It was possible <span class="hljs-keyword">for</span> apps <span class="hljs-keyword">to</span> <span class="hljs-keyword">put</span> toast type windows<br><span class="hljs-keyword">that</span> overlay other apps which toast winodws aren&#x27;t<br>removed <span class="hljs-keyword">after</span> a <span class="hljs-keyword">timeout</span>.<br><br>Now <span class="hljs-keyword">for</span> apps targeting SDK <span class="hljs-keyword">greater than</span> N MR1 <span class="hljs-keyword">to</span> add a<br>toast window one needs <span class="hljs-keyword">to</span> have a special token. The token<br><span class="hljs-keyword">is</span> added <span class="hljs-keyword">by</span> <span class="hljs-keyword">the</span> notificatoion manager service only <span class="hljs-keyword">for</span><br><span class="hljs-keyword">the</span> lifetime <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> shown toast <span class="hljs-keyword">and</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">then</span> removed<br>including all windows associated <span class="hljs-keyword">with</span> this token. This<br>prevents apps <span class="hljs-keyword">to</span> add arbitrary toast windows.<br><br>Since legacy apps may rely <span class="hljs-keyword">on</span> <span class="hljs-keyword">the</span> ability <span class="hljs-keyword">to</span> directly<br>add toasts we mitigate <span class="hljs-keyword">by</span> allowing these apps <span class="hljs-keyword">to</span> still<br>add such windows <span class="hljs-keyword">for</span> unlimited duration <span class="hljs-keyword">if</span> this app <span class="hljs-keyword">is</span><br><span class="hljs-keyword">the</span> currently focused one, i.e. <span class="hljs-keyword">the</span> user interacts <span class="hljs-keyword">with</span><br><span class="hljs-keyword">it</span> <span class="hljs-keyword">then</span> <span class="hljs-keyword">it</span> can overlay itself, otherwise we make sure<br>these toast windows are removed <span class="hljs-keyword">after</span> a <span class="hljs-keyword">timeout</span> like<br>a toast would be.<br><br>We don&#x27;t allow more <span class="hljs-keyword">that</span> one toast window per UID being<br>added <span class="hljs-keyword">at</span> a <span class="hljs-built_in">time</span> which prevents <span class="hljs-number">1</span>) legacy apps <span class="hljs-keyword">to</span> <span class="hljs-keyword">put</span> <span class="hljs-keyword">the</span><br>same toast <span class="hljs-keyword">after</span> a <span class="hljs-keyword">timeout</span> <span class="hljs-keyword">to</span> go <span class="hljs-keyword">around</span> our new policy<br><span class="hljs-keyword">of</span> hiding toasts <span class="hljs-keyword">after</span> a <span class="hljs-keyword">while</span>; <span class="hljs-number">2</span>) modern apps <span class="hljs-keyword">to</span> reuse<br><span class="hljs-keyword">the</span> passed token <span class="hljs-keyword">to</span> add more than one window; Note <span class="hljs-keyword">that</span><br><span class="hljs-keyword">the</span> notification manager shows toasts one <span class="hljs-keyword">at</span> a <span class="hljs-built_in">time</span>.<br></code></pre></td></tr></table></figure>

<p>它并不是用来控制 Toast 的显示时间的，只是为了防止有些应用的 toast 类型的窗口长期覆盖在别的应用上面，而超时自动隐藏这些窗口的时间，可以看作是一种防护措施。</p>
<p>第二处，文件 <a href="https://github.com/aosp-mirror/platform_frameworks_base/blob/master/services/core/java/com/android/server/notification/NotificationManagerService.java">platform_frameworks_base/services/core/java/com/android/server/notification/NotificationManagerService.java</a> 里</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">long</span> delay = r.duration == Toast.LENGTH_LONG ? LONG_DELAY : SHORT_DELAY;<br></code></pre></td></tr></table></figure>

<p>在同一文件里能找到 <code>LONG_DELAY</code> 与 <code>SHORT_DELAY</code> 的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> LONG_DELAY = PhoneWindowManager.TOAST_WINDOW_TIMEOUT;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SHORT_DELAY = <span class="hljs-number">2000</span>; <span class="hljs-comment">// 2 seconds</span><br></code></pre></td></tr></table></figure>

<p>点击查看 <code>PhoneWindowManager.TOAST_WINDOW_TIMEOUT</code> 的定义：</p>
<p>文件 <a href="https://github.com/aosp-mirror/platform_frameworks_base/blob/master/services/core/java/com/android/server/policy/PhoneWindowManager.java">platform_frameworks_base/services/core/java/com/android/server/policy/PhoneWindowManager.java</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** Amount of time (in milliseconds) a toast window can be shown. */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TOAST_WINDOW_TIMEOUT = <span class="hljs-number">3500</span>; <span class="hljs-comment">// 3.5 seconds</span><br></code></pre></td></tr></table></figure>
<p>至此，我们可以得出 <strong>结论：Toast 的长/短超时时间分别为 3.5 秒和 2 秒。</strong></p>
<p><em>Tips: 也可以通过分析代码里的逻辑，一层一层追踪用到 <code>LENGTH_SHORT</code> 和 <code>LENGTH_LONG</code> 的地方，最终得出结论，而这里是根据一些合理推断来简化追踪过程，更快达到目标，这在一些场景下是可取和必要的。</em></p>
<h3 id="能不能弹一个时间超长的-Toast？"><a href="#能不能弹一个时间超长的-Toast？" class="headerlink" title="能不能弹一个时间超长的 Toast？"></a>能不能弹一个时间超长的 Toast？</h3><p>注：这里探讨的是能否直接通过 Toast 提供的公开 API 做到，网络上能搜索到的使用 Timer、反射、自定义等方式达到弹出一个超长时间 Toast 目的的方法不在讨论范围内。</p>
<p>我们在 Toast 类的源码里看一下跟设置时长相关的代码：</p>
<p>文件 <a href="https://github.com/aosp-mirror/platform_frameworks_base/blob/master/core/java/android/widget/Toast.java">platform_frameworks_base/core/java/android/widget/Toast.java</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">...<br><br>    <span class="hljs-comment">/** <span class="hljs-doctag">@hide</span> */</span><br>    <span class="hljs-meta">@IntDef(&#123;LENGTH_SHORT, LENGTH_LONG&#125;)</span><br>    <span class="hljs-meta">@Retention(RetentionPolicy.SOURCE)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Duration &#123;&#125;<br><br>...<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Set how long to show the view for.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> #LENGTH_SHORT</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> #LENGTH_LONG</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDuration</span><span class="hljs-params">(<span class="hljs-meta">@Duration</span> <span class="hljs-keyword">int</span> duration)</span> </span>&#123;<br>        mDuration = duration;<br>        mTN.mDuration = duration;<br>    &#125;<br><br>...<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Make a standard toast that just contains a text view.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> context  The context to use.  Usually your &#123;<span class="hljs-doctag">@link</span> android.app.Application&#125;</span><br><span class="hljs-comment">     *                 or &#123;<span class="hljs-doctag">@link</span> android.app.Activity&#125; object.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> text     The text to show.  Can be formatted text.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> duration How long to display the message.  Either &#123;<span class="hljs-doctag">@link</span> #LENGTH_SHORT&#125; or</span><br><span class="hljs-comment">     *                 &#123;<span class="hljs-doctag">@link</span> #LENGTH_LONG&#125;</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Toast <span class="hljs-title">makeText</span><span class="hljs-params">(Context context, CharSequence text, <span class="hljs-meta">@Duration</span> <span class="hljs-keyword">int</span> duration)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> makeText(context, <span class="hljs-keyword">null</span>, text, duration);<br>    &#125;<br><br>...<br></code></pre></td></tr></table></figure>

<p>其实从上面 <code>setDuration</code> 和 <code>makeText</code> 的注释已经可以看出，duration 只能取值 <code>LENGTH_SHORT</code> 和 <code>LENGTH_LONG</code>，除了注释之外，还使用了 <code>@Duration</code> 注解来保证此事。<code>Duration</code> 自身使用了 <code>@IntDef</code> 注解，它用于限制可以取的值。</p>
<p>文件 <a href="https://github.com/aosp-mirror/platform_frameworks_base/blob/master/core/java/android/annotation/IntDef.java">platform_frameworks_base/core/java/android/annotation/IntDef.java</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Denotes that the annotated element of integer type, represents</span><br><span class="hljs-comment"> * a logical type and that its value should be one of the explicitly</span><br><span class="hljs-comment"> * named constants. If the &#123;<span class="hljs-doctag">@link</span> #flag()&#125; attribute is set to true,</span><br><span class="hljs-comment"> * multiple constants can be combined.</span><br><span class="hljs-comment"> * ...</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>

<p>不信邪的我们可以快速在一个 demo Android 工程里写一句这样的代码试试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Toast.makeText(<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure>

<p>Android Studio 首先就不会同意，警告你 <code>Must be one of: Toast.LENGTH_SHORT, Toast.LENGTH_LONG</code>，但实际这段代码是可以通过编译的，因为 <code>Duration</code> 注解的 <code>Retention</code> 为 <code>RetentionPolicy.SOURCE</code>，我的理解是该注解主要能用于 IDE 的智能提示警告，编译期就被丢掉了。</p>
<p>但即使 duration 能传入 <code>LENGTH_SHORT</code> 和 <code>LENGTH_LONG</code> 以外的值，也并没有什么卵用，别忘了这里设置的只是一个 flag，真正计算的时候是 <code>long delay = r.duration == Toast.LENGTH_LONG ? LONG_DELAY : SHORT_DELAY;</code>，即 duration 为 <code>LENGTH_LONG</code> 时时长为 3.5 秒，其它情况都是 2 秒。</p>
<p>所以我们可以得出 <strong>结论：无法通过 Toast 提供的公开 API 直接弹出超长时间的 Toast。</strong>（如节首所述，可以通过一些其它方式实现类似的效果）</p>
<h3 id="Toast-能不能在非-UI-线程调用？"><a href="#Toast-能不能在非-UI-线程调用？" class="headerlink" title="Toast 能不能在非 UI 线程调用？"></a>Toast 能不能在非 UI 线程调用？</h3><p>这个问题适合用一个 demo 来解答。</p>
<p>我们创建一个最简单的 App 工程，然后在启动 Activity 的 onCreate 方法里添加这样一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        Toast.makeText(MainActivity.<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;Call toast on non-UI thread&quot;</span>, Toast.LENGTH_SHORT)<br>                .show();<br>    &#125;<br>&#125;).start();<br></code></pre></td></tr></table></figure>

<p>啊哦~很遗憾程序直接挂掉了。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-number">11</span>-<span class="hljs-number">07</span> <span class="hljs-number">13</span>:<span class="hljs-number">35</span>:<span class="hljs-number">33.980</span> <span class="hljs-number">2020</span>-<span class="hljs-number">2035</span>/org.mazhuang.androiduidemos E/AndroidRuntime: FATAL EXCEPTION: Thread-<span class="hljs-number">77</span><br>    java.lang.RuntimeException: Can&#x27;t create handler inside thread that has not called <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Looper</span>.</span></span>prepare<span class="hljs-literal">()</span><br>        at android.widget.Toast$TN.&lt;init&gt;(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Toast</span>.</span></span>java:<span class="hljs-number">390</span>)<br>        at android.widget.Toast.&lt;init&gt;(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Toast</span>.</span></span>java:<span class="hljs-number">114</span>)<br>        at android.widget.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Toast</span>.</span></span>make<span class="hljs-constructor">Text(Toast.<span class="hljs-params">java</span>:277)</span><br>        at android.widget.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Toast</span>.</span></span>make<span class="hljs-constructor">Text(Toast.<span class="hljs-params">java</span>:267)</span><br>        at org.mazhuang.androiduidemos.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">MainActivity$1</span>.</span></span>run(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">MainActivity</span>.</span></span>java:<span class="hljs-number">27</span>)<br>        at java.lang.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>run(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>java:<span class="hljs-number">856</span>)<br></code></pre></td></tr></table></figure>

<p>顺着堆栈里显示的方法调用从下往上一路看过去，</p>
<p>文件 <a href="https://github.com/aosp-mirror/platform_frameworks_base/blob/master/core/java/android/widget/Toast.java">platform_frameworks_base/core/java/android/widget/Toast.java</a> </p>
<p>首先是两级 makeText 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 我们的代码里调用的 makeText 方法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Toast <span class="hljs-title">makeText</span><span class="hljs-params">(Context context, CharSequence text, <span class="hljs-meta">@Duration</span> <span class="hljs-keyword">int</span> duration)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> makeText(context, <span class="hljs-keyword">null</span>, text, duration);<br>&#125;<br><br><span class="hljs-comment">// 隐藏的 makeText 方法，不能手动调用</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Toast <span class="hljs-title">makeText</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Context context, <span class="hljs-meta">@Nullable</span> Looper looper,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-meta">@NonNull</span> CharSequence text, <span class="hljs-meta">@Duration</span> <span class="hljs-keyword">int</span> duration)</span> </span>&#123;<br>    Toast result = <span class="hljs-keyword">new</span> Toast(context, looper); <span class="hljs-comment">// 这里的 looper 为 null</span><br>    ...<br></code></pre></td></tr></table></figure>

<p>然后到了 Toast 的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Toast</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Context context, <span class="hljs-meta">@Nullable</span> Looper looper)</span> </span>&#123;<br>    mContext = context;<br>    mTN = <span class="hljs-keyword">new</span> TN(context.getPackageName(), looper); <span class="hljs-comment">// looper 为 null</span><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>到 Toast$TN 的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// looper = null</span><br>TN(String packageName, <span class="hljs-meta">@Nullable</span> Looper looper) &#123;<br>    ...<br>    <span class="hljs-keyword">if</span> (looper == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// Use Looper.myLooper() if looper is not specified.</span><br>        looper = Looper.myLooper();<br>        <span class="hljs-keyword">if</span> (looper == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<br>                    <span class="hljs-string">&quot;Can&#x27;t toast on a thread that has not called Looper.prepare()&quot;</span>);<br>        &#125;<br>    &#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>至此，我们已经追踪到了我们的崩溃的 RuntimeException，即要避免进入抛出异常的逻辑，要么调用的时候传递一个 Looper 进来（无法直接实现，能传递 Looper 参数的构造方法与 makeText 方法是 hide 的），要么 <code>Looper.myLooper()</code> 返回不为 null，提示信息 <code>Can&#39;t create handler inside thread that has not called Looper.prepare()</code> 里给出了方法，那我们在 toast 前面加一句 <code>Looper.prepare()</code> 试试？这次不崩溃了，但依然不弹出 Toast，毕竟，这个线程在调用完 <code>show()</code> 方法后就直接结束了，没有调用 <code>Looper.loop()</code>，至于为什么调用 Toast 的线程结束与否会对 Toast 的显示隐藏等起影响，在本文的后面的章节里会进行分析。</p>
<p>从崩溃提示来看，Android 并没有限制在非 UI 线程里使用 Toast，只是线程得是一个有 Looper 的线程。于是我们尝试构造如下代码，发现可以成功从非 UI 线程弹出 toast 了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MSG_TOAST = <span class="hljs-number">101</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MSG_QUIT = <span class="hljs-number">102</span>;<br><br>        Looper.prepare();<br><br>        <span class="hljs-keyword">final</span> Handler handler = <span class="hljs-keyword">new</span> Handler() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;<br><br>                <span class="hljs-keyword">switch</span> (msg.what) &#123;<br>                    <span class="hljs-keyword">case</span> MSG_TOAST:<br>                        Toast.makeText(MainActivity.<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;Call toast on non-UI thread&quot;</span>, Toast.LENGTH_SHORT)<br>                                .show();<br>                        sendEmptyMessageDelayed(MSG_QUIT, <span class="hljs-number">4000</span>);<br>                        <span class="hljs-keyword">return</span>;<br><br>                    <span class="hljs-keyword">case</span> MSG_QUIT:<br>                        Looper.myLooper().quit();<br>                        <span class="hljs-keyword">return</span>;<br>                &#125;<br><br>                <span class="hljs-keyword">super</span>.handleMessage(msg);<br>            &#125;<br>        &#125;;<br><br>        handler.sendEmptyMessage(MSG_TOAST);<br><br>        Looper.loop();<br>    &#125;<br>&#125;).start();<br></code></pre></td></tr></table></figure>

<p>至于为什么 <code>sendEmptyMesageDelayed(MSG_QUIT, 4000)</code> 里的 delayMillis 我设成了 4000，这里卖个关子，感兴趣的同学可以把这个值调成 0、1000 等等看一下效果，会有一些意想不到的情况发生。</p>
<p>到此，我们可以得出 <strong>结论：可以在非 UI 线程里调用 Toast，但是得是一个有 Looper 的线程。</strong></p>
<p>ps. 上面这一段演示代码让人感觉为了弹出一个 Toast 好麻烦，也可以采用 Activity.runOnUiThread、View.post 等方法从非 UI 线程将逻辑切换到 UI 线程里执行，直接从 UI 线程里弹出，UI 线程是有 Looper 的。</p>
<p><em>知识点：这里如果对 Looper、Handler 和 MessageQueue 有所了解，就容易理解多了，预计下一篇对这三剑客进行讲解。</em></p>
<h3 id="应用在后台时能不能-Toast？"><a href="#应用在后台时能不能-Toast？" class="headerlink" title="应用在后台时能不能 Toast？"></a>应用在后台时能不能 Toast？</h3><p>这个问题也比较适合用一个简单的 demo 来尝试回答。</p>
<p>在 MainActivity 的 onCreate 里加上这样一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">view.postDelayed(<span class="hljs-keyword">new</span> Runnable() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        Toast.makeText(MainActivity.<span class="hljs-keyword">this</span>, <span class="hljs-string">&quot;background toast&quot;</span>, Toast.LENGTH_SHORT).show();<br>    &#125;<br>&#125;, <span class="hljs-number">5000</span>);<br></code></pre></td></tr></table></figure>

<p>然后待应用启动后按 HOME 键，等几秒看是否能弹出该 Toast 即可。</p>
<p><strong>结论是：应用在后台时可以弹出 Toast。</strong></p>
<h3 id="Toast-数量有没有限制？"><a href="#Toast-数量有没有限制？" class="headerlink" title="Toast 数量有没有限制？"></a>Toast 数量有没有限制？</h3><p>这个问题将在下一节中一并解答。</p>
<h3 id="Toast-makeText-…-show-具体都做了些什么？"><a href="#Toast-makeText-…-show-具体都做了些什么？" class="headerlink" title="Toast.makeText(…).show() 具体都做了些什么？"></a><code>Toast.makeText(…).show()</code> 具体都做了些什么？</h3><p>首先看一下 makeText 方法。</p>
<p>文件 <a href="https://github.com/aosp-mirror/platform_frameworks_base/blob/master/core/java/android/widget/Toast.java">platform_frameworks_base/core/java/android/widget/Toast.java</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Make a standard toast to display using the specified looper.</span><br><span class="hljs-comment"> * If looper is null, Looper.myLooper() is used.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@hide</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Toast <span class="hljs-title">makeText</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Context context, <span class="hljs-meta">@Nullable</span> Looper looper,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-meta">@NonNull</span> CharSequence text, <span class="hljs-meta">@Duration</span> <span class="hljs-keyword">int</span> duration)</span> </span>&#123;<br>    Toast result = <span class="hljs-keyword">new</span> Toast(context, looper);<br><br>    LayoutInflater inflate = (LayoutInflater)<br>            context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);<br>    View v = inflate.inflate(com.android.internal.R.layout.transient_notification, <span class="hljs-keyword">null</span>);<br>    TextView tv = (TextView)v.findViewById(com.android.internal.R.id.message);<br>    tv.setText(text);<br><br>    result.mNextView = v;<br>    result.mDuration = duration;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这个方法里就是构造了一个 Toast 对象，将需要展示的 View 准备好，设置好超时时长标记，我们可以看一下 <code>com.android.internal.R.layout.transient_notification</code> 这个布局的内容：</p>
<p>文件 <a href="https://github.com/aosp-mirror/platform_frameworks_base/blob/master/core/res/res/layout/transient_notification.xml">platform_frameworks_base/core/res/res/layout/transient_notification.xml</a></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><br><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;?android:attr/toastFrameBackground&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@android:id/message&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">&quot;1&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_marginHorizontal</span>=<span class="hljs-string">&quot;24dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_marginVertical</span>=<span class="hljs-string">&quot;15dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_gravity</span>=<span class="hljs-string">&quot;center_horizontal&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:textAppearance</span>=<span class="hljs-string">&quot;@style/TextAppearance.Toast&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:textColor</span>=<span class="hljs-string">&quot;@color/primary_text_default_material_light&quot;</span></span><br><span class="hljs-tag">        /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>我们最常见的 Toast 就是从这个布局文件渲染出来的了。</p>
<p>我们继续看一下 makeText 里调用的 Toast 的构造方法里做了哪些事情：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Constructs an empty Toast object.  If looper is null, Looper.myLooper() is used.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@hide</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Toast</span><span class="hljs-params">(<span class="hljs-meta">@NonNull</span> Context context, <span class="hljs-meta">@Nullable</span> Looper looper)</span> </span>&#123;<br>    mContext = context;<br>    mTN = <span class="hljs-keyword">new</span> TN(context.getPackageName(), looper);<br>    mTN.mY = context.getResources().getDimensionPixelSize(<br>            com.android.internal.R.dimen.toast_y_offset);<br>    mTN.mGravity = context.getResources().getInteger(<br>            com.android.internal.R.integer.config_toastDefaultGravity);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>主要就是构造了一个 TN 对象，计算了位置。</p>
<p>TN 的构造方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">TN(String packageName, <span class="hljs-meta">@Nullable</span> Looper looper) &#123;<br>    <span class="hljs-comment">// XXX This should be changed to use a Dialog, with a Theme.Toast</span><br>    <span class="hljs-comment">// defined that sets up the layout params appropriately.</span><br>    <span class="hljs-keyword">final</span> WindowManager.LayoutParams params = mParams;<br>    params.height = WindowManager.LayoutParams.WRAP_CONTENT;<br>    params.width = WindowManager.LayoutParams.WRAP_CONTENT;<br>    params.format = PixelFormat.TRANSLUCENT;<br>    params.windowAnimations = com.android.internal.R.style.Animation_Toast;<br>    params.type = WindowManager.LayoutParams.TYPE_TOAST;<br>    params.setTitle(<span class="hljs-string">&quot;Toast&quot;</span>);<br>    params.flags = WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON<br>            | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE<br>            | WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE;<br><br>    mPackageName = packageName;<br><br>    <span class="hljs-keyword">if</span> (looper == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// Use Looper.myLooper() if looper is not specified.</span><br>        looper = Looper.myLooper();<br>        <span class="hljs-keyword">if</span> (looper == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<br>                    <span class="hljs-string">&quot;Can&#x27;t toast on a thread that has not called Looper.prepare()&quot;</span>);<br>        &#125;<br>    &#125;<br>    mHandler = <span class="hljs-keyword">new</span> Handler(looper, <span class="hljs-keyword">null</span>) &#123;<br>        ...<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>设置了 LayoutParams 的初始值，在后面 show 的时候会用到，设置了包名和 Looper、Handler。</p>
<p>TN 是 App 中用于与 Notification Service 交互的对象，这里涉及到 Binder 和跨进程通信的知识，这块会在后面开新篇来讲解，这里可以简单地理解一下：Notification Service 是系统为了管理各种 App 的 Notification（包括 Toast）的服务，比如 Toast，由这个服务来统一维护一个待展示 Toast 队列，各 App 需要弹 Toast 的时候就将相关信息发送给这个服务，服务会将其加入队列，然后根据队列的情况，依次通知各 App 展示和隐藏 Toast。</p>
<p>接下来看看 show 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Show the view for the specified duration.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (mNextView == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;setView must have been called&quot;</span>);<br>    &#125;<br><br>    INotificationManager service = getService();<br>    String pkg = mContext.getOpPackageName();<br>    TN tn = mTN;<br>    tn.mNextView = mNextView;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        service.enqueueToast(pkg, tn, mDuration);<br>    &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>        <span class="hljs-comment">// Empty</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>调用了 INotificationManager 的 enqueueToast 方法，INotificationManager 是一个接口，其实现类在 NotificationManagerService 里，我们来看 enqueueToast 方法的实现：</p>
<p>文件 <a href="https://github.com/aosp-mirror/platform_frameworks_base/blob/master/services/core/java/com/android/server/notification/NotificationManagerService.java">platform_frameworks_base/services/core/java/com/android/server/notification/NotificationManagerService.java</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enqueueToast</span><span class="hljs-params">(String pkg, ITransientNotification callback, <span class="hljs-keyword">int</span> duration)</span></span><br><span class="hljs-function"></span>&#123;<br>    ...<br><br>    <span class="hljs-keyword">synchronized</span> (mToastQueue) &#123;<br>        ...<br>        <span class="hljs-keyword">try</span> &#123;<br>            ToastRecord record;<br>            <span class="hljs-keyword">int</span> index = indexOfToastLocked(pkg, callback);<br>            <span class="hljs-comment">// If it&#x27;s already in the queue, we update it in place, we don&#x27;t</span><br>            <span class="hljs-comment">// move it to the end of the queue.</span><br>            <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span>) &#123;<br>                record = mToastQueue.get(index);<br>                record.update(duration);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// Limit the number of toasts that any given package except the android</span><br>                <span class="hljs-comment">// package can enqueue.  Prevents DOS attacks and deals with leaks.</span><br>                <span class="hljs-keyword">if</span> (!isSystemToast) &#123;<br>                    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>                    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = mToastQueue.size();<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;N; i++) &#123;<br>                         <span class="hljs-keyword">final</span> ToastRecord r = mToastQueue.get(i);<br>                         <span class="hljs-keyword">if</span> (r.pkg.equals(pkg)) &#123;<br>                             count++;<br>                             <span class="hljs-keyword">if</span> (count &gt;= MAX_PACKAGE_NOTIFICATIONS) &#123;<br>                                 Slog.e(TAG, <span class="hljs-string">&quot;Package has already posted &quot;</span> + count<br>                                        + <span class="hljs-string">&quot; toasts. Not showing more. Package=&quot;</span> + pkg);<br>                                 <span class="hljs-keyword">return</span>;<br>                             &#125;<br>                         &#125;<br>                    &#125;<br>                &#125;<br><br>                Binder token = <span class="hljs-keyword">new</span> Binder();<br>                mWindowManagerInternal.addWindowToken(token, TYPE_TOAST, DEFAULT_DISPLAY);<br>                record = <span class="hljs-keyword">new</span> ToastRecord(callingPid, pkg, callback, duration, token);<br>                mToastQueue.add(record);<br>                index = mToastQueue.size() - <span class="hljs-number">1</span>;<br>                keepProcessAliveIfNeededLocked(callingPid);<br>            &#125;<br>            <span class="hljs-comment">// If it&#x27;s at index 0, it&#x27;s the current toast.  It doesn&#x27;t matter if it&#x27;s</span><br>            <span class="hljs-comment">// new or just been updated.  Call back and tell it to show itself.</span><br>            <span class="hljs-comment">// If the callback fails, this will remove it from the list, so don&#x27;t</span><br>            <span class="hljs-comment">// assume that it&#x27;s valid after this.</span><br>            <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) &#123;<br>                showNextToastLocked();<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            Binder.restoreCallingIdentity(callingId);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>主要就是使用调用方传来的包名、callback 和 duration 构造一个 ToastRecord，然后添加到 mToastQueue 中。如果在 mToastQueue 中已经存在该包名和 callback 的 Toast，则只更新其 duration。</p>
<p>这段代码里有一段可以回答我们的上一个问题 <code>Toast 数量有没有限制</code> 了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Limit the number of toasts that any given package except the android</span><br><span class="hljs-comment">// package can enqueue.  Prevents DOS attacks and deals with leaks.</span><br><span class="hljs-keyword">if</span> (!isSystemToast) &#123;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> N = mToastQueue.size();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;N; i++) &#123;<br>         <span class="hljs-keyword">final</span> ToastRecord r = mToastQueue.get(i);<br>         <span class="hljs-keyword">if</span> (r.pkg.equals(pkg)) &#123;<br>             count++;<br>             <span class="hljs-keyword">if</span> (count &gt;= MAX_PACKAGE_NOTIFICATIONS) &#123;<br>                 Slog.e(TAG, <span class="hljs-string">&quot;Package has already posted &quot;</span> + count<br>                        + <span class="hljs-string">&quot; toasts. Not showing more. Package=&quot;</span> + pkg);<br>                 <span class="hljs-keyword">return</span>;<br>             &#125;<br>         &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>即会计算 mToastQueue 里该包名的 Toast 数量，如果超过 50，则将当前申请加入队列的 Toast 抛弃掉。所以上一个问题的 <strong>结论是：Toast 队列里允许每个应用存在不超过 50 个 Toast。</strong></p>
<p>那么构造 ToastRecord 并加入 mToastQueue 之后是如何调度，控制显示和隐藏的呢？enqueueToast 方法里有个逻辑是如果当前列表里只有一个 ToastRecord，则调用 <code>showNextToastLocked</code>，看一下与该方法相关的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GuardedBy(&quot;mToastQueue&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">showNextToastLocked</span><span class="hljs-params">()</span> </span>&#123;<br>    ToastRecord record = mToastQueue.get(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">while</span> (record != <span class="hljs-keyword">null</span>) &#123;<br>        ...<br>        <span class="hljs-keyword">try</span> &#123;<br>            record.callback.show(record.token);<br>            scheduleTimeoutLocked(record);<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>            ...<br>            <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span>) &#123;<br>                mToastQueue.remove(index);<br>            &#125;<br>            ...<br>        &#125;<br>    &#125;<br>&#125;<br><br>...<br><br><span class="hljs-meta">@GuardedBy(&quot;mToastQueue&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">scheduleTimeoutLocked</span><span class="hljs-params">(ToastRecord r)</span></span><br><span class="hljs-function"></span>&#123;<br>    mHandler.removeCallbacksAndMessages(r);<br>    Message m = Message.obtain(mHandler, MESSAGE_TIMEOUT, r);<br>    <span class="hljs-keyword">long</span> delay = r.duration == Toast.LENGTH_LONG ? LONG_DELAY : SHORT_DELAY;<br>    mHandler.sendMessageDelayed(m, delay);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleTimeout</span><span class="hljs-params">(ToastRecord record)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (DBG) Slog.d(TAG, <span class="hljs-string">&quot;Timeout pkg=&quot;</span> + record.pkg + <span class="hljs-string">&quot; callback=&quot;</span> + record.callback);<br>    <span class="hljs-keyword">synchronized</span> (mToastQueue) &#123;<br>        <span class="hljs-keyword">int</span> index = indexOfToastLocked(record.pkg, record.callback);<br>        <span class="hljs-keyword">if</span> (index &gt;= <span class="hljs-number">0</span>) &#123;<br>            cancelToastLocked(index);<br>        &#125;<br>    &#125;<br>&#125;<br><br>...<br><br><span class="hljs-meta">@GuardedBy(&quot;mToastQueue&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cancelToastLocked</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    ToastRecord record = mToastQueue.get(index);<br>    <span class="hljs-keyword">try</span> &#123;<br>        record.callback.hide();<br>    &#125; <span class="hljs-keyword">catch</span> (RemoteException e) &#123;<br>        ...<br>    &#125;<br><br>    ToastRecord lastToast = mToastQueue.remove(index);<br>    mWindowManagerInternal.removeWindowToken(lastToast.token, <span class="hljs-keyword">true</span>, DEFAULT_DISPLAY);<br><br>    keepProcessAliveIfNeededLocked(record.pid);<br>    <span class="hljs-keyword">if</span> (mToastQueue.size() &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// Show the next one. If the callback fails, this will remove</span><br>        <span class="hljs-comment">// it from the list, so don&#x27;t assume that the list hasn&#x27;t changed</span><br>        <span class="hljs-comment">// after this point.</span><br>        showNextToastLocked(); <span class="hljs-comment">// 继续显示队列里的下一个 Toast</span><br>    &#125;<br>&#125;<br><br>...<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WorkerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span></span><br><span class="hljs-class"></span>&#123;<br>    ...<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">switch</span> (msg.what)<br>        &#123;<br>            <span class="hljs-keyword">case</span> MESSAGE_TIMEOUT:<br>                handleTimeout((ToastRecord)msg.obj);<br>                <span class="hljs-keyword">break</span>;<br>            ...<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>即首先调用 <code>record.callback.show(record.token)</code>，通知 App 展示该 Toast，然后根据 duration，延时发送一条超时消息 <code>MESSAGE_TIMEOUT</code>，WorkHandler 收到该消息后，调用 <code>cancelToastLocked</code> 通知应用隐藏该 Toast，并继续调用 <code>showNextToastLocked</code> 显示队列里的下一个 Toast。这样一个机制就保证了只要队列里有 ToastRecord，就能依次显示出来。</p>
<p>机制弄清楚了，再详细看一下应用接到通知 show 和 hide 一个 Toast 后是怎么做的：</p>
<p>文件 <a href="https://github.com/aosp-mirror/platform_frameworks_base/blob/master/core/java/android/widget/Toast.java">platform_frameworks_base/core/java/android/widget/Toast.java</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TN</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ITransientNotification</span>.<span class="hljs-title">Stub</span> </span>&#123;<br>    ...<br>    TN(String packageName, <span class="hljs-meta">@Nullable</span> Looper looper) &#123;<br>        ...<br>        mHandler = <span class="hljs-keyword">new</span> Handler(looper, <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(Message msg)</span> </span>&#123;<br>                <span class="hljs-keyword">switch</span> (msg.what) &#123;<br>                    <span class="hljs-keyword">case</span> SHOW: &#123;<br>                        IBinder token = (IBinder) msg.obj;<br>                        handleShow(token);<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">case</span> HIDE: &#123;<br>                        handleHide();<br>                        ...<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                    ...<br>                &#125;<br>            &#125;<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * schedule handleShow into the right thread</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(IBinder windowToken)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (localLOGV) Log.v(TAG, <span class="hljs-string">&quot;SHOW: &quot;</span> + <span class="hljs-keyword">this</span>);<br>        mHandler.obtainMessage(SHOW, windowToken).sendToTarget();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * schedule handleHide into the right thread</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hide</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (localLOGV) Log.v(TAG, <span class="hljs-string">&quot;HIDE: &quot;</span> + <span class="hljs-keyword">this</span>);<br>        mHandler.obtainMessage(HIDE).sendToTarget();<br>    &#125;<br><br>    ...<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleShow</span><span class="hljs-params">(IBinder windowToken)</span> </span>&#123;<br>        ...<br>                mWM.addView(mView, mParams);<br>        ...<br>    &#125;<br><br>    ...<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleHide</span><span class="hljs-params">()</span> </span>&#123;<br>        ...<br>                mWM.removeViewImmediate(mView);<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>显示过程：show 方法被远程调用后，先是发送了一个 SHOW 消息，接收到该消息后调用了 handleShow 方法，然后 <code>mWM.addView</code> 将该 View 添加到窗口。</p>
<p>隐藏过程：hide 方法被远程调用后，先是发送了一个 HIDE 消息，接收到该消息后调用了 handleHide 方法，然后 <code>mWM.removeViewImmediate</code> 将该 View 从窗口移除。</p>
<p><em>这里插播一条结论，就是前文留下的为什么调用 Toast 的线程线束之后没弹出的 Toast 就无法弹出了的问题，因为 Notification Service 通知应用进程显示或隐藏 Toast 时，使用的是 <code>mHandler.obtainMessage(SHOW).sendToTarget()</code> 与 <code>mHandler.obtainMessage(HIDE).sendToTarget()</code>，这个消息发出去后，Handler 对应线程没有在 <code>Looper.loop()</code> 过程里的话，就没有办法进入到 Handler 的 handleMessage 方法里去，自然也就无法调用显示和隐藏 View 的流程了。<code>Looper.loop()</code> 相关的知识点将在下篇讲解。</em></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="补充后的-Toast-知识点列表"><a href="#补充后的-Toast-知识点列表" class="headerlink" title="补充后的 Toast 知识点列表"></a>补充后的 Toast 知识点列表</h3><ol>
<li><p>Toast 不是 View，它用于帮助创建并展示包含一条小消息的 View；</p>
</li>
<li><p>它的设计理念是尽量不惹眼，但又能展示想让用户看到的信息；</p>
</li>
<li><p>被展示时，浮在应用界面之上；</p>
</li>
<li><p>永远不会获取到焦点；</p>
</li>
<li><p>大小取决于消息的长度；</p>
</li>
<li><p>超时后会自动消失；</p>
</li>
<li><p>可以自定义显示在屏幕上的位置（默认左右居中显示在靠近屏幕底部的位置）；</p>
</li>
<li><p>可以使用自定义布局，也只有在自定义布局的时候才需要直接调用 Toast 的构造方法，其它时候都是使用 makeText 方法来创建 Toast；</p>
</li>
<li><p>Toast 弹出后当前 Activity 会保持可见性和可交互性；</p>
</li>
<li><p>使用 <code>cancel</code> 方法可以立即将已显示的 Toast 关闭，让未显示的 Toast 不再显示；</p>
</li>
<li><p>Toast 也算是一个「通知」，如果弹出状态消息后期望得到用户响应，应该使用 Notification；</p>
</li>
<li><p>Toast 的超时时间为 LENGTH_SHORT 对应 2 秒，LENGTH_LONG 对应 3.5 秒；</p>
</li>
<li><p>不能通过 Toast 类的公开方法直接弹一个时间超长的 Toast；</p>
</li>
<li><p>应用在后台时可以调用 Toast 并正常弹出；</p>
</li>
<li><p>Toast 队列里允许单个应用往里添加 50 个 Toast，超出的将被丢弃。</p>
</li>
</ol>
<h3 id="遗留知识点"><a href="#遗留知识点" class="headerlink" title="遗留知识点"></a>遗留知识点</h3><p>本篇涉及到了一些需要进一步了解的知识点，在后续的篇章中会依次解读：</p>
<ol>
<li><p>Handler、Looper 和 MessageQueue</p>
</li>
<li><p>WindowManager</p>
</li>
<li><p>Binder 与跨进程通信</p>
</li>
</ol>
<h3 id="本篇用到的源码分析方法"><a href="#本篇用到的源码分析方法" class="headerlink" title="本篇用到的源码分析方法"></a>本篇用到的源码分析方法</h3><ol>
<li><p>查找关键变量被引用的地方；</p>
</li>
<li><p>按方法调用堆栈一层层逻辑跟踪与分析；</p>
</li>
<li><p>使用 git blame 查看关键代码行的变更日志；</p>
</li>
</ol>
<h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>到此，上面提到的几个问题都已经解答完毕，对 Toast 源码的分析也告一段落。</p>
<p>写这篇文章花费的时间比较长，所以并不能按照预计的节奏更新，这里表示抱歉。另外，各位如果有耐心读到这里，觉得本文的思路是否清晰，是否能跟随文章的节奏理解一些东西？因为我也在摸索写这类文章的组织形式，所以也希望能收到反馈和建议，以作改进，先行谢过。</p>
<hr>
<p>最后，照例要安利一下我的微信公众号「闷骚的程序员」，扫码关注，接收 rtfsc-android 的最近更新。</p>
<div align="center"><img width="192px" height="192px" src="https://mazhuang.org/assets/images/qrcode.jpg"/></div>

]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RTFSC, Android, Toast</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员节的过节姿势大全</title>
    <url>/2017/10/24/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/poses/</url>
    <content><![CDATA[<p>今天是 10 月 24 日，不知道你的朋友圈有没有被程序员节刷屏，反正我的是被刷了。</p>
<p>看到 1024 这个数字，相信很多人都怀着特别的感情，比如我，游泳不会止步于 1000 米，肯定会补 24 米凑个整，跑步如果跑到 10 公里，那一定再多跑个 0.24 出来。</p>
<p>搞不好还会想起那些年追过的社区，嗟叹一下逝去的青春：</p>
<p><img src="/images/blog/1024-gold.png"></p>
<p>那么，这样一个特别的日子，我的交游圈里大家是以怎样的姿势度过的呢？</p>
<h2 id="程序员们怎么过"><a href="#程序员们怎么过" class="headerlink" title="程序员们怎么过"></a>程序员们怎么过</h2><h3 id="聚众自黑型"><a href="#聚众自黑型" class="headerlink" title="聚众自黑型"></a>聚众自黑型</h3><p>作为互联网上最擅长自黑自嘲，以至于现在不明真相的群众都把他们的自黑当真话听的群体，这一天怎么会甘于寂寞，今天微信群里的画风是这样的：</p>
<p><img src="/images/blog/overtime.jpeg"></p>
<p><img src="/images/blog/3w-programmer.jpeg"></p>
<p><img src="/images/blog/fake.jpeg"></p>
<p>（from 掘金.专栏作者群）</p>
<p>大家纷纷表示自己是个假程序员。</p>
<h3 id="感-xuan-恩-yao-公司关怀型"><a href="#感-xuan-恩-yao-公司关怀型" class="headerlink" title="感(xuan)恩(yao)公司关怀型"></a>感(xuan)恩(yao)公司关怀型</h3><p>以重视员工工作体验著称的互联网公司们也没闲着，为程序员们推出了各种福利，所以今天朋友圈里的画风是这样的：</p>
<p><img src="/images/blog/1024-sogou.jpeg"></p>
<p><img src="/images/blog/1024-meituan.jpeg"></p>
<p><img src="/images/blog/1024-kuaishou.jpeg"></p>
<p>还有程序员鼓励师出没：</p>
<p><img src="/images/blog/encourage.jpeg"></p>
<p>（from 掘金.专栏作者群）</p>
<h2 id="非程序员们怎么过"><a href="#非程序员们怎么过" class="headerlink" title="非程序员们怎么过"></a>非程序员们怎么过</h2><p><img src="/images/blog/doubt.jpeg"></p>
<p>关我屁事？</p>
<h2 id="公众号们怎么过"><a href="#公众号们怎么过" class="headerlink" title="公众号们怎么过"></a>公众号们怎么过</h2><p>也算一年一度的节，相关的公众号们也没闲着。</p>
<h3 id="科普型"><a href="#科普型" class="headerlink" title="科普型"></a>科普型</h3><p><img src="/images/blog/kepu.jpeg"></p>
<p>（知晓程序员）</p>
<h3 id="在世界中心呼唤爱型"><a href="#在世界中心呼唤爱型" class="headerlink" title="在世界中心呼唤爱型"></a>在世界中心呼唤爱型</h3><p><img src="/images/blog/request-love.jpeg"></p>
<p>（Java 程序员联盟）</p>
<h3 id="趁势搞活动型"><a href="#趁势搞活动型" class="headerlink" title="趁势搞活动型"></a>趁势搞活动型</h3><p><img src="/images/blog/1024-vote.jpeg"></p>
<p>（InfoQ）</p>
<p><img src="/images/blog/release-books.jpeg"></p>
<p>（码农翻身）</p>
<h3 id="欠揍型"><a href="#欠揍型" class="headerlink" title="欠揍型"></a>欠揍型</h3><p><img src="/images/blog/qianzou.jpeg"></p>
<p>（微信派）</p>
<h2 id="掘金怎么过"><a href="#掘金怎么过" class="headerlink" title="掘金怎么过"></a>掘金怎么过</h2><p>文首的图就是掘金社区去年 1024 出品，今年他们录了一首歌，链接：</p>
<p><a href="https://juejin.im/post/59ee13d7f265da43284006e3">老子今天不加班，程序员也需要自由</a></p>
<h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>好了，夜已深，打完收工。祝 WE 程序员们少熬夜，保住我们的发际线。</p>
]]></content>
      <categories>
        <category>博客文章</category>
      </categories>
      <tags>
        <tag>1024, 程序员节</tag>
      </tags>
  </entry>
  <entry>
    <title>发布一款光谷社区第三方 Android App</title>
    <url>/2017/10/14/Andriod/guanggoo-android-app/</url>
    <content><![CDATA[<p>在过去的一个来月，我利用业余时间做了一款光谷社区的第三方 Android 客户端。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>光谷社区是我在决定离开帝都回武汉的过程中，及回武汉之后关注得较多的武汉本土社区，网站 <a href="http://guanggoo.com/">http://guanggoo.com</a> 自己的 description 是这样的：</p>
<blockquote>
<p>光谷社区是源自光谷的高端社交网络，这里有关于创业、创意、IT、金融等最热话题的交流，也有招聘问答、活动交友等最新资讯的发布。</p>
</blockquote>
<p>描述得还比较准确。我觉得身在光谷，或者心系光谷的童鞋们可以关注一下。</p>
<h2 id="发布详情"><a href="#发布详情" class="headerlink" title="发布详情"></a>发布详情</h2><p>目前支持特性：</p>
<ol>
<li>登录</li>
<li>首页主题列表（三种视图）</li>
<li>主题详情 / 评论列表</li>
<li>节点列表 / 节点主题列表</li>
<li>评论 / 艾特用户</li>
<li>分享主题链接</li>
<li>发表新主题</li>
<li>查看用户信息</li>
</ol>
<p>源码放在 GitHub 上：</p>
<p><a href="https://github.com/mzlogin/guanggoo-android">https://github.com/mzlogin/guanggoo-android</a></p>
<p>部分界面截图：</p>
<p><img src="https://mazhuang.org/guanggoo-android/screenshots/topic-list.png"></p>
<p><img src="https://mazhuang.org/guanggoo-android/screenshots/topic-detail.png"></p>
<p><img src="https://mazhuang.org/guanggoo-android/screenshots/nodes-list.png"></p>
<p><img src="https://mazhuang.org/guanggoo-android/screenshots/drawer.png"></p>
<p>更多的功能开发、完善以及优化还在进行中，也希望看到的朋友们下载试用起来，多提建议多交流。</p>
<p>好吧，啰嗦了这么多，哪里能够下载得到呢？</p>
<p><strong>APK 下载链接</strong></p>
<p>（如果是在微信里看到这里，建议长按后复制链接到浏览器打开）</p>
<p><a href="https://mazhuang.org/guanggoo-android/guanggoo-lastest.apk">https://mazhuang.org/guanggoo-android/guanggoo-lastest.apk</a></p>
<p>百度网盘备用链接：</p>
<p><a href="https://pan.baidu.com/s/1pL0t1Zd">https://pan.baidu.com/s/1pL0t1Zd</a></p>
<p><strong>扫描或识别二维码下载</strong></p>
<p>（如果使用微信识别二维码不能开始下载，还是复制上方的链接到浏览器打开下载吧）</p>
<div align="center"><img width="192px" height="192px" src="https://mazhuang.org/guanggoo-android/qrcode.png"/></div>

<h2 id="为什么会做这个"><a href="#为什么会做这个" class="headerlink" title="为什么会做这个"></a>为什么会做这个</h2><ol>
<li><p>社区目前只有 Web 页面，做了移动端适配，体验也还不错。不过作为一个打开频率较高的应用，我还是希望能用上 App；</p>
</li>
<li><p>之前偶然在社区的几个帖子里也有一些用户问到是否有 App 可用，都没有了下文，可以满足一下这部分用户的需求；</p>
</li>
<li><p>作为一个长期维护的业余项目，更深刻地体会 App 开发的整个生命周期，也将一些想学习的技术应用到实际项目中；</p>
</li>
<li><p>借此机会认识一下光谷技术圈子里志趣相投的朋友。</p>
</li>
</ol>
<h2 id="前缘后续"><a href="#前缘后续" class="headerlink" title="前缘后续"></a>前缘后续</h2><p>上 GitHub 搜索 guanggoo 出来的结果很少，发现有一个 <a href="https://github.com/cauil/react-native-guanggoo">cauil/react-native-guanggoo</a> 的项目适配了 iOS，独缺 Android 客户端，于是决定自己写一个。要不是那一阵刚好闹 Facebook 开源许可证风波，让人没有学习 React Native 的信心和欲望，也许我就学点 React Native 在这位仁兄的基础上开发了。</p>
<p>经过几周业余时间和十一长假期间的开发，目前完成度不算特别高，但常用的功能已经基本可用了，当然还有一些功能比如注册、帖子里的外部链接打开等，我是先抛给了系统浏览器。想着只埋头自己开发也比较枯燥，决定先放出一个版本来让网友们吐吐槽，提提意见，应该能做得更好。</p>
<p>PS: 本文非软文，也没有收取光谷社区任何好处，请光谷社区嘴炮管理员看到这里帮我开通个 VIP，我的社区 ID 是 mzlogin，:-P。</p>
<hr>
<p>好了，最后照例安利一下我自己的微信公众号，近期专注 Java、Android 相关的技术分享，如果你感兴趣，可以关注一下接收最新动态。</p>
<div align="center"><img width="192px" height="192px" src="https://mazhuang.org/assets/images/qrcode.jpg"/></div>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android, 光谷社区</tag>
      </tags>
  </entry>
  <entry>
    <title>从一个 NullPointerException 探究 Java 的自动装箱拆箱机制</title>
    <url>/2017/08/20/Java/java-auto-boxing-unboxing/</url>
    <content><![CDATA[<p>前天遇到了一个 NullPointerException，触发的代码类似下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">long</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Long value = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">// ...</span><br>        test(value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>main 方法里的代码实际上相当于调用 <code>test(null);</code>，为什么不直接这样写呢？因为编译不过，会报 <code>错误: 不兼容的类型: &lt;空值&gt;无法转换为long</code>。</p>
<h2 id="抛出问题"><a href="#抛出问题" class="headerlink" title="抛出问题"></a>抛出问题</h2><p>运行时提示 <code>test(value);</code> 这一行抛出 NullPointerException，但是看着以上代码会有些许困惑：以上代码里一个对象方法都没有调用啊，NullPointerException 从何而来？</p>
<h2 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h2><p>这时，如果留意到 test 方法接受的参数是 long 类型，而我们传入的是 Long 类型（虽然其实是 null），就会想到这会经历一次从类型 Long 到基本数据类型 long 的自动拆箱过程，那会不会是这个过程中抛出的 NullPointerException 呢？因为以前只知道 Java 为一些基础数据类型与对应的包装器类型之间提供了自动装箱拆箱机制，而并不知这机制的具体实现方法是怎么样的，正好学习一下。</p>
<p>用命令 <code>javap -c Test</code> 将以上代码编译出的 Test.class 文件进行反汇编，可以看到如下输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Compiled from <span class="hljs-string">&quot;Test.java&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Test</span><span class="hljs-params">()</span></span>;<br>    Code:<br>       <span class="hljs-number">0</span>: aload_0<br>       <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span>                  <span class="hljs-comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>       <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-keyword">long</span>)</span></span>;<br>    Code:<br>       <span class="hljs-number">0</span>: lload_0<br>       <span class="hljs-number">1</span>: <span class="hljs-function">lreturn</span><br><span class="hljs-function"></span><br><span class="hljs-function">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>;<br>    Code:<br>       <span class="hljs-number">0</span>: aconst_null<br>       <span class="hljs-number">1</span>: astore_1<br>       <span class="hljs-number">2</span>: aload_1<br>       <span class="hljs-number">3</span>: invokevirtual #<span class="hljs-number">2</span>                  <span class="hljs-comment">// Method java/lang/Long.longValue:()J</span><br>       <span class="hljs-number">6</span>: invokestatic  #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Method test:(J)J</span><br>       <span class="hljs-number">9</span>: pop2<br>      <span class="hljs-number">10</span>: <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>从以上字节码及对应的注释可以看出，<code>test(value);</code> 这一行被编译后等同于如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">long</span> primitive = value.longValue();<br>test(promitive);<br></code></pre></td></tr></table></figure>

<p>相比实际代码，多出的 <code>long primitive = value.longValue();</code> 这一行看起来就是自动拆箱的过程了，而我们传入的 <code>value</code> 为 null，<code>value.longValue()</code> 会抛出 NullPointerException，一切就解释得通了。用更简洁的代码表达出了更丰富的含义，这就是所谓的语法糖了。</p>
<h2 id="证实猜想"><a href="#证实猜想" class="headerlink" title="证实猜想"></a>证实猜想</h2><p>那么我们上面得出的自动拆箱机制的结论是否正确呢？选择一种其它基本数据类型，比如 int，来佐证一下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Integer value = <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">int</span> primitive = value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>反汇编后对应的字节码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Compiled from <span class="hljs-string">&quot;Test.java&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Test</span><span class="hljs-params">()</span></span>;<br>    Code:<br>       <span class="hljs-number">0</span>: aload_0<br>       <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span>                  <span class="hljs-comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>       <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>;<br>    Code:<br>       <span class="hljs-number">0</span>: bipush        <span class="hljs-number">10</span><br>       <span class="hljs-number">2</span>: invokestatic  #<span class="hljs-number">2</span>                  <span class="hljs-comment">// Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span><br>       <span class="hljs-number">5</span>: astore_1<br>       <span class="hljs-number">6</span>: aload_1<br>       <span class="hljs-number">7</span>: invokevirtual #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Method java/lang/Integer.intValue:()I</span><br>      <span class="hljs-number">10</span>: istore_2<br>      <span class="hljs-number">11</span>: <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>由以上字节码我们可以印证下文里的知识点了。</p>
<h2 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h2><p>自动装箱与拆箱是 Java 1.5 引入的新特性，是一种语法糖。</p>
<p>在此之前，我们要创建一个值为 10 的 Integer 对象，只能写作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Integer value = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure>

<p>而现在，我们可以更方便地写为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Integer value = <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>

<h3 id="定义与实现机制"><a href="#定义与实现机制" class="headerlink" title="定义与实现机制"></a>定义与实现机制</h3><p><strong>自动装箱</strong>，是指从基本数据类型值到其对应的包装类对象的自动转换。比如 <code>Integer value = 10;</code>，是通过调用 Integer.valueOf 方法实现转换的。</p>
<p><strong>自动拆箱</strong>，是指从包装类对象到其对应的基本数据类型值的自动转换。比如 <code>int primitive = value;</code>，是通过调用 Integer.intValue 方法实现转换的。</p>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类型</th>
<th>装箱方法</th>
<th>拆箱方法</th>
</tr>
</thead>
<tbody><tr>
<td>boolean</td>
<td>Boolean</td>
<td>Boolean.valueOf(boolean)</td>
<td>Boolean.booleanValue()</td>
</tr>
<tr>
<td>byte</td>
<td>Byte</td>
<td>Byte.valueOf(byte)</td>
<td>Byte.byteValue()</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
<td>Character.valueOf(char)</td>
<td>Character.charValue()</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
<td>Short.valueOf(short)</td>
<td>Short.shortValue()</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
<td>Integer.valueOf(int)</td>
<td>Integer.intValue()</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
<td>Long.valueOf(long)</td>
<td>Long.longValue()</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
<td>Float.valueOf(float)</td>
<td>Float.floatValue()</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
<td>Double.valueOf(double)</td>
<td>Double.doubleValue()</td>
</tr>
</tbody></table>
<h3 id="发生时机"><a href="#发生时机" class="headerlink" title="发生时机"></a>发生时机</h3><p>自动装箱与拆箱主要发生在以下四种时机：</p>
<ol>
<li><p>赋值时；</p>
</li>
<li><p>比较时；</p>
</li>
<li><p>算术运算时；</p>
</li>
<li><p>方法调用时。</p>
</li>
</ol>
<h3 id="常见应用场景"><a href="#常见应用场景" class="headerlink" title="常见应用场景"></a>常见应用场景</h3><p><strong>Case 1:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Integer value = <span class="hljs-number">10</span>; <span class="hljs-comment">// 自动装箱（赋值时）</span><br><br><span class="hljs-keyword">int</span> primitive = value; <span class="hljs-comment">// 自动拆箱（方法调用时）</span><br></code></pre></td></tr></table></figure>

<p><strong>Case 2:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Integer value = <span class="hljs-number">1000</span>;<br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">if</span> (value &lt;= <span class="hljs-number">1000</span>) &#123; <span class="hljs-comment">// 自动拆箱（比较时）</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Case 3:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>list.add(<span class="hljs-number">10</span>); <span class="hljs-comment">// 自动装箱（方法调用时）</span><br><br><span class="hljs-keyword">int</span> i = list.get(<span class="hljs-number">0</span>); <span class="hljs-comment">// 自动拆箱（赋值时）</span><br></code></pre></td></tr></table></figure>

<p><em>注：集合（Collections）里不能直接放入原始类型，集合只接收对象。</em></p>
<p><strong>Case 4:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ThreadLocal&lt;Integer&gt; local = <span class="hljs-keyword">new</span> ThreadLocal&lt;Integer&gt;();<br>local.set(<span class="hljs-number">10</span>); <span class="hljs-comment">// 自动装箱（方法调用时）</span><br><br><span class="hljs-keyword">int</span> i = local.get(); <span class="hljs-comment">// 自动拆箱（赋值时）</span><br></code></pre></td></tr></table></figure>

<p><em>注：ThreadLocal 不能存储基本数据类型，只接收引用类型。</em></p>
<p><strong>Case 5:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun1</span><span class="hljs-params">(Integer value)</span> </span>&#123;<br>    <span class="hljs-comment">//</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>    <span class="hljs-comment">//</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    fun1(<span class="hljs-number">10</span>); <span class="hljs-comment">// 自动装箱（方法调用时）</span><br><br>    Integer value = <span class="hljs-number">10</span>;<br>    fun2(value); <span class="hljs-comment">// 自动拆箱（方法调用时）</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Case 6:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Integer v1 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">10</span>);<br>Integer v2 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">20</span>);<br><span class="hljs-keyword">int</span> v3 = <span class="hljs-number">30</span>;<br><br><span class="hljs-keyword">int</span> sum = v1 + v2; <span class="hljs-comment">// 自动拆箱（算术运算时）</span><br>sum = v1 + <span class="hljs-number">30</span>; <span class="hljs-comment">// 自动拆箱（算术运算时）</span><br></code></pre></td></tr></table></figure>

<h3 id="相关知识点"><a href="#相关知识点" class="headerlink" title="相关知识点"></a>相关知识点</h3><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p>除 <code>==</code> 以外，包装类对象与基本数据类型值的比较，包装类对象与包装类对象之间的比较，都是自动拆箱后对基本数据类型值进行比较，所以，<strong>要注意这些类型间进行比较时自动拆箱可能引发的 NullPointerException</strong>。</p>
<p><code>==</code> 比较特殊，因为可以用于判断左右是否为同一对象，所以两个包装类对象之间 <code>==</code>，会用于判断是否为同一对象，而不会进行自动拆箱操作；包装类对象与基本数据类型值之间 <code>==</code>，会自动拆箱。</p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Integer v1 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">10</span>);<br>Integer v2 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">20</span>);<br><br><span class="hljs-keyword">if</span> (v1 &lt; v2) &#123; <span class="hljs-comment">// 自动拆箱</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">if</span> (v1 == v2) &#123; <span class="hljs-comment">// 不拆箱</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">if</span> (v1 == <span class="hljs-number">10</span>) &#123; <span class="hljs-comment">// 自动拆箱</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>Java 为整型值包装类 Byte、Character、Short、Integer、Long 设置了缓存，用于存储一定范围内的值，详细如下：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>缓存值范围</th>
</tr>
</thead>
<tbody><tr>
<td>Byte</td>
<td>-128 ~ 127</td>
</tr>
<tr>
<td>Character</td>
<td>0 ~ 127</td>
</tr>
<tr>
<td>Short</td>
<td>-128 ~ 127</td>
</tr>
<tr>
<td>Integer</td>
<td>-128 ~ 127（可配置）</td>
</tr>
<tr>
<td>Long</td>
<td>-128 ~ 127</td>
</tr>
</tbody></table>
<p>在一些情况下，比如自动装箱时，如果值在缓存值范围内，将不创建新对象，直接从缓存里取出对象返回，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Integer v1 = <span class="hljs-number">10</span>;<br>Integer v2 = <span class="hljs-number">10</span>;<br>Integer v3 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">10</span>);<br>Integer v4 = <span class="hljs-number">128</span>;<br>Integer v5 = <span class="hljs-number">128</span>;<br>Integer v6 = Integer.valueOf(<span class="hljs-number">10</span>);<br><br>System.out.println(v1 == v2); <span class="hljs-comment">// true</span><br>System.out.println(v1 == v3); <span class="hljs-comment">// false</span><br>System.out.println(v4 == v5); <span class="hljs-comment">// false</span><br>System.out.println(v1 == v6); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<p><strong>缓存实现机制：</strong></p>
<p>这里使用了设计模式享元模式。</p>
<p>以 Short 类实现源码为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Short</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Number</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Short</span>&gt; </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShortCache</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ShortCache</span><span class="hljs-params">()</span></span>&#123;&#125;<br><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Short cache[] = <span class="hljs-keyword">new</span> Short[-(-<span class="hljs-number">128</span>) + <span class="hljs-number">127</span> + <span class="hljs-number">1</span>];<br><br>        <span class="hljs-keyword">static</span> &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; cache.length; i++)<br>                cache[i] = <span class="hljs-keyword">new</span> Short((<span class="hljs-keyword">short</span>)(i - <span class="hljs-number">128</span>));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Short <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">short</span> s)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> offset = <span class="hljs-number">128</span>;<br>        <span class="hljs-keyword">int</span> sAsInt = s;<br>        <span class="hljs-keyword">if</span> (sAsInt &gt;= -<span class="hljs-number">128</span> &amp;&amp; sAsInt &lt;= <span class="hljs-number">127</span>) &#123; <span class="hljs-comment">// must cache</span><br>            <span class="hljs-keyword">return</span> ShortCache.cache[sAsInt + offset];<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Short(s);<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在第一次调用到 <code>Short.valueOf(short)</code> 方法时，将创建 -128 ~ 127 对应的 256 个对象缓存到堆内存里。</p>
<p>这种设计，在频繁用到这个范围内的值的时候效率较高，可以避免重复创建和回收对象，否则有可能闲置较多对象在内存中。</p>
<h4 id="使用不当的情况"><a href="#使用不当的情况" class="headerlink" title="使用不当的情况"></a>使用不当的情况</h4><p>自动装箱和拆箱这种语法糖为我们写代码带来了简洁和便利，但如果使用不当，也有可能带来负面影响。</p>
<ol>
<li><p>性能的损耗</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Integer sum = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1000</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>    <span class="hljs-comment">// 1. 先对 sum 进行自动拆箱</span><br>    <span class="hljs-comment">// 2. 加法</span><br>    <span class="hljs-comment">// 3. 自动装箱赋值给 sum，无法命中缓存，会 new Integer(int)</span><br>    sum = sum + i;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在循环过程中会分别调用 4000 次 Integer.intValue() 和 Integer.valueOf(int)，并 new 4000 个 Integer 对象，而这些操作将 sum 的类型改为 int 即可避免，节约运行时间和空间，提升性能。</p>
</li>
<li><p>java.lang.NullPointerException</p>
<p>尝试对一个值为 null 的包装类对象进行自动拆箱，就有可能造成 NullPointerException。</p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Integer v1 = <span class="hljs-keyword">null</span>;<br><span class="hljs-keyword">int</span> v2 = v1; <span class="hljs-comment">// NullPointerException</span><br><br><span class="hljs-keyword">if</span> (v1 &gt; <span class="hljs-number">10</span>) &#123; <span class="hljs-comment">// NullPointerException</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-keyword">int</span> v3 = v1 + <span class="hljs-number">10</span>; <span class="hljs-comment">// NullPointerException</span><br></code></pre></td></tr></table></figure>

<p>还有一种更隐蔽的情形，感谢 <a href="https://www.zhihu.com/people/zhou-shao-68-55">@周少</a> 补充：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> value = <span class="hljs-keyword">true</span> ? <span class="hljs-keyword">null</span> : <span class="hljs-number">1</span>; <span class="hljs-comment">// NullPointerException</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这实际上还是对一个值为 null 的 Long 类型进行自动拆箱，反汇编代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Compiled from <span class="hljs-string">&quot;Test.java&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Test</span><span class="hljs-params">()</span></span>;<br>    Code:<br>       <span class="hljs-number">0</span>: aload_0<br>       <span class="hljs-number">1</span>: invokespecial #<span class="hljs-number">1</span>                  <span class="hljs-comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br>       <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span><br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(java.lang.String[])</span></span>;<br>    Code:<br>       <span class="hljs-number">0</span>: aconst_null<br>       <span class="hljs-number">1</span>: checkcast     #<span class="hljs-number">2</span>                  <span class="hljs-comment">// class java/lang/Long</span><br>       <span class="hljs-number">4</span>: invokevirtual #<span class="hljs-number">3</span>                  <span class="hljs-comment">// Method java/lang/Long.longValue:()J</span><br>       <span class="hljs-number">7</span>: lstore_1<br>       <span class="hljs-number">8</span>: <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://droidyue.com/blog/2015/04/07/autoboxing-and-autounboxing-in-java/index.html">Java中的自动装箱与拆箱</a></li>
<li><a href="http://www.cnblogs.com/dolphin0520/p/3780005.html">深入剖析Java中的装箱和拆箱</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java, 自动装箱, 自动拆箱</tag>
      </tags>
  </entry>
  <entry>
    <title>读书：追风筝的人</title>
    <url>/2017/02/19/%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/the-kite-runner/</url>
    <content><![CDATA[<blockquote>
<p>《追风筝的人》确实是一部相当优秀而又深刻的作品。——小别老师</p>
</blockquote>
<p><img src="/images/blog/the-kite-runner.png"></p>
<p>图 1. 《追风筝的人》/卡勒德.胡赛尼 封面</p>
<p>当在我用一整个下午读完这本书，印象最深的句子是下面这两个：</p>
<blockquote>
<p>那儿有再次成为好人的路。</p>
</blockquote>
<blockquote>
<p>为你，千千万万遍。</p>
</blockquote>
<p>这样的句子翻译之后总觉得少了点意思，感受下原文：</p>
<blockquote>
<p>There is a way to be good again.</p>
</blockquote>
<blockquote>
<p>For you, a thousand times over.</p>
</blockquote>
<p>就是这两个简单的句子，承载了故事的主要线索——自我救赎与献身。</p>
<h2 id="剧透"><a href="#剧透" class="headerlink" title="剧透"></a>剧透</h2><p>小说其实讲述了一个非常简单的故事：</p>
<p>一心只想讨父亲欢心的少爷阿米尔与他忠诚的仆人哈桑从小一起长大，哈桑总是为阿米尔背锅，还在危急关头为他挺身而出，但是在哈桑被反社会分子逼到巷角时，阿米尔却眼睁睁地看着强暴发生，什么都没有做。</p>
<p>阿米尔后来无法承受对自己懦弱的自责所带来的痛苦，就设计逼走了哈桑。随后阿富汗发生战乱，阿米尔随父亲逃到美国讨生活，有了美丽的妻子和体面的职业，过上了岁月静好的生活。</p>
<p>但是多年以后，父亲旧时好友告诉了他一个惊天秘密：原来哈桑是他同父异母的弟弟。虽然被一直以来形象正面的父亲蒙蔽多年给心灵带来的冲击巨大，但为了救赎自己少年时的背叛，他还是冒着生命危险去营救弟弟唯一的骨肉，最后果然有了生命危险，他也为自己多年前的「罪行」受到了「惩罚」，完成了自我救赎。一番波折之后，带着弟弟的骨肉回到了美国。</p>
<h2 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h2><h3 id="整体评价"><a href="#整体评价" class="headerlink" title="整体评价"></a>整体评价</h3><p>对于我这样的俗人来说，一部小说或者讲故事的电影优秀与否其实很好判断：</p>
<ol>
<li><p>看完之后能否比较容易地复述整个故事。</p>
</li>
<li><p>不为了制造戏剧冲突而夸大其词，造成情节和情感脱线。</p>
</li>
<li><p>能让人在听故事之余，在人性或亲情等方面产生更深刻的认识。</p>
</li>
</ol>
<p>从这几点来讲，《追风筝的人》都不失为一部好作品。</p>
<p>下面分几个方面来记录一下我个人的理解：</p>
<h3 id="哈桑"><a href="#哈桑" class="headerlink" title="哈桑"></a>哈桑</h3><p>哈桑是忠诚的，一辈子都在「献身」，但他却因此成为故事里悲剧部分的主要载体。</p>
<p>少爷出主意恶作剧时，他负责背锅；少爷受欺负时，他负责挡枪；自己遭受暴行时，少爷袖手旁观，但他却依然不变初心；少爷想要激怒他来减轻自己的负罪感时，默默承受；少爷栽赃给他时，波澜不惊地应承下来；直至最后，都是为了守护少爷的房子而死。</p>
<p>他让我想起我们小学时接受思想品德教育时，「舍己为人」、「先人后己」和「毫不利己，专门利人」这些词汇，我们可以逐步跳脱出来，而身处那个环境的哈桑——少爷说，「哈桑从未拒绝我任何事情」。</p>
<blockquote>
<p>但在你为他献身之前，你想过吗？他会为你献身吗？</p>
</blockquote>
<p>他对少爷怀着的是一种我无法理解的感情。</p>
<h3 id="父亲"><a href="#父亲" class="headerlink" title="父亲"></a>父亲</h3><p>在大部分时候，他是一个令人敬佩的形象。</p>
<p>他乐善好施，不屈从世俗与宗教，选择自己认为对的路，并且将生活经营得有声有色；他心怀高尚的情操，面对俄国士兵的枪杆也毫不退缩，靠自己赢得所有人的尊敬；即使逃到美国，也只靠自己双手劳作，拒绝靠政府的救济来生存。</p>
<p>他对世间罪行的概括：</p>
<blockquote>
<p>罪行只有一种，那就是盗窃，其它罪行都是盗窃的变种。当你杀害一个人，你偷走一条性命，你偷走他妻子身为人妇的权利，夺走他子女的父亲。当你说谎，你偷走别人知道真相的权利。当你诈骗，你偷走公平的权利。</p>
</blockquote>
<p>在阅读他的事迹的时候，我常在想，原来这样的人，真的存在。</p>
<p>他这一生也许只做过一件羞耻的错事，那就是给阿米尔带来了一个同父异母的兄弟。所以当我看到这一点，受到的冲击是巨大的，可以想见阿米尔为何会因此而崩溃。</p>
<p>他展现在大伙面前的正面的神迹般的一生，也是对这唯一一件错事的自我救赎。</p>
<h3 id="阿米尔"><a href="#阿米尔" class="headerlink" title="阿米尔"></a>阿米尔</h3><p>故事的绝对主线，一个懦弱的孩子，要不是在父亲，哈桑，和好些其它人的保护之下，我很怀疑他能顺利长大。小时候的他，身上充斥着各种他自己的察觉或未察觉的阴暗面。</p>
<p>他与哈桑的一段对话让我印象深刻：</p>
<blockquote>
<p>「我骗过你吗，阿米尔少爷？」</p>
<p>「我不知道，你会骗我吗？」</p>
<p>「我宁愿吃泥巴也不会骗你。」</p>
<p>「真的吗？你会那样做？」</p>
<p>「做什么？」</p>
<p>「如果我让你吃泥巴，你会吃吗？」</p>
<p>「如果你要求，我会的。不过我怀疑，你是否会让我那么做。你会吗，阿米尔少爷？」</p>
</blockquote>
<p>阿塞夫是反社会，但是他对阿米尔的总结却也并不见得有多偏颇：</p>
<blockquote>
<p>为什么他跟客人玩总不喊上你？为什么他总是在没有人的时候才理睬你？我告诉你为什么，哈扎拉人。因为对他来说，你什么都不是，只是一只丑陋的宠物。一种他无聊的时候可以玩的东西，一种他发怒的时候可以踢开的东西。</p>
</blockquote>
<p>阿米尔小时候拼命想得到父亲的认可与亲近，而哈桑却在不经意间就能获得，所以一定程度上讲，他是嫉妒哈桑的。</p>
<p>他了解哈桑对自己的感情与忠诚，并且利用和背叛了它，却又受自己的良心煎熬，毕竟「一直以来，你对自己太严苛了」，所以在二十五年后，冒着生命危险也要回到故乡去带回索拉博，名义上是援救这个孩子，实际只为了完成那一场自我救赎。只是与他受人尊敬坚毅果敢的父亲不同，他的这场救赎来得实在太晚。</p>
<h3 id="阿富汗"><a href="#阿富汗" class="headerlink" title="阿富汗"></a>阿富汗</h3><p>这个国度以前在我的印象里真的只有连年战乱，塔利班，火箭弹。</p>
<p>现在，脑海里对它的曾经的样子，经历的历史进程，国民遭受的苦难有了更具象的刻画，也许有一天，我会去查更多关于它的资料，只为理解这个世界上真的有这样一个地方，它的人民真的生活在这样的环境里，而它曾经孕育过一代又一代能快乐地追风筝的少年。</p>
<p>作者胡赛尼「立志拂去蒙在阿富汗普通民众面孔的尘灰，将背后灵魂的悸动展示给世人」，从某种意义上讲，他实现了这个志向。</p>
<h3 id="同名电影"><a href="#同名电影" class="headerlink" title="同名电影"></a>同名电影</h3><p>在 2017 贺岁档电影里，我唯一觉得还不错的《乘风破浪》（豆瓣 7.0 分），之所以广受好评，主要也是因为第一点做得比较好，完整地讲述了一个简单的故事，让人知所云，这本来应该是一部电影的基本素质，但是它做到这一点，却已比如今一众故弄玄虚总想搞个大新闻的烂片不知道高到哪里去了。</p>
<p>而本书的同名电影在豆瓣上评分高达了 8.2 分，可见也很值得一看。但我的体会是在阅读本书的过程中，脑海里能根据作者的讲述不断脑补起各种场景、人物和剧情，所以不建议看完本书之后立即去看电影——脑海里刚刚放映过包含各种细节和微妙之处的完整版，马上接着去看有删节有改编版，难免会失落。</p>
<h2 id="感受"><a href="#感受" class="headerlink" title="感受"></a>感受</h2><p>一个好的故事，应该连续地读完，及时记下所感所想。</p>
<p>虽然我不擅长写读书笔记、读后感，但是输入之后有输出真的是一个能让自己受益良多的好习惯。不顾忌那么多，先写下来，然后对记录的模板、方式和内容进行迭代。</p>
<p>希望本篇成为一个良好的开端。</p>
]]></content>
      <categories>
        <category>博客文章</category>
      </categories>
      <tags>
        <tag>追风筝的人</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建大型源码阅读环境——使用 OpenGrok</title>
    <url>/2016/12/14/%E5%B7%A5%E5%85%B7/rtfsc-with-opengrok/</url>
    <content><![CDATA[<p>RTFSC 是程序员打怪升级路上避不开的功课，那营造一个舒适的环境来提升上课的体验就很有必要了。</p>
<p>比如阅读 AOSP 这种大型源码，用什么姿势来阅读才能丝般顺滑，让 F**king Source Code 也变得不那么可恶呢？</p>
<h2 id="工具的选择"><a href="#工具的选择" class="headerlink" title="工具的选择"></a>工具的选择</h2><p>阅读源码的工具我尝试过以下几类：</p>
<ol>
<li><p>IDE</p>
<p>在看特定类型项目时这是我的首选。比如它原本就是一个 Visual Studio 工程，那当然用 Visual Studio 来打开阅读，看 Android App 或者 Library 源码当然用 Android Studio 体验更好。</p>
</li>
<li><p>编辑器配合插件</p>
<p>比如 Vim + Ctags + Cscope，再配合文件模糊查找插件 LeaderF 和神器 YouCompleteMe，在源码规模不大时很方便，打开也轻快，阅读一些小项目时我还是乐意使用它们。</p>
</li>
<li><p>专门的源码阅读工具</p>
<p>在针对特大型源码时，比如 AOSP 和 Chromium，使用上述两种方案可能会感觉乏力，这时候就需要祭出专门的源码阅读工具了。</p>
<p>一类是商业软件，比如 Windows 下有著名的 Source Insight，跨平台的有 Understand，功能都很强大，都是不错的选择。当然它们都价格不菲。</p>
<p>而我这里要讲的主角 OpenGrok 属于另一类，免费，开源，运行流畅，功能也毫不逊色。</p>
</li>
</ol>
<p>如果你还在寻觅适合你自己的解决方案，大可以花一点时间将以上几种都尝试一遍，哪个称手用哪个，也可以像我一样，针对不同的项目使用不同的工具。想直观了解 OpenGrok 的同学可以直接先看看一些使用 OpenGrok 的在线源码查看网站，看看它能否满足你的需求，其中的一些列在 <a href="https://github.com/OpenGrok/OpenGrok/wiki/OpenGrok-installations">OpenGrok installations</a>。</p>
<h2 id="OpenGrok-特性"><a href="#OpenGrok-特性" class="headerlink" title="OpenGrok 特性"></a>OpenGrok 特性</h2><p>译自官方 <a href="https://github.com/OpenGrok/OpenGrok/wiki/Features">Wiki</a>。</p>
<p>OpenGrok 提供如下特性：</p>
<ol>
<li><p>快速搜索代码的引擎</p>
<ul>
<li><p>搜索全文、定义、符号、文件路径和修改历史</p>
</li>
<li><p>搜索任意指定子目录（分层搜索）</p>
</li>
<li><p>增量更新索引文件</p>
</li>
<li><p>支持类似 Google 的查询语法，比如 <code>path:Makefile defs:target</code></p>
</li>
<li><p>搜索日期范围内修改的文件</p>
</li>
<li><p>支持使用通配符搜索，如 <code>*</code> 表示多个字符，<code>?</code> 表示单个字符</p>
</li>
<li><p>在搜索结果中展示匹配行</p>
</li>
</ul>
</li>
<li><p>一个 Web 只读版的版本历史查看界面</p>
<ul>
<li><p>文件的修改日志</p>
</li>
<li><p>文件在两个版本间的 diff</p>
</li>
<li><p>文件夹的历史记录</p>
</li>
</ul>
</li>
<li><p>带语法高亮的交叉引用显示，可以使用 CSS 自定义样式</p>
</li>
<li><p>可以开发插件支持新的语言和版本控制系统</p>
<p> 已经支持的语言： <a href="https://github.com/OpenGrok/OpenGrok/wiki/Supported-Languages-and-Formats">Supported Languages and Formats</a></p>
<p> 已经支持的版本控制系统：<a href="https://github.com/OpenGrok/OpenGrok/wiki/Supported-Revision-Control-Systems">Supported Revision Control Systems</a></p>
</li>
</ol>
<h2 id="配置-OpenGrok"><a href="#配置-OpenGrok" class="headerlink" title="配置 OpenGrok"></a>配置 OpenGrok</h2><h3 id="截屏"><a href="#截屏" class="headerlink" title="截屏"></a>截屏</h3><p>按惯例先上图吧，万一你一眼就发现不是你的菜呢（截图来自<a href="https://opengrok.github.io/OpenGrok/">官网</a>）。</p>
<p>搜索功能和源码树：</p>
<p><img  src="/images/posts/tools/opengrok-scr1.png"  ><span class="image-caption">OpenGrok Search and Browse</span></p>
<p>代码导航和版本历史记录：</p>
<p><img  src="/images/posts/tools/opengrok-scr2.png"  ><span class="image-caption">OpenGrok Navitation and History</span></p>
<h3 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h3><p>如下以 Windows 下为例，Mac OS X 与 Linux 下与此类似，很多步骤能使用 brew 或者 apt-get 会更方便。</p>
<ol>
<li><p>安装 <a href="http://www.oracle.com/technetwork/java/">JDK</a>，并配置 JAVA_HOME 或者 JRE_HOME 环境变量为安装目录。</p>
</li>
<li><p>下载 <a href="http://tomcat.apache.org/">Tomcat</a>，解压到一个目录，如 D:\Programs\apache-tomcat-8.5.8，并将此目录添加为 CATALINA_HOME 环境变量。</p>
<p><img src="/images/posts/tools/catalina-home.png"></p>
</li>
<li><p>下载 <a href="https://github.com/universal-ctags/ctags">Universal Ctags</a> for Windows，将 ctags.exe 文件所在目录添加到 PATH 环境变量。</p>
</li>
<li><p>下载 <a href="https://github.com/OpenGrok/OpenGrok/releases">OpenGrok</a> 的最新包，比如 opengrok-0.13-rc4.zip，解压到一个目录，如 D:\Programs\opengrok-0.13-rc4。</p>
</li>
<li><p>配置 data root。</p>
<p>data root 用于放置生成的索引文件和配置信息，比如我在 OpenGrok 目录下创建了一个 data 目录用作 data root，即 D:\Programs\opengrok-0.13-rc4\data。</p>
</li>
<li><p>将 OpenGrok 的 lib 目录里的 source.war 解压到 D:\Programs\apache-tomcat-8.5.8\webapps\source，配置 WEB-INF\web.xml 文件的 CONFIGURATION 为上一步生成的 data 目录下的 configureation.xml，比如我的配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">display-name</span>&gt;</span>OpenGrok<span class="hljs-tag">&lt;/<span class="hljs-name">display-name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>A wicked fast source browser<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Full path to the configuration file where OpenGrok can read its configuration<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>CONFIGURATION<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>D:/Programs/opengrok-0.13-rc4/data/configuration.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><em>注：这里只是配置一个文件路径，具体的 configuration.xml 会在第 8 步时自动生成。</em></p>
</li>
<li><p>配置 source root。</p>
<p>可以让 OpenGrok 认为 source root 下的每个子文件夹是一个项目，所以我们利用这个特性来配置和阅读多个项目源码就好了。</p>
<p>我的做法是在 OpenGrok 下创建了一个子目录 D:\Programs\opengrok-0.13-rc4\projects，然后将需要阅读的源码使用符号链接的方式链接到这个目录里：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /d D:\Programs\opengrok-0.13-rc4\projects<br>mklink /J android D:\sources\android_5.1<br>mklink /J openjdk7 D:\sources\openjdk7<br></code></pre></td></tr></table></figure>

<p>这样就有一个叫 android 的工程，它实际对应 D:\sources\android_5.1 下的源码，一个叫 openjdk7 的工程，它实际对应 D:\sources\openjdk7 下的源码。</p>
</li>
<li><p>建立索引。</p>
<p>使用 opengrok.jar 调用 ctags 来为源码建立索引。命令行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">java -jar /path/to/opengrok.jar -P -S -v -s /path/to/<span class="hljs-built_in">source</span>/root -d /path/to/data/root -W /path/to/configuration.xml<br></code></pre></td></tr></table></figure>

<p><code>-P</code> 表示为 source root 目录下的每个一级子目录生成一个工程。</p>
<p><code>-S</code> 表示搜索并添加 “external” source repositories。</p>
<p><code>-v</code> 表示打印操作的进度信息。</p>
<p><code>-s</code> 表示指定 source root。</p>
<p><code>-d</code> 表示指定 data root。</p>
<p><code>-W</code> 表示指定将配置写到该文件。</p>
<p>还有更多配置选项可以使用 <code>java -jar /path/to/opengrok.jar</code> 查看。</p>
<p>比如我使用的完整命令行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">java -jar D:\Programs\opengrok-0.13-rc4\lib\opengrok.jar -P -S -v -s D:\Programs\opengrok-0.13-rc4\projects -d D:\Programs\opengrok-0.13-rc4\data -W D:\Programs\opengrok-0.13-rc4\data\configuration.xml<br></code></pre></td></tr></table></figure>

<p>每次需要建立或更新索引的时候敲这么长一个命令当然很不爽，使用 doskey 或者 Cmder 里的 alias 命令将其 alias 为 opengrok-index 命令会省力不少，再不济把这命令存成个 bat 文件也行啊。</p>
<p>为大型源码建立索引可能需要漫长的时间，这时候可以去干点别的事了。</p>
</li>
<li><p>启动 Tomcat，愉快地 RTFSC。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">D:\Programs\apache-tomcat-8.5.8\bin\catalina.bat start<br></code></pre></td></tr></table></figure>

<p>用你最爱的浏览器打开 <a href="http://localhost:8080/source/">http://localhost:8080/source/</a>，然后就能愉快地跟 OpenGrok 玩耍了。</p>
<p>当新添加了项目，或者现有项目有源码更新时，再次执行上一步的命令，就能增量更新索引了。</p>
</li>
</ol>
<h3 id="配置多项目"><a href="#配置多项目" class="headerlink" title="配置多项目"></a>配置多项目</h3><p>我曾经为如何在 OpenGrok 里配置多项目苦恼了好久——一开始我是把 Android 源码的根目录当作 source root 的，可想而知 OpenGrok 把 Android 分成了好多个子项目，而这时我也没法再添加新的工程了。</p>
<p>后来才发现建一个专用的 source root，然后把各种项目源码根目录软链接过来，让 OpenGrok 为 source root 下的每个 symbol 一级子目录建立一个项目才是正确的使用方法。</p>
<p>Windows 下建立软链接的方法是使用 <code>mklink /J android D:\sources\android_5.1</code>，Mac OS X 和 Linux 下可以使用 <code>ln -s /path/to/source project_name</code>。</p>
<h3 id="折腾狂魔"><a href="#折腾狂魔" class="headerlink" title="折腾狂魔"></a>折腾狂魔</h3><p><strong>在 Vim 里使用</strong></p>
<p>没错，还有人做了支持在 Vim 里使用 OpenGrok 的插件，如果你是 Vim 控+折腾狂魔，可以一试，这里仅给出插件地址：</p>
<ul>
<li><a href="https://github.com/asenac/vim-opengrok">asenac/vim-opengrok</a></li>
<li><a href="https://github.com/jdevera/vim-opengrok-search">jdevera/vim-opengrok-search</a></li>
</ul>
<p>反正像我这种智商是折腾不动了，就安心在浏览器里用了。</p>
<p><strong>在源码里做笔记</strong></p>
<p>配合 Chrome 插件 <a href="https://chrome.google.com/webstore/detail/diigo-web-collector-captu/pnhplgjpclknigjpccbcnmicgcieojbh">Diigo</a>，还能给源码加标签，写注释等等。</p>
<p>参考：<a href="https://www.zhihu.com/question/33505693/answer/132224974">https://www.zhihu.com/question/33505693/answer/132224974</a></p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="打开网页后报错"><a href="#打开网页后报错" class="headerlink" title="打开网页后报错"></a>打开网页后报错</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">There was an error!<br>CONFIGURATION parameter has not been configured <span class="hljs-keyword">in</span> web.xml! Please configure your webapp.<br>Unable <span class="hljs-keyword">to</span> determine source root path. Missing configuration?<br>java.io.FileNotFoundException: Unable <span class="hljs-keyword">to</span> determine source root path. Missing configuration?<br>	at org.opensolaris.opengrok.web.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PageConfig</span>.</span></span>check<span class="hljs-constructor">SourceRootExistence(PageConfig.<span class="hljs-params">java</span>:1562)</span><br>	at org.apache.jsp.index_jsp.<span class="hljs-constructor">_jspService(<span class="hljs-params">index_jsp</span>.<span class="hljs-params">java</span>:222)</span><br>	at org.apache.jasper.runtime.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">HttpJspBase</span>.</span></span>service(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">HttpJspBase</span>.</span></span>java:<span class="hljs-number">70</span>)<br>	at javax.servlet.http.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">HttpServlet</span>.</span></span>service(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">HttpServlet</span>.</span></span>java:<span class="hljs-number">742</span>)<br>	at org.apache.jasper.servlet.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JspServletWrapper</span>.</span></span>service(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JspServletWrapper</span>.</span></span>java:<span class="hljs-number">443</span>)<br>	at org.apache.jasper.servlet.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JspServlet</span>.</span></span>service<span class="hljs-constructor">JspFile(JspServlet.<span class="hljs-params">java</span>:385)</span><br>	at org.apache.jasper.servlet.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JspServlet</span>.</span></span>service(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JspServlet</span>.</span></span>java:<span class="hljs-number">329</span>)<br>	at javax.servlet.http.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">HttpServlet</span>.</span></span>service(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">HttpServlet</span>.</span></span>java:<span class="hljs-number">742</span>)<br>	at org.apache.catalina.core.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ApplicationFilterChain</span>.</span></span>internal<span class="hljs-constructor">DoFilter(ApplicationFilterChain.<span class="hljs-params">java</span>:231)</span><br>	at org.apache.catalina.core.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ApplicationFilterChain</span>.</span></span><span class="hljs-keyword">do</span><span class="hljs-constructor">Filter(ApplicationFilterChain.<span class="hljs-params">java</span>:166)</span><br>	at org.apache.tomcat.websocket.server.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">WsFilter</span>.</span></span><span class="hljs-keyword">do</span><span class="hljs-constructor">Filter(WsFilter.<span class="hljs-params">java</span>:52)</span><br>	at org.apache.catalina.core.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ApplicationFilterChain</span>.</span></span>internal<span class="hljs-constructor">DoFilter(ApplicationFilterChain.<span class="hljs-params">java</span>:193)</span><br>	at org.apache.catalina.core.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ApplicationFilterChain</span>.</span></span><span class="hljs-keyword">do</span><span class="hljs-constructor">Filter(ApplicationFilterChain.<span class="hljs-params">java</span>:166)</span><br>	at org.opensolaris.opengrok.web.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">StatisticsFilter</span>.</span></span><span class="hljs-keyword">do</span><span class="hljs-constructor">Filter(StatisticsFilter.<span class="hljs-params">java</span>:55)</span><br>	at org.apache.catalina.core.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ApplicationFilterChain</span>.</span></span>internal<span class="hljs-constructor">DoFilter(ApplicationFilterChain.<span class="hljs-params">java</span>:193)</span><br>	at org.apache.catalina.core.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ApplicationFilterChain</span>.</span></span><span class="hljs-keyword">do</span><span class="hljs-constructor">Filter(ApplicationFilterChain.<span class="hljs-params">java</span>:166)</span><br>	at org.opensolaris.opengrok.web.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AuthorizationFilter</span>.</span></span><span class="hljs-keyword">do</span><span class="hljs-constructor">Filter(AuthorizationFilter.<span class="hljs-params">java</span>:83)</span><br>	at org.apache.catalina.core.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ApplicationFilterChain</span>.</span></span>internal<span class="hljs-constructor">DoFilter(ApplicationFilterChain.<span class="hljs-params">java</span>:193)</span><br>	at org.apache.catalina.core.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ApplicationFilterChain</span>.</span></span><span class="hljs-keyword">do</span><span class="hljs-constructor">Filter(ApplicationFilterChain.<span class="hljs-params">java</span>:166)</span><br>	at org.apache.catalina.core.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">StandardWrapperValve</span>.</span></span>invoke(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">StandardWrapperValve</span>.</span></span>java:<span class="hljs-number">198</span>)<br>	at org.apache.catalina.core.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">StandardContextValve</span>.</span></span>invoke(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">StandardContextValve</span>.</span></span>java:<span class="hljs-number">96</span>)<br>	at org.apache.catalina.authenticator.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AuthenticatorBase</span>.</span></span>invoke(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AuthenticatorBase</span>.</span></span>java:<span class="hljs-number">478</span>)<br>	at org.apache.catalina.core.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">StandardHostValve</span>.</span></span>invoke(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">StandardHostValve</span>.</span></span>java:<span class="hljs-number">140</span>)<br>	at org.apache.catalina.valves.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ErrorReportValve</span>.</span></span>invoke(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ErrorReportValve</span>.</span></span>java:<span class="hljs-number">80</span>)<br>	at org.apache.catalina.valves.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AbstractAccessLogValve</span>.</span></span>invoke(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AbstractAccessLogValve</span>.</span></span>java:<span class="hljs-number">624</span>)<br>	at org.apache.catalina.core.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">StandardEngineValve</span>.</span></span>invoke(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">StandardEngineValve</span>.</span></span>java:<span class="hljs-number">87</span>)<br>	at org.apache.catalina.connector.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">CoyoteAdapter</span>.</span></span>service(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">CoyoteAdapter</span>.</span></span>java:<span class="hljs-number">342</span>)<br>	at org.apache.coyote.http11.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Http11Processor</span>.</span></span>service(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Http11Processor</span>.</span></span>java:<span class="hljs-number">799</span>)<br>	at org.apache.coyote.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AbstractProcessorLight</span>.</span></span>process(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AbstractProcessorLight</span>.</span></span>java:<span class="hljs-number">66</span>)<br>	at org.apache.coyote.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AbstractProtocol$ConnectionHandler</span>.</span></span>process(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AbstractProtocol</span>.</span></span>java:<span class="hljs-number">868</span>)<br>	at org.apache.tomcat.util.net.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">NioEndpoint$SocketProcessor</span>.</span></span><span class="hljs-keyword">do</span><span class="hljs-constructor">Run(NioEndpoint.<span class="hljs-params">java</span>:1455)</span><br>	at org.apache.tomcat.util.net.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SocketProcessorBase</span>.</span></span>run(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SocketProcessorBase</span>.</span></span>java:<span class="hljs-number">49</span>)<br>	at java.util.concurrent.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ThreadPoolExecutor</span>.</span></span>run<span class="hljs-constructor">Worker(ThreadPoolExecutor.<span class="hljs-params">java</span>:1142)</span><br>	at java.util.concurrent.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ThreadPoolExecutor$Worker</span>.</span></span>run(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ThreadPoolExecutor</span>.</span></span>java:<span class="hljs-number">617</span>)<br>	at org.apache.tomcat.util.threads.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TaskThread$WrappingRunnable</span>.</span></span>run(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TaskThread</span>.</span></span>java:<span class="hljs-number">61</span>)<br>	at java.lang.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>run(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>java:<span class="hljs-number">745</span>)<br></code></pre></td></tr></table></figure>

<p>这一般是由于更新或切换了 OpenGrok 版本，但却没有将 tomcat 的 webapps 目录下的 source 文件夹替换为对应版本。</p>
<h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><p>古人教会了我们工欲善其事，必先利其器的智慧，但我们也不能沉迷和徘徊于各种利器之间，选择一样自己感觉最称手的工具，把它用熟练，少再在这上面花时间折腾，毕竟把有限的生命投入到无限的 RTFSC 才是正道不是么。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>OpenGrok, RTFSC</tag>
      </tags>
  </entry>
  <entry>
    <title>vim-markdown-toc 发布 v1.0 版</title>
    <url>/2016/10/22/Vim/vim-markdown-toc-release/</url>
    <content><![CDATA[<p>前几天，第一款由我独立开发的 Vim 插件 vim-markdown-toc 升级了功能，发布了 v1.0 版本。</p>
<p>它的主要功能是为 Markdown 文件生成 toc（Table of Contents）、更新已经存在的 toc 和在保存时自动更新 toc。</p>
<p>说它是当前使用 Vim 编辑 Markdown 文件时维护 Table of Contents 的最佳解决方案应该不为过。</p>
<h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><ul>
<li><a href="https://github.com/mzlogin/vim-markdown-toc">vim-markdown-toc</a></li>
</ul>
<h2 id="主要更新"><a href="#主要更新" class="headerlink" title="主要更新"></a>主要更新</h2><ol>
<li><p>支持使用 <code>:UpdateToc</code> 命令更新已经存在的 toc。</p>
</li>
<li><p>支持保存时自动更新 toc。</p>
</li>
</ol>
<h2 id="功能演示"><a href="#功能演示" class="headerlink" title="功能演示"></a>功能演示</h2><p><img  src="https://raw.githubusercontent.com/mzlogin/vim-markdown-toc/master/screenshots/english.gif"  ><span class="image-caption">vim-markdown-toc-screenshot</span></p>
<h2 id="一些体会"><a href="#一些体会" class="headerlink" title="一些体会"></a>一些体会</h2><ol>
<li><p>相比于 <a href="https://github.com/mzlogin/awesome-adb">awesome-adb</a> 的一千多个 Star，<a href="https://github.com/mzlogin/vim-markdown-toc">vim-markdown-toc</a> 的三十多个 Star 在我心目中含金量更高。</p>
</li>
<li><p>做能挣钱的东西，或者对自己有用的东西。</p>
<p>有天和我们组去年来的小朋友聊天，他说了一个观点我觉得很有道理：做能给自己产生经济效益的东西，你才有动力持续下去。虽然听起来功利，但不无道理。</p>
<p>这么一个插件显然不能挣钱，它属于第二种。本次更新的功能其实在半年前就有网友提过需求，见 <a href="https://github.com/mzlogin/vim-markdown-toc/issues/6">#6</a>，但我却迟迟没有动手。半年后的某个夜里，突然就决定要把这些做出来，并且花了几个小时就做完了。究其原因，还是因为自己现在有了需求，我现在要维护几份比较长的 Markdown 文档，如果每次手动去删除已有 toc 然后再次生成，虽然比纯手工写 toc 要不知道方便和准确到哪里去了，但归根结底还是不够完美。果然最后用着自己做的功能替自己省下不少重复劳动时，那种感觉也是很爽的。</p>
</li>
<li><p>酒香也怕巷子深。</p>
<p>发布了个人的项目后，适当地在相关的社区进行推广，让更多的人享受到你的劳动成果，帮助验证和反馈，也能给自己带来更多的成就感和关注度。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>Vim, Markdown, Table of Contents</tag>
      </tags>
  </entry>
  <entry>
    <title>一道在知乎很火的 Java 题——如何输出 ab</title>
    <url>/2016/09/20/Java/java-output-ab/</url>
    <content><![CDATA[<p>这是一个源自知乎的话题，原贴链接：<a href="https://www.zhihu.com/question/50801791">一道百度的面试题，有大神会嘛？</a></p>
<p>虽然我不是大神，但我也点进去看了一下，思考了一会之后有了一些思路，然后去看其它人的答案的时候果然全都已经被各路大神们先想到并贴出来了，所以我就不去凑热闹写重复答案了，整理一下网友们的智慧在这里自娱自乐好了。</p>
<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img  src="/images/posts/java/output-ab.jpg"  ><span class="image-caption">java-output-ab</span></p>
<h2 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h2><p>作为一个多年前也见过不少笔试题的少年，看到这个题目的第一想法是脑筋急转弯——注入一段逻辑直接改变原 if 结构。</p>
<h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>填入内容 <code>true)&#123;System.out.print(&quot;a&quot;);&#125;if(false</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">true</span>) &#123;<br>        System.out.print(<span class="hljs-string">&quot;a&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">false</span>) &#123;<br>        System.out.print(<span class="hljs-string">&quot;a&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        System.out.print(<span class="hljs-string">&quot;b&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>类似地也可以填入 <code>true)&#123;System.out.print(&quot;ab&quot;);return;&#125;if(false</code> 等。</p>
<p>当初大学时单纯的少年可是很难想出这样的套路的，时间改变了我们啊。</p>
<h2 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h2><p>如果正经遵从题目的原代码结构，那就得想办法构造一段代码，既能输出 <code>a</code>，又能返回 <code>false</code>。</p>
<h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>我也想到能否使用 <code>System.out.print</code> 的返回值来做文章，但奈何并不记得它返回什么，首先让我们复习一下 <code>PrintStream</code> 的 <code>print</code>、<code>println</code> 和 <code>printf</code> 方法的区别：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>print</td>
<td>打印一个值或者对象</td>
<td>void</td>
</tr>
<tr>
<td>println</td>
<td>打印并换行</td>
<td>void</td>
</tr>
<tr>
<td>printf</td>
<td>格式化打印</td>
<td>PrintStream</td>
</tr>
</tbody></table>
<p>所以适用的是 <code>printf</code>，它的返回值是 <code>PrintStream</code> 类型的 <code>System.out</code>，判它是否为空即可。</p>
<p>填入内容 <code>System.out.printf(&quot;a&quot;) == null</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (System.out.printf(<span class="hljs-string">&quot;a&quot;</span>) == <span class="hljs-keyword">null</span>) &#123;<br>        System.out.print(<span class="hljs-string">&quot;a&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        System.out.print(<span class="hljs-string">&quot;b&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>经测试填入 <code>System.out.append(&quot;a&quot;) == null</code> 也是可以达到效果的。</p>
<h3 id="解法三"><a href="#解法三" class="headerlink" title="解法三"></a>解法三</h3><p>仍然是思路二，但从匿名内部类来作文章。</p>
<p>实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> Object() &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.print(<span class="hljs-string">&quot;a&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;.print()) &#123;<br>        System.out.print(<span class="hljs-string">&quot;a&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        System.out.print(<span class="hljs-string">&quot;b&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里利用的知识点是匿名内部类可以声明基类没有的新方法并且马上调用。</p>
<h3 id="解法四"><a href="#解法四" class="headerlink" title="解法四"></a>解法四</h3><p>使用 Java 8 里的 lambda 来实现思路二。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (((BooleanSupplier)(() -&gt; &#123;System.out.print(<span class="hljs-string">&quot;a&quot;</span>);<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;)).getAsBoolean()) &#123;<br>        System.out.print(<span class="hljs-string">&quot;a&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        System.out.print(<span class="hljs-string">&quot;b&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>严格来讲这个不一定能算作正确答案，因为要增加 <code>import java.util.function.BooleanSupplier;</code>。</p>
<h2 id="脑洞大开"><a href="#脑洞大开" class="headerlink" title="脑洞大开"></a>脑洞大开</h2><p>讲完严肃的解法，来看看网友 <a href="https://www.zhihu.com/people/qiong-xiao-zi-158">穷小子</a> 开脑洞的思路：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//    if ( ) &#123;</span><br>        System.out.print(<span class="hljs-string">&quot;a&quot;</span>);<br><span class="hljs-comment">//    &#125; else &#123;</span><br>        System.out.print(<span class="hljs-string">&quot;b&quot;</span>);<br><span class="hljs-comment">//    &#125;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果没有特意说明只能在括号里加东西，倒真是个妙计！</p>
<p>同样看得我一愣一愣的还有 <a href="https://www.zhihu.com/people/caiwei710">caiwei</a> 同学的答案，他和朋友们发现题目里少写了个大括号（真的），于是我们看到他的朋友老方的解决方案：</p>
<p><img  src="/images/posts/java/add-brace.jpg"  ><span class="image-caption">add-brace</span></p>
<p>真是防不胜防啊~不过我喜欢！:+1:</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.zhihu.com/question/50801791/answer/122781965">RednaxelaFX 的回答</a></li>
<li><a href="https://www.zhihu.com/question/50801791/answer/122773831">仓鼠君 的回答</a></li>
<li><a href="https://www.zhihu.com/question/50801791/answer/122769426">放开那女孩 的回答</a></li>
<li><a href="https://www.zhihu.com/question/50801791/answer/122863062">穷小子 的回答</a></li>
<li><a href="https://www.zhihu.com/question/50801791/answer/122795854">caiwei 的回答</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>为绑定域名的 GitHub Pages 启用 HTTPS</title>
    <url>/2016/05/21/GitHub/enable-https-for-github-pages/</url>
    <content><![CDATA[<p><strong>Update 2018/05/01: GitHub 官方已经支持自定义域名启用 HTTPS 了，见 <a href="https://blog.github.com/2018-05-01-github-pages-custom-domains-https/">https://blog.github.com/2018-05-01-github-pages-custom-domains-https/</a></strong></p>
<p><strong>Update 2016/07/11: 收到 Kloudsec 的邮件，说将在 2016/08/01 停止服务，所以如下方法在那之后会无法使用，寻找 GitHub Pages + Custom Domain + HTTPS 的方法的童鞋请不要再尝试 Kloudsec 了，去找一找别的方法吧。</strong></p>
<p>虽然现在各种网站都在 HTTPS 化，甚至有的个人网站在添加链接的说明里明确声明只与启用 HTTPS 的网站交换链接，但一直以来我启用 HTTPS 的需求并不强烈，又加上有懒癌在身，实在是没有动力去折腾，直到最近发生了几件事情。</p>
<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><ol>
<li><p>最近一段时间也不知道是 GitHub Pages 做了调整还是 Google 的收录策略有了变化，Google 收录我的博客页面都是同时收录了 HTTP 和 HTTPS 两种版本，而很遗憾这个博客并没有配置有效的 SSL 证书，所以点开的是一个 HTTPS 的链接就会被浏览器提示连接不可信，有安全风险云云，虽然访问量不大，但这样体验太差，也是蛮闹心的。</p>
</li>
<li><p>恰逢知乎上有人邀我答题 <a href="https://www.zhihu.com/question/33495825">Github Pages 绑定了个人域名，怎么使用 HTTPS 访问而证书不报错呢？</a>。</p>
</li>
<li><p>三月份的时候 <a href="https://github.com/nubela">@nubela</a> 发邮件邀请我试用他为绑定域名的 GitHub Pages 制作的一键启用 HTTPS 的工具，而我当时答复的是实在太忙，后来有空再折腾。</p>
</li>
</ol>
<p>几个理由加在一起，终于战胜了懒癌，让我动了起来。</p>
<p><img  src="/images/posts/github/github-pages-with-https.png"  ><span class="image-caption">enable https for GitHub Pages</span></p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>@nubela 提供的工具非常友好且方便，第一次使用的我只简单做了一些配置，没有对 GitHub Pages 仓库做任何更改就实现了全站 HTTPS 化，自动使用了 Let’s Encrypt 提供的免费 SSL 证书，有效期 90 天，Kloudsec 会在它过期前自动续期，换句话说，只要 Kloudsec 还活着并且免费提供这项服务的话，后面就不用管这个了。</p>
<p>记录操作步骤如下：</p>
<ol>
<li><p>打开 Kloudsec 为 GitHub Pages 提供的工具 <a href="https://kloudsec.com/github-pages/new">Kloudsec for GitHub Pages</a>。</p>
</li>
<li><p>按工具里的要求填好三个部分的内容，依次是</p>
<ul>
<li><p>用于注册 Kloudsec 的邮箱和为 Kloudsec 账户设置的密码。</p>
<p><img  src="/images/posts/github/https-kloudsec-account.png"  ><span class="image-caption">Register a Kloudsec account</span></p>
</li>
<li><p>GitHub Pages 项目的 URL 和绑定的域名。</p>
<p><img  src="/images/posts/github/https-config-gh.png"  ><span class="image-caption">Configure your Github Page</span></p>
</li>
<li><p>到你的域名解析控制面板里添加工具要求的 A 记录。</p>
<p><img  src="/images/posts/github/https-config-dns.png"  ><span class="image-caption">Configure your DNS settings</span></p>
<p><strong>注意：</strong> 每个 A 记录应只保留一个 IP，比如之前将 @ 做了 A 记录到 GitHub Pages 的 IP 上了，那现在将其删除，并添加工具提供的 IP。</p>
</li>
</ul>
</li>
<li><p>去上一步填写的邮箱里收邮件，激活 Kloudsec 账号并登录。</p>
</li>
<li><p>进入到 Dashboard 的 SETTINGS，在 Web Server Origin IP / Hostname 一栏填上 GitHub Pages 的可用 IP，比如我填写的是 <code>103.245.222.133</code>。</p>
<p><img  src="/images/posts/github/https-config-server-ip.png"  ><span class="image-caption">Web Server Origin IP</span></p>
</li>
<li><p>开启 HTTP 自动跳转到 HTTPS。<em>（非必须，按自己需求来。）</em></p>
<p>进入到 Dashboard 的 PROTECTION，点击 SSL Encryption 里的按钮，选择你的网站：</p>
<p><img  src="/images/posts/github/https-config-redirection-1.png"  ><span class="image-caption">PROTECTION</span></p>
<p>将 Automatically redirect to HTTPS site? 下面的开关切换到 ON：</p>
<p><img  src="/images/posts/github/https-config-redirection-2.png"  ><span class="image-caption">Automatically redirect to HTTPS site?</span></p>
</li>
<li><p>进入到 Dashboard 的 PLUGIN STORE，启用 Offline Protection、Page Optimizer 和 One-Click Encryption，一般来讲免费的计划就够用了，如果你想要使用付费计划提供更多更好的服务，那按需选择吧。</p>
<p><img  src="/images/posts/github/https-config-plugin-store.png"  ><span class="image-caption">Plugin Store</span></p>
</li>
</ol>
<p>恭喜你已完成所有步骤！等待几分钟生效即可。</p>
<h2 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h2><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>看 Kloudsec 的文档里描述的 <a href="https://docs.kloudsec.com/#section-how-does-it-work-">HOW DOES IT WORK?</a>，它提供的服务处于我们的网站服务器和我们的网站访问者之间，其原理是缓存了我们服务器上的页面，所以实际用户建立的 HTTPS 连接是用户的浏览器与 Kloudsec 之间的。</p>
<h3 id="使用-Kloudsec-的好处"><a href="#使用-Kloudsec-的好处" class="headerlink" title="使用 Kloudsec 的好处"></a>使用 Kloudsec 的好处</h3><ul>
<li><p>摆脱了证书不可信存在安全风险的不友好提示。</p>
</li>
<li><p>配置方便，一劳永逸。</p>
</li>
<li><p>访问速度并未受影响<del>，因为缓存里优化了图片大小，合并了 CSS/JS，甚至可能更快了。</del></p>
</li>
<li><p>小绿锁看着舒心。</p>
</li>
</ul>
<h3 id="使用-Kloudsec-的风险和影响"><a href="#使用-Kloudsec-的风险和影响" class="headerlink" title="使用 Kloudsec 的风险和影响"></a>使用 Kloudsec 的风险和影响</h3><ul>
<li><p>貌似是个小公司，这样的免费服务能提供多长时间只有天知道。</p>
</li>
<li><p><del>因为用户看到是在 Kloudsec 上的缓存页面，所以我们更新 GitHub Pages 内容后，刷新线上页面效果的时间变久了，以前上传完基本马上就能看到，现在有时候部分页面会延迟两三分钟，我勉强能接受。</del></p>
<p>Update: 2016/6/16 现在基本上传完马上就能看到了。</p>
</li>
<li><p><del>很偶尔会出现样式加载不完整的情况，刷新就好了。</del></p>
<p>Update: 2016/6/16 最近基本没出现过了。</p>
</li>
<li><p><del>缓存页面合并了 CSS 和 JS 文件，使用开发工具在线调试时要找到样式源文件变困难了——可能看到全都在一个 CSS 文件里。不过我大部分情况下都是用 Jekyll 在本地调试好再上传，这点对我影响不大。</del></p>
<p>Update: 2016/6/16 现在貌似不会合并了。</p>
</li>
<li><p>如果引用了其它域名下的非 HTTPS 的 CSS 和图片资源等，开发者控制台下会有 error，显示不受影响。</p>
</li>
<li><p><del>Google 索引状态会受影响，目前本博客来自 Google 的流量完全没有了，估计需要一段时间才能恢复。</del></p>
<p>Update: 2016/6/16 应该影响不大，只是 Google Search Console 将 http 与 https 的未当成一个网站来统计，所以给我造成错觉了。</p>
</li>
</ul>
<p>接下来，能做的就是祈祷 Kloudsec 不要挂了。:laughing:</p>
<h2 id="其它做法"><a href="#其它做法" class="headerlink" title="其它做法"></a>其它做法</h2><p>如果使用 GitLab 提供的 Pages 服务，那它直接支持添加自定义域名的 SSL 证书，可以配合免费申请的 SSL 证书一起使用。详情可见 <a href="https://www.figotan.org/2016/04/26/using-free-wosign-to-certificate-your-blog-on-gitlab/">零成本打造安全博客的简单办法</a>。</p>
]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>GitHub Pages, SSL, Let&#39;s Encrypt</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 使用笔记</title>
    <url>/2016/01/12/Linux/use-ubuntu-notes/</url>
    <content><![CDATA[<p>使用 Ubuntu 过程中遇到的问题及解决方案。</p>
<h2 id="使用-git-pull-遇到问题"><a href="#使用-git-pull-遇到问题" class="headerlink" title="使用 git pull 遇到问题"></a>使用 git pull 遇到问题</h2><p>提示</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><code class="hljs livecodeserver">Agent admitted failure <span class="hljs-built_in">to</span> sign <span class="hljs-keyword">using</span> <span class="hljs-keyword">the</span> key.<br>Permission denied (publickey).<br>fatal: Could <span class="hljs-keyword">not</span> <span class="hljs-built_in">read</span> <span class="hljs-built_in">from</span> remote repository.<br><br>Please make sure you have <span class="hljs-keyword">the</span> correct access rights<br><span class="hljs-keyword">and</span> <span class="hljs-keyword">the</span> repository exists.<br></code></pre></td></tr></table></figure>

<p>解决方法：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">ssh-add ~/.ssh/id_rsa<br></code></pre></td></tr></table></figure>

<h2 id="图形界面编辑配置文件"><a href="#图形界面编辑配置文件" class="headerlink" title="图形界面编辑配置文件"></a>图形界面编辑配置文件</h2><p>安装 dconf-editor。</p>
<h2 id="配置-Exchange"><a href="#配置-Exchange" class="headerlink" title="配置 Exchange"></a>配置 Exchange</h2><p>为 ThunderBird 安装插件 ExQuilla，有时被墙。</p>
<p><a href="http://mesquilla.net/exquilla-currentrelease-tb-linux.xpi">http://mesquilla.net/exquilla-currentrelease-tb-linux.xpi</a></p>
<h2 id="安装和配置-JDK"><a href="#安装和配置-JDK" class="headerlink" title="安装和配置 JDK"></a>安装和配置 JDK</h2><p>在 Terminal 运行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">sudo add-apt-repository ppa:webupd8team/java<br>sudo apt-get update<br>sudo apt-get install oracle-java8-installer<br><br>sudo vim /etc/profile<br><br><span class="hljs-built_in">export</span> JAVA_HOME=/usr/lib/jvm/java-8-oracle<br><span class="hljs-built_in">export</span> JRE_HOME=<span class="hljs-variable">$JAVA_HOME</span>/jre<br><span class="hljs-built_in">export</span> CLASSPATH=.:<span class="hljs-variable">$JAVA_HOME</span>/lib:<span class="hljs-variable">$JRE_HOME</span>/lib<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$JAVA_HOME</span>/bin:<span class="hljs-variable">$JRE_HOME</span>/bin:<span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure>

<h2 id="配置-adt"><a href="#配置-adt" class="headerlink" title="配置 adt"></a>配置 adt</h2><p>安装兼容 32 位 adb 运行的环境</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">sudo apt-get install lib32z1 lib32ncurses5 lib32bz2-1.0 lib32stdc++6<br></code></pre></td></tr></table></figure>

<p>添加路径到 $PATH 环境变量，修改 /etc/profile 或 ~/.profile 等皆可。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">ANDROID_SDK_HOME</span>=/home/mzlogin/android/sdk<br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$ANDROID_SDK_HOME</span>/platform-tools:$ANDROID_SDK_HOME/tools:$PATH<br></code></pre></td></tr></table></figure>

<h2 id="安装-SVN-图形前端-RabbitVCS"><a href="#安装-SVN-图形前端-RabbitVCS" class="headerlink" title="安装 SVN 图形前端 RabbitVCS"></a>安装 SVN 图形前端 RabbitVCS</h2><p>在 Terminal 运行：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">sudo add-apt-repository ppa:rabbitvcs/ppa<br>sudo apt-get update<br>sudo apt-get install rabbitvcs-nautilus3 rabbitvcs-thunar rabbitvcs-gedit rabbitvcs-cli<br></code></pre></td></tr></table></figure>

<h2 id="创建-eclipse-快捷方式"><a href="#创建-eclipse-快捷方式" class="headerlink" title="创建 eclipse 快捷方式"></a>创建 eclipse 快捷方式</h2><p>/usr/share/applications 里新建 Eclipse.desktop，填如下内容：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Desktop Entry]</span><br><span class="hljs-attr">Name</span>=Eclipse<br><span class="hljs-attr">Comment</span>=Launch Eclipse<br><span class="hljs-attr">Exec</span>=/home/mzlogin/android/eclipse/eclipse<br><span class="hljs-attr">Icon</span>=/home/mzlogin/android/eclipse/icon.xpm<br><span class="hljs-attr">StartupNotify</span>=<span class="hljs-literal">true</span><br><span class="hljs-attr">Terminal</span>=<span class="hljs-literal">false</span><br><span class="hljs-attr">Type</span>=Application<br></code></pre></td></tr></table></figure>

<h2 id="安装-XMind"><a href="#安装-XMind" class="headerlink" title="安装 XMind"></a>安装 XMind</h2><p>到 XMind 官网下载安装包，然后 ：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">sudo dpkg --ignore-depends=lame,libwebkitgtk-1.0-0 -i xmind-linux-3.5.0.201410310637_amd64.deb<br></code></pre></td></tr></table></figure>

<h2 id="切换输入法"><a href="#切换输入法" class="headerlink" title="切换输入法"></a>切换输入法</h2><p>添加一个英文，一个五笔，将切换到上一个源和下一个源的快捷键分别设为左和右 Shift，这样就可以使用左右 Shift 在中英之间来回切换了。</p>
<p>安装 im-switch 会导致语言支持被移除，恢复用 <code>sudo apt-get install language-selector-gnome</code>。</p>
<h2 id="消除启动-gVim-在-terminal-中的警告"><a href="#消除启动-gVim-在-terminal-中的警告" class="headerlink" title="消除启动 gVim 在 terminal 中的警告"></a>消除启动 gVim 在 terminal 中的警告</h2><p>安装 vim-gnome 后运行 gVim 会提示：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">GLib-GObject-<span class="hljs-built_in">WARNING</span> **: Attempt <span class="hljs-keyword">to</span> <span class="hljs-keyword">add</span> property GnomeProgram::sm-<span class="hljs-keyword">connect</span> <span class="hljs-keyword">after</span> <span class="hljs-keyword">class</span> was initialised<br></code></pre></td></tr></table></figure>

<p>改为安装 vim-gtk 就好了。</p>
<h2 id="解决-ibus-五笔候选词水平显示和个数的问题"><a href="#解决-ibus-五笔候选词水平显示和个数的问题" class="headerlink" title="解决 ibus 五笔候选词水平显示和个数的问题"></a>解决 ibus 五笔候选词水平显示和个数的问题</h2><p>修改 /usr/share/ibus-table/tables/wubi-jidian86.db 的 ime 表里的 orientation（水平 0 垂直 1）和 select_keys（有几个选择键就有几个项，从下面代码可知用 <code>,</code> 分隔）。</p>
<p>/usr/share/ibus-tables/engine/tabsqlitedb.py 中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_page_size</span> (<span class="hljs-params">self</span>):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.get_select_keys().split(<span class="hljs-string">&#x27;,&#x27;</span>))<br></code></pre></td></tr></table></figure>

<h2 id="将-Caps-Lock-映射为-Ctrl"><a href="#将-Caps-Lock-映射为-Ctrl" class="headerlink" title="将 Caps Lock 映射为 Ctrl"></a>将 Caps Lock 映射为 Ctrl</h2><ol>
<li><p>安装 Gnome Tweak Tool</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">sudo apt-get install gnome-tweak-tool<br></code></pre></td></tr></table></figure></li>
<li><p>打开 tweak-tool，找到「打字」－「大写锁定键行为」，选择「将 CapsLock 作为额外的 Ctrl」</p>
</li>
</ol>
<p>参考 <a href="http://askubuntu.com/questions/462021/how-do-i-turn-caps-lock-into-an-extra-control-key">http://askubuntu.com/questions/462021/how-do-i-turn-caps-lock-into-an-extra-control-key</a></p>
<h2 id="将个人文件夹下文件夹名改为英文"><a href="#将个人文件夹下文件夹名改为英文" class="headerlink" title="将个人文件夹下文件夹名改为英文"></a>将个人文件夹下文件夹名改为英文</h2><p>~ 目录下的「桌面」和「文档」等文件夹是中文，在 Terminal 下输入很不方便，将其改为英文的方法：</p>
<ol>
<li><p>打开 ~/.config/user-dirs.dirs，将其中的中文改掉：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">XDG_DESKTOP_DIR</span>=<span class="hljs-string">&quot;$HOME/desktop&quot;</span><br><span class="hljs-attr">XDG_DOWNLOAD_DIR</span>=<span class="hljs-string">&quot;$HOME/downloads&quot;</span><br><span class="hljs-attr">XDG_TEMPLATES_DIR</span>=<span class="hljs-string">&quot;$HOME/templates&quot;</span><br><span class="hljs-attr">XDG_PUBLICSHARE_DIR</span>=<span class="hljs-string">&quot;$HOME/public&quot;</span><br><span class="hljs-attr">XDG_DOCUMENTS_DIR</span>=<span class="hljs-string">&quot;$HOME/documents&quot;</span><br><span class="hljs-attr">XDG_MUSIC_DIR</span>=<span class="hljs-string">&quot;$HOME/music&quot;</span><br><span class="hljs-attr">XDG_PICTURES_DIR</span>=<span class="hljs-string">&quot;$HOME/pictures&quot;</span><br><span class="hljs-attr">XDG_VIDEOS_DIR</span>=<span class="hljs-string">&quot;$HOME/videos&quot;</span><br></code></pre></td></tr></table></figure></li>
<li><p>在文件管理器中将 HOME 目录下的中文文件夹名改成与上面的配置对应。</p>
</li>
</ol>
<h2 id="输入「」与『』"><a href="#输入「」与『』" class="headerlink" title="输入「」与『』"></a>输入「」与『』</h2><p>极点五笔中文输入状态下，按 [] 即输入「」，按 {} 即输入『』。</p>
<h2 id="VirtualBox-里-Ubuntu-分辨率无法调整"><a href="#VirtualBox-里-Ubuntu-分辨率无法调整" class="headerlink" title="VirtualBox 里 Ubuntu 分辨率无法调整"></a>VirtualBox 里 Ubuntu 分辨率无法调整</h2><p>Ubuntu 14.04 LTS 在 VirtualBox 中刚安装完时，分辨率只有 640*480 一种选项，无法调整。</p>
<p>解决方法：</p>
<ol>
<li><p>打开 xdiagnose</p>
<p><img src="/images/posts/linux/xdiagnose.png"></p>
</li>
<li><p>勾选 Debug 下的所有选项</p>
<p><img src="/images/posts/linux/xdiagnose-2.png"></p>
</li>
<li><p>重启</p>
</li>
<li><p>安装增强功能</p>
<p><img src="/images/posts/linux/install-additions.png"></p>
<p>然后：</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> <span class="hljs-string">/media/</span>&lt;username&gt;<span class="hljs-string">/VBOXADDITIONS_X.X.XX_XXXXX</span><br>sudo <span class="hljs-string">./VBoxLinuxAdditions.run</span><br></code></pre></td></tr></table></figure>

<p>（注意把 username 替换成自己的，VBOXADDITIONS 后面的 X 换成具体版本号）</p>
</li>
</ol>
<h2 id="与-Win7-共享-SSH-key"><a href="#与-Win7-共享-SSH-key" class="headerlink" title="与 Win7 共享 SSH key"></a>与 Win7 共享 SSH key</h2><p>如下步骤适用于在 Ubuntu 上使用从 Win7 拷贝的 SSH key，反之应该也一样能用。</p>
<p>创建 ~/.ssh 目录，确认其权限为 0700，将 Windows %userprofile%/.ssh 下的 id_rsa 和 id_rsa.pub 文件拷贝到 ~/.ssh 目录下，权限分别改为 0600 和 0644。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">mzlogin@ubuntu:~$ ll ~/.ssh<br>total 20<br>drwx------  2 mzlogin mzlogin 4096 Jun 22 01:03 ./<br>drwxr-xr-x 20 mzlogin mzlogin 4096 Jun 22 01:02 ../<br>-rw-------  1 mzlogin mzlogin 1679 Jun 21 05:17 id_rsa<br>-rw-r--r--  1 mzlogin mzlogin  399 Jun 21 05:17 id_rsa.pub<br></code></pre></td></tr></table></figure>

<p>然后</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh">ssh-add ~/.ssh/id_rsa<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux, Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>为 Markdown 生成 TOC 的 Vim 插件</title>
    <url>/2015/12/19/Vim/vim-markdown-toc/</url>
    <content><![CDATA[<p>因为饱受 GFM 和 Redcarpet 两种 Markdown 引擎生成 TOC 链接的差异的折磨，而我又不得不同时使用它们——博客基于 Jekyll 使用 Redcarpet（<em>Update 2016/09/16: GitHub Pages 现在已经改为只支持 kramdown</em>），而其它放在 GitHub 仓库里的文档使用 GFM，我决定为我常用的 Markdown 编辑器 Vim 做一款同时支持 GFM 和 Redcarpet 两种 TOC 链接风格的 Table of Contents 自动生成插件。</p>
<p>这算是我真正意义上完全独立开发的第一款实用 Vim 插件，当然开发过程中也参考了别人的做法。</p>
<h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><ul>
<li><a href="https://github.com/mzlogin/vim-markdown-toc">vim-markdown-toc</a></li>
</ul>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul>
<li><p>为 Markdown 文件生成 Table of Contents，目前支持 GFM 和 Redcarpet 两种链接风格。</p>
</li>
<li><p>更新已经存在的 Table of Contents。</p>
</li>
<li><p>保存文件时自动更新 Table of Contents。</p>
</li>
</ul>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><h3 id="生成-Table-of-Contents"><a href="#生成-Table-of-Contents" class="headerlink" title="生成 Table of Contents"></a>生成 Table of Contents</h3><p>将光标移动到想在后面插入 Table of Contents 的那一行，然后运行下面的某个命令：</p>
<ol>
<li><p><code>:GenTocGFM</code></p>
<p>生成 GFM 链接风格的 Table of Contents。</p>
<p>适用于 GitHub 仓库里的 Markdown 文件，比如 README.md，也适用用于生成 GitBook 的 Markdown 文件。</p>
</li>
<li><p><code>:GenTocRedcarpet</code></p>
<p>生成 Redcarpet 链接风格的 Table of Contents。</p>
<p>适用于使用 Redcarpet 作为 Markdown 引擎的 Jekyll 项目或其它地方。</p>
</li>
</ol>
<h3 id="更新已存在的-Table-of-Contents"><a href="#更新已存在的-Table-of-Contents" class="headerlink" title="更新已存在的 Table of Contents"></a>更新已存在的 Table of Contents</h3><p>通常不需要手动做这件事，保存文件时会自动更新已经存在的 Table of Contents。</p>
<p>除非是在配置里关闭了保存时自动更新，并且维持插入 Table of Contents 前后的 <code>&lt;!-- vim-markdown-toc --&gt;</code>，此时可使用 <code>:UpdateToc</code> 命令手动更新。</p>
<h3 id="删除-Table-of-Contents"><a href="#删除-Table-of-Contents" class="headerlink" title="删除 Table of Contents"></a>删除 Table of Contents</h3><p><code>:RemoveToc</code> 命令可以帮你删除本插件生成的 Table of Contents。</p>
<h2 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h2><p>推荐使用 <a href="http://github.com/VundleVim/Vundle.Vim">Vundle</a> 来管理你的 Vim 插件，这样你就可以简单三步完成安装：</p>
<ol>
<li><p>在你的 vimrc 文件中添加如下内容：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">Plugin</span> <span class="hljs-string">&#x27;mzlogin/vim-markdown-toc&#x27;</span><br></code></pre></td></tr></table></figure></li>
<li><p><code>:so $MYVIMRC</code></p>
</li>
<li><p><code>:PluginInstall</code></p>
</li>
</ol>
<p>使用 vim-plug 安装的过程的与此基本一样。</p>
<h2 id="配置选项"><a href="#配置选项" class="headerlink" title="配置选项"></a>配置选项</h2><ol>
<li><p><code>g:vmt_auto_update_on_save</code></p>
<p>默认值：1</p>
<p>插件会自动更新已经存在的 Table of Contents，如果你不想要这个功能，可以在你的 vimrc 文件里加入如下内容关闭：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs viml">let g:vmt_auto_update_on_save = 0<br></code></pre></td></tr></table></figure></li>
<li><p><code>g:vmt_dont_insert_fence</code></p>
<p>默认值：0</p>
<p>在默认情况下，<code>:GenTocXXX</code> 命令会在插入的 Table of Contents 前后加上 <code>&lt;!-- vim-markdown-toc --&gt;</code>，这是为了实现自动和手动更新 Table of Contents 功能。</p>
<p>如果你不想看到它们，可以在 vimrc 文件里加入如下内容移除：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs viml">let g:vmt_dont_insert_fence = 1<br></code></pre></td></tr></table></figure>

<p>需要注意的是移除之后插件将无法再帮你保存文件时自动更新 Table of Contents 了，也无法使用 <code>:UpdateToc</code> 命令了。这里如果还想更新 Table of Contents，只能先手动删除已经存在的，然后重新运行 <code>:GenTocXXX</code> 命令。</p>
</li>
<li><p><code>g:vmt_cycle_list_item_markers</code></p>
<p>默认值：0</p>
<p>在默认情况下，所有 Table of Contents 项目前面的标记都是 <code>*</code>：</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><code class="hljs subunit">* [Level 1](#level<span class="hljs-string">-1</span>)<br>    * [Level 1<span class="hljs-string">-1</span>](#level<span class="hljs-string">-1</span><span class="hljs-string">-1</span>)<br>    * [Level 1<span class="hljs-string">-2</span>](#level<span class="hljs-string">-1</span><span class="hljs-string">-2</span>)<br>        * [Level 1<span class="hljs-string">-2</span><span class="hljs-string">-1</span>](#level<span class="hljs-string">-1</span><span class="hljs-string">-2</span><span class="hljs-string">-1</span>)<br>* [Level 2](level<span class="hljs-string">-2</span>)<br></code></pre></td></tr></table></figure>

<p>这里提供一个选项改变这个行为，如果设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs viml">let g:vmt_cycle_list_item_markers = 1<br></code></pre></td></tr></table></figure>

<p>那标记将根据级别循环使用 <code>*</code>、<code>-</code> 和 <code>+</code>：</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><code class="hljs subunit">* [Level 1](#level<span class="hljs-string">-1</span>)<br>    - [Level 1<span class="hljs-string">-1</span>](#level<span class="hljs-string">-1</span><span class="hljs-string">-1</span>)<br>    - [Level 1<span class="hljs-string">-2</span>](#level<span class="hljs-string">-1</span><span class="hljs-string">-2</span>)<br>        + [Level 1<span class="hljs-string">-2</span><span class="hljs-string">-1</span>](#level<span class="hljs-string">-1</span><span class="hljs-string">-2</span><span class="hljs-string">-1</span>)<br>* [Level 2](level<span class="hljs-string">-2</span>)<br></code></pre></td></tr></table></figure>

<p>这不会影响 Markdown 文档解析后的显示效果，只用于提升源文件的可读性。</p>
</li>
</ol>
<h2 id="屏幕截图"><a href="#屏幕截图" class="headerlink" title="屏幕截图"></a>屏幕截图</h2><p><a href="https://github.com/mzlogin/chinese-copywriting-guidelines/blob/Simplified/README.en.md">使用本插件生成 TOC 的英文文档在线示例</a></p>
<p><img src="https://github.com/mzlogin/vim-markdown-toc/raw/master/screenshots/english.gif"></p>
<p><a href="https://mazhuang.org/wiki/chinese-copywriting-guidelines/">使用本插件生成 TOC 的中文文档在线示例</a></p>
<p><img src="https://github.com/mzlogin/vim-markdown-toc/raw/master/screenshots/chinese.gif"></p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a href="https://mazhuang.org/2015/12/05/diff-between-gfm-and-redcarpet/">GFM 与 Redcarpet 的不同点</a></li>
<li><a href="https://github.com/ajorgensen/vim-markdown-toc">ajorgensen/vim-markdown-toc</a></li>
</ul>
]]></content>
      <categories>
        <category>Vim</category>
      </categories>
      <tags>
        <tag>vim, markdown, toc</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac 遇到问题集锦</title>
    <url>/2015/10/25/Mac/mac/</url>
    <content><![CDATA[<ol>
<li><p>在桌面和 Finder 底部出现的神秘白条是怎么回事，如何消除？</p>
<p><img src="/images/posts/mac/white-rectangle.jpg"></p>
<p>它可以拖动，可以拉伸改变形状，并不知道它属于哪个程序，一旦出现在 Finder 底部和桌面都会存在。</p>
<p>经过尝试，发现它出现的步骤是这样的：</p>
<ul>
<li>在 Finder 中点击一下空白区域，然后使用中文输入法打字。</li>
<li>在文字还没有上屏时出切换到英文输入状态。</li>
<li>用鼠标点击空白区域。</li>
</ul>
<p>目前试验了「搜狗五笔」和 Mac 自带的「五笔型」均是如此，看来应该是系统的 Bug。</p>
<p><strong>消除方法：</strong>点击白条后 Esc。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>定制 Fiddler 之按设备过滤请求</title>
    <url>/2015/07/08/Fiddler/fiddler-filter-by-device/</url>
    <content><![CDATA[<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>在开发/测试过程中有多台设备（PC/手机/模拟器）通过 Fiddler 代理上网时，如何方便地从满屏纷飞的 Session 中筛选出自己关心的那台设备的请求？</p>
<h3 id="设想"><a href="#设想" class="headerlink" title="设想"></a>设想</h3><p>通过 FiddlerScript 扩展，在 Session 的右键弹出菜单中添加一项，作为「查看所有设备请求」和「查看单个设备请求」的切换开关。</p>
<p><em>设计操作流程：</em></p>
<ol>
<li><p>找到自己关心的设备发出的某一条请求，在它的右键弹出菜单里有我们添加的菜单项「开/关过滤单设备请求」。</p>
</li>
<li><p>点击该菜单项后：</p>
<ul>
<li>若当前状态为「查看所有设备请求」，则切换为「查看单个设备请求」状态，该设备为此条请求的发送者，并清除当前已显示的所有不关心的设备的请求。</li>
<li>若当前状态为「查看单个设备请求」，则切换为「查看所有设备请求」状态。</li>
</ul>
</li>
</ol>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><em>实现思路：</em></p>
<ul>
<li><p>通过修改 CustomRules.js，在右键弹出菜单上添加一个菜单项来切换请求筛选状态。</p>
</li>
<li><p>每一条请求都带有 ClientIP，它在没有网络切换之类的情况发生时能较好地唯一标识一台设备。</p>
</li>
<li><p>筛选规则是将非来自该 ClientIP 的请求隐藏掉。</p>
</li>
</ul>
<p><em>实现步骤：</em></p>
<ol>
<li><p>打开 CustomRules.js。</p>
<p>启动Fiddler，依次选择菜单 Rules &gt; Customize Rules…</p>
</li>
<li><p>在 <code>OnBeforeRequest</code> 前添加如下代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 是否过滤单设备请求标志</span><br>public <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> gs_FilterDevice: boolean = <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 显示请求的设备的 ClientIP</span><br>public <span class="hljs-keyword">static</span> <span class="hljs-keyword">var</span> gs_FilterClientIP: <span class="hljs-built_in">String</span> = <span class="hljs-literal">null</span>;<br><br><span class="hljs-keyword">static</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">IsUnMatchClientIP</span>(<span class="hljs-params">oS:Session</span>):<span class="hljs-title">Boolean</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (oS.m_clientIP != gs_FilterClientIP);<br>&#125;<br><br>public <span class="hljs-keyword">static</span> ContextAction(<span class="hljs-string">&quot;开/关过滤单设备请求&quot;</span>)<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ToggleDeviceFilter</span>(<span class="hljs-params">oSessions: Fiddler.Session[]</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span> (gs_FilterDevice) &#123;<br>        gs_FilterDevice = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">var</span> oS: Session = FiddlerApplication.UI.GetFirstSelectedSession();<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == oS) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">if</span> (!gs_FilterDevice) &#123;<br>        gs_FilterDevice = <span class="hljs-literal">true</span>;<br>    &#125;<br>    gs_FilterClientIP = oS.clientIP;<br><br>    <span class="hljs-comment">// 删除当前已显示的非所关心设备的请求</span><br>    FiddlerApplication.UI.actSelectSessionsMatchingCriteria(IsUnMatchClientIP);<br>    FiddlerApplication.UI.actRemoveSelectedSessions();<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>在 <code>OnBeforeRequest</code> 函数里添加如下代码，用于在「查看单个设备请求」状态时将不关心的设备产生的新请求隐藏：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (gs_FilterDevice &amp;&amp; oSession.m_clientIP != gs_FilterClientIP) &#123;<br>    oSession[<span class="hljs-string">&quot;ui-hide&quot;</span>] = <span class="hljs-string">&quot;true&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<p><em>最终效果如下图：</em></p>
<ul>
<li><p>筛选前</p>
<p><img src="/images/posts/fiddler/fiddler-filter-by-device-before.png"></p>
</li>
<li><p>筛选后</p>
<p><img src="/images/posts/fiddler/fiddler-filter-by-device-after.png"></p>
</li>
</ul>
<h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p>当前做法有如下缺陷，尚未想到好办法解决：  </p>
<ul>
<li><p>菜单项并不能标明当前的状态，不知道筛选是开是关，这可以通过查看当前 Session 列表里是否有多种设备的请求来判断。</p>
</li>
<li><p>当设备有网络切换时，比如重启了路由或者离开又回到某 Wifi，ClientIP 可能发生了变化，需要关闭筛选后在设备以新的 ClientIP 产生的请求上右键再次开启筛选。</p>
</li>
</ul>
<h3 id="附注"><a href="#附注" class="headerlink" title="附注"></a>附注</h3><p>我使用的完整最新的 CustomRules.js 文件我上传到了一个 Gist 里，详见：<a href="https://gist.github.com/mzlogin/3c5f9781c5bedff3fcfb">https://gist.github.com/mzlogin/3c5f9781c5bedff3fcfb</a>，如果想直接使用可以复制脚本内容后放置到「我的文档/Fiddler 2/Scripts/CustomRules.js」，也可以在此目录下使用 git 抓取我的最新定制 js 文件。</p>
]]></content>
      <categories>
        <category>Fiddler</category>
      </categories>
      <tags>
        <tag>Fiddler, Filter, Device</tag>
      </tags>
  </entry>
  <entry>
    <title>TortoiseSVN 从 GitHub 更新时发生异常</title>
    <url>/2015/05/27/SVN/svn-exception/</url>
    <content><![CDATA[<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>使用 TortoiseSVN 从 GitHub 仓库 Update 时，弹出错误提示对话框：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-code">---------------------------</span><br><span class="hljs-code">Subversion Exception!</span><br><span class="hljs-code">---------------------------</span><br>Subversion encountered a serious problem.<br>Please take the time to report this on the Subversion mailing list<br>with as much information as possible about what<br>you were trying to do.<br>But please first search the mailing list archives for the error message<br>to avoid reporting the same problem repeatedly.<br>You can find the mailing list archives at<br>http://subversion.apache.org/mailing-lists.html<br><br>Subversion reported the following<br>(you can copy the content of this dialog<br>to the clipboard using Ctrl-C):<br><br>In file<br><span class="hljs-code"> &#x27;D:\Development\SVN\Releases\TortoiseSVN-1.8.11\ext\subversion\subversion\libsvn_wc\update_editor.c&#x27;</span><br><span class="hljs-section"> line 1550: assertion failed (action == svn_wc_conflict_action_delete)</span><br><span class="hljs-section">---------------------------</span><br><span class="hljs-section">确定   </span><br><span class="hljs-section">---------------------------</span><br></code></pre></td></tr></table></figure>

<p>推测发生原因可能是 GitHub 认为本地的目录结构与服务器冲突，因为能看到本地之前 Checkout 出来的一个文件夹显示未纳入版本控制，但是实际上服务器上这个文件夹一直存在在。</p>
<p>查到在一个 <a href="http://mail-archives.apache.org/mod_mbox/subversion-users/201503.mbox/%3C076701d05e91$234ef3b0$69ecdb10$@qqmail.nl%3E">邮件列表</a> 里说这是由 GitHub 的实现有点问题导致，但是，也如其它地方能查到的信息一样，并没有给出解决方案。</p>
<p>经过各种尝试，包括</p>
<ol>
<li><p>Clean up</p>
<p>Clean up 本身能成功，但是再 Update 依然报错。</p>
</li>
<li><p>在一个新的文件夹 Checkout</p>
<p>没有问题。</p>
</li>
<li><p>删除可疑文件和文件夹，重新 Update。</p>
<p>依然报错。</p>
</li>
</ol>
<p>无奈之下试了一下命令行，找到了解决办法。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>其实很简单，就是使用命令行</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">svn cleanup</span><br><span class="hljs-attribute">svn update</span><br></code></pre></td></tr></table></figure>

<p>就可以了，再使用 GUI 的 Update 就不会报错了。</p>
<p>为啥就好了仍然原因不明。</p>
<h3 id="最新情况"><a href="#最新情况" class="headerlink" title="最新情况"></a>最新情况</h3><p>后来又出现了一次这样的情况，在命令行 <code>svn update</code> 也不好使了，提示</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh">svn: E155010: The <span class="hljs-keyword">node</span> <span class="hljs-title">&#x27;a</span>/folder/path/&#x27; was not found.<br></code></pre></td></tr></table></figure>

<p>忍无可忍，切回使用 git。</p>
]]></content>
      <categories>
        <category>SVN</category>
      </categories>
      <tags>
        <tag>TortoiseSVN, github</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 日期类常用写法小结</title>
    <url>/2015/04/03/Java/java-date/</url>
    <content><![CDATA[<p><strong>Date 和 Calendar 转 String</strong></p>
<p>借助 SimpleDateFormat 类的 format 方法，Calendar.getTime() 返回 Date，最终 Calendar 也是转化为 Date 后转 String。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// see SimpleDateFormat in Java API</span><br>String format = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(format, Locale.US);<br><br><span class="hljs-comment">// Date</span><br>String strDate = sdf.format(<span class="hljs-keyword">new</span> Date());<br><br>Calendar cal = Calendar.getInstance();<br><span class="hljs-comment">// Calendar</span><br>String strCalendar = sdf.format(cal.getTime());<br></code></pre></td></tr></table></figure>

<p><strong>String 转 Date、Calendar</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">String strDate = <span class="hljs-string">&quot;2015-04-04 00:33:00&quot;</span>;<br>Date date = <span class="hljs-keyword">null</span>;<br>Calendar cal = Calendar.getInstance();<br><span class="hljs-keyword">try</span> &#123;<br>    SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>, Locale.US);<br>    date = sdf.parse(strDate);<br>    cal.setTime(date);<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>设置 Calendar 到某年某月某日</strong></p>
<p>注意点：</p>
<ul>
<li>Month 要设为比实际小 1。</li>
<li>除显式设置的几个字段外，其它字段之前的值不变；如果不是期待的，可以先调用 clear() 清除。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Calendar cal = Calendar.getInstance();<br><span class="hljs-comment">// set to 2015-03-01</span><br>cal.set(<span class="hljs-number">2015</span>, <span class="hljs-number">3</span> - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>

<p><strong>复制 Calendar</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Calendar calDst = (Calendar)calSrc.clone();<br></code></pre></td></tr></table></figure>

<p><strong>求本周、上周、下周的起始时间</strong></p>
<p>做了一个工具类来处理此事（注意：这里计算的一周是从周一到周日，如果要算周天到周六，把获取本周一时括号里的 +1 去掉）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DateCalcUtil</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> GET_PREVIOUS_MONDAY = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> GET_PREVIOUS_SUNDAY = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> GET_THIS_MONDAY = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> GET_THIS_SUNDAY = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> GET_NEXT_MONDAY = <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> GET_NEXT_SUNDAY = <span class="hljs-number">5</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Calendar <span class="hljs-title">calc</span><span class="hljs-params">(Calendar base, <span class="hljs-keyword">int</span> calcType)</span> </span>&#123;<br>        <span class="hljs-comment">// 获取这一周开始基准</span><br>        <span class="hljs-keyword">int</span> min = base.getActualMinimum(Calendar.DAY_OF_WEEK);<br>        <span class="hljs-comment">// 获取当天在这一周内天数</span><br>        <span class="hljs-keyword">int</span> current = base.get(Calendar.DAY_OF_WEEK);<br>        Calendar calendar = (Calendar)base.clone();<br><br>        <span class="hljs-comment">// 获取本周一</span><br>        <span class="hljs-keyword">int</span> nCount = (current == min) ? -<span class="hljs-number">6</span> : (min - current + <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">switch</span> (calcType) &#123;<br>            <span class="hljs-keyword">case</span> GET_PREVIOUS_MONDAY:<br>                nCount -= <span class="hljs-number">7</span>;<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">case</span> GET_PREVIOUS_SUNDAY:<br>                nCount -= <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">case</span> GET_THIS_MONDAY:<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">case</span> GET_THIS_SUNDAY:<br>                nCount += <span class="hljs-number">6</span>;<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">case</span> GET_NEXT_MONDAY:<br>                nCount += <span class="hljs-number">7</span>;<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">case</span> GET_NEXT_SUNDAY:<br>                nCount += <span class="hljs-number">13</span>;<br>                <span class="hljs-keyword">break</span>;<br><br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        calendar.add(Calendar.DAY_OF_WEEK, nCount);<br><br>        <span class="hljs-keyword">return</span> calendar;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 今天</span><br>Calendar base = Calendar.getInstance();<br><br><span class="hljs-comment">// 本周</span><br>Calendar thisMonday = DateCalcUtil.calc(base, DateCalcUtil.GET_THIS_MONDAY);<br>Calendar thisSunday = DateCalcUtil.calc(base, DateCalcUtil.GET_THIS_SUNDAY);<br><br><span class="hljs-comment">// 下周</span><br>Calendar nextMonday = DateCalcUtil.calc(base, DateCalcUtil.GET_NEXT_MONDAY);<br>Calendar nextSunday = DateCalcUtil.calc(base, DateCalcUtil.GET_NEXT_SUNDAY);<br><br><span class="hljs-comment">// 上周</span><br>Calendar previousMonday = DateCalcUtil.calc(base, DateCalcUtil.GET_PREVIOUS_MONDAY);<br>Calendar previousSunday = DateCalcUtil.calc(base, DateCalcUtil.GET_PREVIOUS_SUNDAY);<br></code></pre></td></tr></table></figure>

<p><strong>获取两个日期相差天数</strong></p>
<p>注意点：</p>
<ul>
<li>getTimeInMillis 返回的是 0 时区时间，所以有可能把你的时间加减了几个小时，造成计算天数有误，这种方法必须考虑时区因素再运算。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">long</span> daysCount1 = (calendar1.getTimeInMillis() + calendar1.get(Calendar.ZONE_OFFSET))<br>    / (<span class="hljs-number">24</span> * <span class="hljs-number">3600</span> * <span class="hljs-number">1000</span>);<br><span class="hljs-keyword">long</span> daysCount2 = (calendar2.getTimeInMillis() + calendar2.get(Calendar.ZONE_OFFSET))<br>    / (<span class="hljs-number">24</span> * <span class="hljs-number">3600</span> * <span class="hljs-number">1000</span>);<br><span class="hljs-keyword">long</span> dayDiffer = daysCount1 - daysCount2;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java, 日期</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows 实现单实例进程的两种方法</title>
    <url>/2015/03/21/Windows/singleton-process/</url>
    <content><![CDATA[<p><strong>方法一：共享静态数据。</strong></p>
<p>此方法参见《Windows 核心编程》第 5 版 17.1.2 章节《在同一个可执行文件或 DLL 的多个实例间共享静态数据》。</p>
<p>实现原理：</p>
<p>创建一个自己命名的段，将其属性改为 READ|WRITE|SHARED，其中 SHARED 属性表示该段的内容为多个实例所共享（实际上关闭了写时复制机制），将变量放在该段内若值被改变，多个实例间都会受到改变的影响。</p>
<p>注意点：</p>
<ul>
<li>最好使用 volatile 修饰变量。</li>
<li>对变量的增减推荐使用原子操作函数 InterlockedExchangedAdd。</li>
<li>g_lInstances 的值在第一个实例运行时总为 0，其它实例中取到的值以先于它运行的实例中改变后的值为准。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> data_seg(<span class="hljs-meta-string">&quot;Shared&quot;</span>)</span><br><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> g_lInstances = <span class="hljs-number">0</span>;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> data_seg()</span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> comment(linker, <span class="hljs-meta-string">&quot;/Section:Shared,RWS&quot;</span>)</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (g_lInstances != <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-built_in">InterlockedExchangeAdd</span>(&amp;g_lInstances, <span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// do something here</span><br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-built_in">InterlockedExchangeAdd</span>(&amp;g_lInstances, <span class="hljs-number">-1</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>方法二：使用 Mutex。</strong></p>
<p>理论上能用于进程间同步的内核对象比如事件和互斥量等都能用于实现此功能，此处使用互斥量 Mutex 举例。</p>
<p>实现原理：</p>
<p>使用操作系统范围内可见的命名内核对象，不同实例间检测同一个内核对象的状态来判断是否为当前唯一实例。</p>
<p>注意点：</p>
<ul>
<li>内核对象要使用全局命名，比如此处使用 Global 开头。</li>
</ul>
<p>示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    HANDLE hMutex = <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-keyword">do</span><br>    &#123;<br>        hMutex = <span class="hljs-built_in">CreateMutex</span>(<span class="hljs-literal">NULL</span>, FALSE, <span class="hljs-string">&quot;Global\\73E21C80-1960-472F-BF0B-3EE7CC7AF17E&quot;</span>);<br><br>        DWORD dwError = <span class="hljs-built_in">GetLastError</span>();<br><br>        <span class="hljs-keyword">if</span> (ERROR_ALREADY_EXISTS == dwError || ERROR_ACCESS_DENIED == dwError)<br>        &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// do something here</span><br>        <span class="hljs-comment">// ...</span><br><br>    &#125; <span class="hljs-keyword">while</span> (<span class="hljs-literal">false</span>);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">NULL</span> != hMutex)<br>    &#123;<br>        <span class="hljs-built_in">CloseHandle</span>(hMutex);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows, Process</tag>
      </tags>
  </entry>
</search>
